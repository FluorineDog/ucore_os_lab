0
00:00:00,000 --> 00:00:06,640


1
00:00:06,720 --> 00:00:07,560
好 我们接下来看看

2
00:00:07,600 --> 00:00:10,800
怎么来建立这个页的映射机制

3
00:00:10,840 --> 00:00:12,240
为了能够理解这个机制

4
00:00:12,280 --> 00:00:15,200
我们首先去了解一下我们整个这个

5
00:00:15,240 --> 00:00:17,080
X86 CPU里面怎么来完成

6
00:00:17,120 --> 00:00:19,200
基于页机制的一个地址映射的

7
00:00:19,240 --> 00:00:21,920
它的硬件操作过程怎么回事

8
00:00:21,960 --> 00:00:23,680
那可以看这幅图

9
00:00:23,720 --> 00:00:25,280
这里面假定已经建好了一个

10
00:00:25,320 --> 00:00:28,920
所谓的页目录表 页表

11
00:00:28,960 --> 00:00:32,440
这一块是它的物理内存

12
00:00:32,480 --> 00:00:36,960
对于一个地址 我们说一个虚拟地址

13
00:00:37,000 --> 00:00:38,600
它分了三块 分了三部分

14
00:00:38,640 --> 00:00:40,440
这实际上是一个典型的二级页表

15
00:00:40,480 --> 00:00:42,840
第一个是Offset这是32位的地址

16
00:00:42,880 --> 00:00:46,280
占了12位 那么中间的二级页表

17
00:00:46,320 --> 00:00:48,520
对应的页表项占了10位

18
00:00:48,560 --> 00:00:51,880
高的页目录项也占了10位

19
00:00:51,920 --> 00:00:54,680
那么高的这10位是用来去查找

20
00:00:54,720 --> 00:00:57,480
作为index查找这个页目录表里面的对应的项

21
00:00:57,520 --> 00:00:58,960
这叫PDE

22
00:00:59,000 --> 00:01:03,640
就是页目录的entry 在PDE记录什么信息

23
00:01:03,680 --> 00:01:07,640
PDE记录的是二级页表里面的起始地址

24
00:01:07,680 --> 00:01:08,760
可以放在这个地方

25
00:01:08,800 --> 00:01:10,480
所以说根据PDE里面的信息

26
00:01:10,520 --> 00:01:14,400
可以找到Page Table的起始地址

27
00:01:14,440 --> 00:01:18,520
同时根据第二级Table这里面的10位

28
00:01:18,560 --> 00:01:22,600
作为index来查这个Page Table对应的项

29
00:01:22,640 --> 00:01:24,320
称之为PTE

30
00:01:24,360 --> 00:01:27,160
这个PTE就是Page Table Entry

31
00:01:27,200 --> 00:01:28,160
它里面存的什么

32
00:01:28,200 --> 00:01:31,480
存的是你这个线性地址

33
00:01:31,520 --> 00:01:35,480
它所对应的一个页的起始地址

34
00:01:35,520 --> 00:01:36,720
这一个页大小多少

35
00:01:36,760 --> 00:01:38,040
其实由它的Offset可以算出来

36
00:01:38,080 --> 00:01:41,360
它12位 那意味着一个页的大小是4K

37
00:01:41,400 --> 00:01:43,520
那这里面PTE里面会存到

38
00:01:43,560 --> 00:01:45,480
这么一个页的起始地址

39
00:01:45,520 --> 00:01:48,680
它会按照4K地址来对齐

40
00:01:48,720 --> 00:01:50,440
那么这个作为Base Address

41
00:01:50,480 --> 00:01:51,800
来加上它Offset

42
00:01:51,840 --> 00:01:53,600
来形成最终的这个物理地址

43
00:01:53,640 --> 00:01:55,000
这就形成了物理地址

44
00:01:55,040 --> 00:01:58,560
这是说在X86里面完成的一个

45
00:01:58,600 --> 00:02:03,480
基于二级页表的一个地址映射关系

46
00:02:03,520 --> 00:02:05,560
那你可以看出来我们的硬件是

47
00:02:05,600 --> 00:02:08,400
这么来查找一个线性地址

48
00:02:08,440 --> 00:02:09,880
怎么转到一个物理地址

49
00:02:09,920 --> 00:02:12,120
那它为什么不是虚拟地址

50
00:02:12,160 --> 00:02:14,880
而称之为线性地址 大家想想

51
00:02:14,920 --> 00:02:16,920
因为我们前面说到了

52
00:02:16,960 --> 00:02:20,360
进入保护模式之后这个段机制是一定存在的

53
00:02:20,400 --> 00:02:23,960
即使这个00映射 我们说的对等映射存在

54
00:02:24,000 --> 00:02:26,200
你也不能说为此把段

55
00:02:26,240 --> 00:02:28,200
这个映射关系给取消掉

56
00:02:28,240 --> 00:02:30,800
这是它必须存在的一个很重要的原因

57
00:02:30,840 --> 00:02:33,800
也是为了上下兼容 所以这是线性地址

58
00:02:33,840 --> 00:02:35,120
那其实这个线性地址和

59
00:02:35,160 --> 00:02:38,720
我们说应用程序虚拟地址是一样的

60
00:02:38,760 --> 00:02:41,640
因为它是对等映射

61
00:02:41,680 --> 00:02:45,080
  

62
00:02:45,120 --> 00:02:48,040
我们既然知道了这么一个映射关系

63
00:02:48,080 --> 00:02:51,000
我们来看一看 看一个实际的例子

64
00:02:51,040 --> 00:02:53,440
怎么能够把一个所谓的线性地址

65
00:02:53,480 --> 00:02:57,480
或者是虚拟地址转换成一个物理地址

66
00:02:57,520 --> 00:03:02,360
那我们需要建好这个页目录表

67
00:03:02,400 --> 00:03:07,000
需要建好这个页表 以及才能找到对应的页

68
00:03:07,040 --> 00:03:10,720
那么页目录表和页表它其实也是4K大小

69
00:03:10,760 --> 00:03:13,200
那么每一项每一个PTE

70
00:03:13,240 --> 00:03:16,280
或者PTE是32位的一项

71
00:03:16,320 --> 00:03:18,800
那意味着4K存1024项

72
00:03:18,840 --> 00:03:20,640
那我们需要把这里面的信息填对了

73
00:03:20,680 --> 00:03:24,880
才使得对于一个虚拟的地址

74
00:03:24,920 --> 00:03:27,600
这是一个虚拟地址 32位的虚拟地址

75
00:03:27,640 --> 00:03:30,200
0xC后面是1234567

76
00:03:30,240 --> 00:03:31,440
这随便举了一个例子

77
00:03:31,480 --> 00:03:33,960
它这个虚拟地址对应的物理地址多少

78
00:03:34,000 --> 00:03:34,560
可以算出来

79
00:03:34,600 --> 00:03:35,840
它实际上是根据这里面的

80
00:03:35,880 --> 00:03:38,480
PDE PTE来算的

81
00:03:38,520 --> 00:03:43,720
首先来看一下 它的高10位

82
00:03:43,760 --> 00:03:46,040
它的高10位其实是这里面

83
00:03:46,080 --> 00:03:49,280
你数这10项实际上这10项

84
00:03:49,320 --> 00:03:51,480
它其实代表的是304

85
00:03:51,520 --> 00:03:52,760
需要注意了一下这个304

86
00:03:52,800 --> 00:03:54,960
那意味着我们需要查

87
00:03:55,000 --> 00:03:58,640
1024项里面的第0x304项

88
00:03:58,680 --> 00:04:01,440
找到这个地方之后这里面会存一个信息

89
00:04:01,480 --> 00:04:02,680
  

90
00:04:02,720 --> 00:04:08,120
这个信息比如说存的是0x233

91
00:04:08,160 --> 00:04:12,320
0x233它是按照4K来做一个偏移

92
00:04:12,360 --> 00:04:15,440
偏移了12位 向右偏移12位

93
00:04:15,480 --> 00:04:17,040
所以把它向左再偏移12位

94
00:04:17,080 --> 00:04:22,080
形成0x233000这么一个地址

95
00:04:22,120 --> 00:04:24,000
这个地址实际上是我们说

96
00:04:24,040 --> 00:04:28,880
它存的是Page Table的一个物理地址的基址

97
00:04:28,920 --> 00:04:30,520
找到这个Page Table之后

98
00:04:30,560 --> 00:04:33,080
我们的CPU会查中间10位

99
00:04:33,120 --> 00:04:37,800
中间10位实际上对应的是0x234

100
00:04:37,840 --> 00:04:39,160
234作为index

101
00:04:39,200 --> 00:04:41,480
找到PDE PDE存的什么

102
00:04:41,520 --> 00:04:45,320
存的是0x22333

103
00:04:45,360 --> 00:04:48,400
同样它也是按照4K对齐 右移了12位

104
00:04:48,440 --> 00:04:50,000
所以我们把它通过左移12位

105
00:04:50,040 --> 00:04:54,400
得到正确的你所对应的物理页的基址

106
00:04:54,440 --> 00:04:59,080
就是0x22333后面3个0正好是12位

107
00:04:59,120 --> 00:05:02,760
这是这个物理页的基址

108
00:05:02,800 --> 00:05:06,160
加上它的Offset Offset是它的低12位

109
00:05:06,200 --> 00:05:07,720
  

110
00:05:07,760 --> 00:05:12,600
0x567 那么合在一起就形成了最终的物理地址

111
00:05:12,640 --> 00:05:16,240
就是0x22333加上567

112
00:05:16,280 --> 00:05:19,480
这就是它的物理地址

113
00:05:19,520 --> 00:05:23,360
所以说可以看到我们需要在lab2里面

114
00:05:23,400 --> 00:05:25,960
来完成对这两个表的建立

115
00:05:26,000 --> 00:05:28,600
从而可以实现正确的映射关系

116
00:05:28,640 --> 00:05:31,240
  

117
00:05:31,280 --> 00:05:33,440
另外还要提醒一下 就是在这里面存的

118
00:05:33,480 --> 00:05:36,080
就比如说在页表项里面

119
00:05:36,120 --> 00:05:38,280
存放的地址内容是线性地址

120
00:05:38,320 --> 00:05:41,160
那这里面还有一点是

121
00:05:41,200 --> 00:05:45,960
第一个页目录的起始地址在哪儿

122
00:05:46,000 --> 00:05:46,760
这里面其实已经看到了

123
00:05:46,800 --> 00:05:50,160
它是一个特殊的寄存器 称之为CR3寄存器

124
00:05:50,200 --> 00:05:53,240
这个CR3寄存器来保存了

125
00:05:53,280 --> 00:05:56,480
页目录的表的起始地址

126
00:05:56,520 --> 00:05:59,160
那为什么只要一个CR3就够了呢

127
00:05:59,200 --> 00:06:01,040
因为它是二级页表 二级页表里面的

128
00:06:01,080 --> 00:06:04,960
页目录表这个4K的页目录表只有一个

129
00:06:05,000 --> 00:06:08,440
所以我们只需要一个CR3寄存器就够了

130
00:06:08,480 --> 00:06:09,760
  

131
00:06:09,800 --> 00:06:12,800
好 我们前面已经把页表的映射机制

132
00:06:12,840 --> 00:06:14,120
给大家做了一个介绍

133
00:06:14,160 --> 00:06:16,000
接下来我们可以看看对于页表 

134
00:06:16,040 --> 00:06:17,960
或者页目录表里面的一项

135
00:06:18,000 --> 00:06:21,080
到底包含了哪些关键信息 作为一个理解

136
00:06:21,120 --> 00:06:25,960
这里面列出来了页目录表项和页表项

137
00:06:26,000 --> 00:06:29,760
它的一个大致的属性的表示

138
00:06:29,800 --> 00:06:31,880
一共是32位 一个页表项

139
00:06:31,920 --> 00:06:33,600
和一个页目录表项是32位

140
00:06:33,640 --> 00:06:36,000
我们这里面除了关注它

141
00:06:36,040 --> 00:06:38,600
所谓的基址记录之外

142
00:06:38,640 --> 00:06:40,400
还需要关注里面的一些属性位

143
00:06:40,440 --> 00:06:44,080
因为基址 就是存放的无论是页的基址

144
00:06:44,120 --> 00:06:45,520
还是页表的基址

145
00:06:45,560 --> 00:06:48,440
物理页的基址 或者页表的基址都是20位

146
00:06:48,480 --> 00:06:51,360
还有剩下12位形成32位这么一项

147
00:06:51,400 --> 00:06:53,080
那么那12位其实很重要的信息

148
00:06:53,120 --> 00:06:56,160
就是低12位 低12位存了一些属性

149
00:06:56,200 --> 00:06:57,800
就你将来访问页的一些属性

150
00:06:57,840 --> 00:07:00,400
比如说这个页是否是只读的

151
00:07:00,440 --> 00:07:02,760
用R/W位来表示

152
00:07:02,800 --> 00:07:05,880
这个页是内核态访问的还是用户态能访问的

153
00:07:05,920 --> 00:07:09,240
那么有一个U/S 是user还是supervisor

154
00:07:09,280 --> 00:07:11,120
就是属于一般用户访问的

155
00:07:11,160 --> 00:07:12,400
还是超级用户访问的

156
00:07:12,440 --> 00:07:15,280
实际上就对应我们的用户态和内核态

157
00:07:15,320 --> 00:07:16,360
那么其实和我们前面说的

158
00:07:16,400 --> 00:07:18,720
段的安全保护机制有异曲同工之妙

159
00:07:18,760 --> 00:07:21,720
只是说基于段的保护机制它更加灵活

160
00:07:21,760 --> 00:07:25,240
它可以表示一个可大可小的一块区域

161
00:07:25,280 --> 00:07:28,280
到底是属于用户态还是内核态

162
00:07:28,320 --> 00:07:30,440
它的特权级是ring 0 ring 1

163
00:07:30,480 --> 00:07:32,040
ring 2 ring 3它有四级

164
00:07:32,080 --> 00:07:34,640
而对于页表而言 它就两级

165
00:07:34,680 --> 00:07:37,120
就是用户态和内核态 当然这也够了

166
00:07:37,160 --> 00:07:39,120
对我们前面讲到操作系统来说

167
00:07:39,160 --> 00:07:41,000
你只有两级是完全够的

168
00:07:41,040 --> 00:07:43,320
还有其它一些位我们讲内存管理的时候

169
00:07:43,360 --> 00:07:44,560
会再逐步展开

170
00:07:44,600 --> 00:07:46,480
它这些位可以有效的用来

171
00:07:46,520 --> 00:07:49,640
做内存的一些有效的管理

172
00:07:49,680 --> 00:07:52,520
  

173
00:07:52,560 --> 00:07:55,160
那我们假定你建立好什么 建立好页表

174
00:07:55,200 --> 00:07:57,160
页目录表 都建好了

175
00:07:57,200 --> 00:07:59,080
这是我们ucore操作系统来建立的

176
00:07:59,120 --> 00:08:01,760
建好之后我们要使能页机制

177
00:08:01,800 --> 00:08:03,920
这和我们前面说的段机制是一样的

178
00:08:03,960 --> 00:08:04,800
保护模式一样的

179
00:08:04,840 --> 00:08:06,480
你需要对一个特定的寄存器

180
00:08:06,520 --> 00:08:09,080
这里面是CR0的一个PG寄存器

181
00:08:09,120 --> 00:08:10,760
它最高位 31位

182
00:08:10,800 --> 00:08:15,480
前面是最低位 最低位来enable保护模式

183
00:08:15,520 --> 00:08:17,720
那么我们最高位31位

184
00:08:17,760 --> 00:08:20,000
CR0的寄存器 31位 如果给它置1的话

185
00:08:20,040 --> 00:08:22,960
就代表启动了页机制

186
00:08:23,000 --> 00:08:25,600
这就是这个特殊的寄存器

187
00:08:25,640 --> 00:08:27,560
它是一个需要在内核态访问的一个寄存器

188
00:08:27,600 --> 00:08:29,800
  

189
00:08:29,840 --> 00:08:34,120
好前面我给大家介绍一下CPU硬件的

190
00:08:34,160 --> 00:08:37,520
一个对内存的页表的机制建立的过程

191
00:08:37,560 --> 00:08:39,040
它的访问过程

192
00:08:39,080 --> 00:08:42,360
那我们操作系统怎么来使这个能正常运作

193
00:08:42,400 --> 00:08:45,520
我们ucore其实为此做了一系列的工作

194
00:08:45,560 --> 00:08:47,560
比如说我们前面说要分配页

195
00:08:47,600 --> 00:08:48,920
因为我们前面已经讲到了

196
00:08:48,960 --> 00:08:52,640
我们的内核以及ucore已经有一套

197
00:08:52,680 --> 00:08:54,480
基于连续内生存的一个

198
00:08:54,520 --> 00:08:57,080
内存分配的一套算法和机制

199
00:08:57,120 --> 00:08:58,640
从而可以说我们分配一个页

200
00:08:58,680 --> 00:09:02,840
分配一个4K来作为一个页目录的一个table

201
00:09:02,880 --> 00:09:07,880
然后再把这个里面的page给清掉

202
00:09:07,920 --> 00:09:09,440
清掉是为了做初始化

203
00:09:09,480 --> 00:09:14,280
然后你需要对除了这个页目录表之外

204
00:09:14,320 --> 00:09:16,000
还要建立对应的页表

205
00:09:16,040 --> 00:09:21,440
来对一定空间的内存来建立对应关系

206
00:09:21,480 --> 00:09:23,360
为此你需要在页目录表和页表里面

207
00:09:23,400 --> 00:09:25,600
填好相应的项 

208
00:09:25,640 --> 00:09:27,440
那我们这里面建立的映射关系是什么

209
00:09:27,480 --> 00:09:30,520
0xC0000000到0xF8000000

210
00:09:30,560 --> 00:09:34,520
这块空间会映射到物理地址的

211
00:09:34,560 --> 00:09:37,840
0x00000000到0x38000000这么一个地址

212
00:09:37,880 --> 00:09:39,200
那这个其实是可以看出来

213
00:09:39,240 --> 00:09:42,160
它们的偏移值就是0xC0000000的偏移值

214
00:09:42,200 --> 00:09:46,840
虚拟地址比物理地址要多出来0xC0000000

215
00:09:46,880 --> 00:09:48,480
那实际上映射的是内核空间

216
00:09:48,520 --> 00:09:50,440
使得我们内核态的代码和数据

217
00:09:50,480 --> 00:09:55,200
都是在0xC0000000这个之上的一个空间

218
00:09:55,240 --> 00:09:58,160
那这个和我们在lab2时候

219
00:09:58,200 --> 00:10:01,400
你可以看到它在编译 链接

220
00:10:01,440 --> 00:10:02,800
形成最后的uCore代码的时候

221
00:10:02,840 --> 00:10:07,160
它链接时候用的起始地址就是0xC0000000

222
00:10:07,200 --> 00:10:09,920
这是对应起来的

223
00:10:09,960 --> 00:10:12,560
同时我们又建立了一个很奇怪的一个映射

224
00:10:12,600 --> 00:10:17,320
就是0x00000000-0x00100000虚拟地址

225
00:10:17,360 --> 00:10:20,080
映射到0x00000000-0x00100000这物理地址

226
00:10:20,120 --> 00:10:23,520
这是一个对等映射

227
00:10:23,560 --> 00:10:25,480
按道理说我们建好这个映射就OK了

228
00:10:25,520 --> 00:10:26,880
为什么还要建立一个对等映射

229
00:10:26,920 --> 00:10:28,480
且在enable了

230
00:10:28,520 --> 00:10:31,680
把这个CR0的31位给它置1之后

231
00:10:31,720 --> 00:10:33,440
enable了的页机制之后

232
00:10:33,480 --> 00:10:37,880
我们再次更新了GDT

233
00:10:37,920 --> 00:10:39,440
为什么要update GDT

234
00:10:39,480 --> 00:10:41,800
是由于我们的页机制已经起作用了

235
00:10:41,840 --> 00:10:45,400
页机制来完成从0xC0000000到0的映射

236
00:10:45,440 --> 00:10:48,080
就是0xC0000000是虚拟地址 0是物理地址

237
00:10:48,120 --> 00:10:49,600
这个映射靠页机制完成了

238
00:10:49,640 --> 00:10:51,920
那我们段机制只需要完成对等映射就OK

239
00:10:51,960 --> 00:10:53,280
就0-0映射就行了

240
00:10:53,320 --> 00:10:56,200
那我们说update GDT之后

241
00:10:56,240 --> 00:10:59,040
其实就是让我们段机制映射的关系

242
00:10:59,080 --> 00:11:04,880
从之前的不是那种对等映射变成对等映射

243
00:11:04,920 --> 00:11:08,720
但变成对等映射之后它又做了一次取消操作

244
00:11:08,760 --> 00:11:10,120
就刚才这里面会有一步

245
00:11:10,160 --> 00:11:15,880
就是完成从0到0x100000的映射

246
00:11:15,920 --> 00:11:18,440
这里面又取消了0到0x100000的映射

247
00:11:18,480 --> 00:11:19,960
这个映射是页机制的映射

248
00:11:20,000 --> 00:11:23,600
把它取消了 有点多余好像感觉

249
00:11:23,640 --> 00:11:26,000
做了一步又取消了 为什么

250
00:11:26,040 --> 00:11:29,280
大家思考一下 作为一个练习

251
00:11:29,320 --> 00:11:31,440
大家想一想怎么来解决

252
00:11:31,480 --> 00:11:32,200
那所有的这些代码

253
00:11:32,240 --> 00:11:33,960
是放在pmm.c里面来实现的

254
00:11:34,000 --> 00:11:36,440
这是ucore里面的一个文件

255
00:11:36,480 --> 00:11:38,600
专门属于管理页表机制的

256
00:11:38,640 --> 00:11:42,640
  

257
00:11:42,680 --> 00:11:45,760
假设我们这个页表建立好了

258
00:11:45,800 --> 00:11:49,520
接下来我可能需要你再去完成

259
00:11:49,560 --> 00:11:53,000
再完成一个特定的内存的映射

260
00:11:53,040 --> 00:11:54,880
这时候你就可能需要去对

261
00:11:54,920 --> 00:11:57,840
这个PTE PDE来做一个处理

262
00:11:57,880 --> 00:11:59,200
甚至还会涉及说

263
00:11:59,240 --> 00:12:01,200
如果我们这个内存它属于

264
00:12:01,240 --> 00:12:03,760
另一块空间我们现在页表

265
00:12:03,800 --> 00:12:06,120
我们现在页表它没有对应到

266
00:12:06,160 --> 00:12:09,040
所以说我们需要干什么建立一个新的页表

267
00:12:09,080 --> 00:12:11,120
这就是我们的一个作业 我们练习

268
00:12:11,160 --> 00:12:14,480
你尝试着给你一个虚拟地址和物理地址

269
00:12:14,520 --> 00:12:17,440
你尝试着能不能分配一个对应的页表项

270
00:12:17,480 --> 00:12:19,920
使得虚拟地址能够正确的

271
00:12:19,960 --> 00:12:21,560
映射到对应的物理地址

272
00:12:21,600 --> 00:12:24,360
这就是我们说在页表里面来建立

273
00:12:24,400 --> 00:12:26,720
页的这个映射关系的这么一个练习

274
00:12:26,760 --> 00:12:30,080
作为我们这个lab2的一个主要的完成部分

275
00:12:30,120 --> 00:12:31,560
需要大家去完成

276
00:12:31,600 --> 00:12:33,360
  

277
00:12:33,400 --> 00:12:36,080
好我们最后再看一下对于X86而言

278
00:12:36,120 --> 00:12:38,120
它确实比较全面

279
00:12:38,160 --> 00:12:40,760
既包含了段机制 也包含了页机制

280
00:12:40,800 --> 00:12:43,280
虽然我们这里面弱化了段机制这个映射关系

281
00:12:43,320 --> 00:12:46,440
但其实通过这个段和页一个组合

282
00:12:46,480 --> 00:12:48,880
我们可以形成一个更灵活的组织方式

283
00:12:48,920 --> 00:12:51,880
当然在现在操作系统里面主要

284
00:12:51,920 --> 00:12:54,360
还是用页机制来完成了整个的映射

285
00:12:54,400 --> 00:12:58,400
段机制它的作用更多的体现在安全管理上面

286
00:12:58,440 --> 00:13:00,600
那其实即使在安全管理上面

287
00:13:00,640 --> 00:13:02,440
段和页也有一定的重复 

288
00:13:02,480 --> 00:13:03,920
在X86里面有一定的重复

289
00:13:03,960 --> 00:13:06,000
所以说可以看到我们会根据

290
00:13:06,040 --> 00:13:07,760
具体的运用情况来了解

291
00:13:07,800 --> 00:13:08,120
  

292
00:13:08,160 --> 00:13:11,120
好 这是列出来在intel

293
00:13:11,160 --> 00:13:13,960
那个系统软件软件开发手册里面

294
00:13:14,000 --> 00:13:14,760
对应的章节

295
00:13:14,800 --> 00:13:16,840
它对页表机制有更深入的讲解

296
00:13:16,880 --> 00:13:18,280
站在硬件的角度

297
00:13:18,320 --> 00:13:19,840
怎么去便于软件开发人员

298
00:13:19,880 --> 00:13:21,880
去理解这个页机制

299
00:13:21,920 --> 00:13:23,000
可以看一看

300
00:13:23,040 --> 00:13:23,120
  

301
00:13:23,160 --> 00:13:24,120
  

302
00:13:24,160 --> 00:13:26,880
  好那这就是这一讲的内容 谢谢大家

303
00:13:26,920 --> 00:13:40,360


304
00:13:40,400 --> 00:13:40,680


305
00:13:40,720 --> 00:13:40,960


306
00:13:41,000 --> 00:13:41,320


307
00:13:41,360 --> 00:13:41,400


