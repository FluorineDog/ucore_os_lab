0
00:00:00,000 --> 00:00:06,720


1
00:00:06,920 --> 00:00:08,400
接下来我们看一下lab2的

2
00:00:08,440 --> 00:00:10,080
这个实验指导书

3
00:00:10,120 --> 00:00:12,320
来对lab2要完成的工作

4
00:00:12,360 --> 00:00:14,120
做一个初步的了解

5
00:00:14,160 --> 00:00:16,640
那lab2主要是完成物理内存管理

6
00:00:16,680 --> 00:00:18,480
当然是建立在lab1基础之上的

7
00:00:18,520 --> 00:00:20,960
意味着如果你lab1没有完成

8
00:00:21,000 --> 00:00:22,760
那你没法开展lab2的工作

9
00:00:22,800 --> 00:00:26,120
这是它们是一个就是有相互依赖关系的

10
00:00:26,160 --> 00:00:29,080
之后的实验也都具有同样的特点

11
00:00:29,120 --> 00:00:31,280
那这个实验的目的是什么呢

12
00:00:31,320 --> 00:00:34,600
这个实验目的是结合我们原理课的讲解

13
00:00:34,640 --> 00:00:38,160
更深入的理解段页式内存的

14
00:00:38,200 --> 00:00:39,680
地址的转换方式

15
00:00:39,720 --> 00:00:41,800
以及如何建立页表

16
00:00:41,840 --> 00:00:43,520
建立页表之前其实还有一个

17
00:00:43,560 --> 00:00:46,560
连续地址空间的这个物理内存管理

18
00:00:46,600 --> 00:00:47,360
这一块呢

19
00:00:47,400 --> 00:00:50,440
也是需要在lab2中有更深入体会

20
00:00:50,480 --> 00:00:53,520
大家可以看一下就是在lab2中

21
00:00:53,560 --> 00:00:56,200
如何通过我们一系列的

22
00:00:56,240 --> 00:00:59,640
操作来完成这些工作的

23
00:00:59,680 --> 00:01:02,960
其实大家很关注就是要完成几个练习

24
00:01:03,000 --> 00:01:06,360
lab2提供三个基本练习和两个扩展练习

25
00:01:06,400 --> 00:01:09,040
我们一个一个来逐一给大家做个讲解

26
00:01:09,080 --> 00:01:10,520
首先这个练习0呢实际上

27
00:01:10,560 --> 00:01:12,280
就是重复lab1的工作

28
00:01:12,320 --> 00:01:14,240
把lab1做的那些你修改的

29
00:01:14,280 --> 00:01:16,720
那些代码填到lab2中来

30
00:01:16,760 --> 00:01:17,880
你可以通过一些工具

31
00:01:17,920 --> 00:01:20,400
比如说diff和patch来自动的merge

32
00:01:20,440 --> 00:01:22,800
如果merge合并的时候呢 出了点问题的话

33
00:01:22,840 --> 00:01:24,840
就可能要手动来做更新

34
00:01:24,880 --> 00:01:27,080
也可以用图形化的工具来手动合并

35
00:01:27,120 --> 00:01:30,160
比如说我们这里面提供的meld等等

36
00:01:30,200 --> 00:01:32,040
这是第一步

37
00:01:32,080 --> 00:01:34,040
因为你要把lab1的工作

38
00:01:34,080 --> 00:01:35,320
能够让它正常工作了

39
00:01:35,360 --> 00:01:39,840
才能进一步完成lab2的后续的一些工作

40
00:01:39,880 --> 00:01:42,640
这个实际上是一个基本的

41
00:01:42,680 --> 00:01:45,480
第二步就是说怎么去来完成

42
00:01:45,520 --> 00:01:46,920
对这个物理内存空间的

43
00:01:46,960 --> 00:01:49,560
分配的一个算法实现

44
00:01:49,600 --> 00:01:53,400
那在原理课中我们讲了好几种不同的

45
00:01:53,440 --> 00:01:55,040
连续物理内存空间的分配算法

46
00:01:55,080 --> 00:01:58,880
包括first-fit best-fit worst-fit等

47
00:01:58,920 --> 00:02:00,200
这里面我们考虑

48
00:02:00,240 --> 00:02:02,200
在操作系统里面怎么来实现

49
00:02:02,240 --> 00:02:03,960
那看起来在原理课里面讲的

50
00:02:04,000 --> 00:02:05,600
first-fit是相当简单的

51
00:02:05,640 --> 00:02:08,000
那如果要具体实现在我们的

52
00:02:08,040 --> 00:02:09,200
ucore操作系统里面

53
00:02:09,240 --> 00:02:12,920
我们设计实现一个新的一种框架

54
00:02:12,960 --> 00:02:15,880
在基于物理内存管理框架之下呢

55
00:02:15,920 --> 00:02:18,960
我们可以实现不同的这个内存分配算法

56
00:02:19,000 --> 00:02:21,640
那么first-fit是我们要求大家去完成的

57
00:02:21,680 --> 00:02:24,400
首先你们就要去了解

58
00:02:24,440 --> 00:02:26,960
我们说的物理内存pmm manager

59
00:02:27,000 --> 00:02:28,200
这么一个程序里面

60
00:02:28,240 --> 00:02:30,360
它到底是怎么来组织的

61
00:02:30,400 --> 00:02:33,040
这也是需要根据源码来看一下

62
00:02:33,080 --> 00:02:35,160
那在这个lab2源代码里面

63
00:02:35,200 --> 00:02:36,040
我们可以看到两个文件

64
00:02:36,080 --> 00:02:39,120
default_ pmm.h和default_ pmm.c

65
00:02:39,160 --> 00:02:42,160
那这里面很重要的pmm_ manager

66
00:02:42,200 --> 00:02:43,560
在这个框架里面

67
00:02:43,600 --> 00:02:45,120
我们设定好了一个

68
00:02:45,160 --> 00:02:46,840
连续物理内存分配算法的

69
00:02:46,880 --> 00:02:49,240
一个最主要的一些函数的实现

70
00:02:49,280 --> 00:02:50,520
这里面列出来了

71
00:02:50,560 --> 00:02:53,440
我们重点实现的是分配 释放

72
00:02:53,480 --> 00:02:55,640
当然你要能够完成正确的分配 释放

73
00:02:55,680 --> 00:02:57,400
你还需要有一定初始化的工作

74
00:02:57,440 --> 00:02:58,240
为什么初始化

75
00:02:58,280 --> 00:03:01,760
首先要把我们说在ucore启动之后

76
00:03:01,800 --> 00:03:06,160
要把我们计算机物理内存有效感知

77
00:03:06,200 --> 00:03:07,760
然后知道哪些是空闲的

78
00:03:07,800 --> 00:03:10,920
哪些可以去为后续做malloc  free

79
00:03:10,960 --> 00:03:12,440
动态内存分配

80
00:03:12,480 --> 00:03:17,400
这个需要在前面init_ memmap

81
00:03:17,440 --> 00:03:18,960
这一块来完成

82
00:03:19,000 --> 00:03:21,840
最后这个是完成一个检查

83
00:03:21,880 --> 00:03:23,680
这个检查是说

84
00:03:23,720 --> 00:03:27,040
我们知道想判断一下你的实现是否对

85
00:03:27,080 --> 00:03:30,000
我们会有check 这么一个函数

86
00:03:30,040 --> 00:03:31,160
这个是得到当前

87
00:03:31,200 --> 00:03:32,800
剩余多少页的这么一个函数

88
00:03:32,840 --> 00:03:35,760
就是返回当前的free pages

89
00:03:35,800 --> 00:03:38,080
这个形成了我们pmm_ manager

90
00:03:38,120 --> 00:03:39,000
看起来比较简单

91
00:03:39,040 --> 00:03:41,000
这是基于函数指针的方式来实现的

92
00:03:41,040 --> 00:03:43,800
那我们需要把我们的first-fit

93
00:03:43,840 --> 00:03:46,320
这个代码填到这里面

94
00:03:46,360 --> 00:03:48,200
这里面有详细的信息

95
00:03:48,240 --> 00:03:50,360
这里面到底要怎么做

96
00:03:50,400 --> 00:03:53,880
你的代码应该怎么去完成相应的工作

97
00:03:53,920 --> 00:03:56,040
它的步骤是什么 这里面都列出来了

98
00:03:56,080 --> 00:03:58,320
我建议大家在实现之前呢

99
00:03:58,360 --> 00:04:01,160
把这一块代码仔细阅读一下

100
00:04:01,200 --> 00:04:02,000
仔细阅读一下

101
00:04:02,040 --> 00:04:04,360
来理解你应该怎么来填写

102
00:04:04,400 --> 00:04:05,920
那到底你填在什么地方

103
00:04:05,960 --> 00:04:08,000
这个也是需要注意的  

104
00:04:08,040 --> 00:04:09,760
在我们这个源代码里面呢

105
00:04:09,800 --> 00:04:10,160
我们可以通过

106
00:04:10,200 --> 00:04:12,800
如下这个命令来查找

107
00:04:12,840 --> 00:04:13,640
你需要填写的地方

108
00:04:13,680 --> 00:04:14,640
我们已经标注出来

109
00:04:14,680 --> 00:04:16,760
大写的LAB2这个位置呢

110
00:04:16,800 --> 00:04:18,040
实际上就是你要填写的地方

111
00:04:18,080 --> 00:04:21,800
我们每个练习里面都包含这个信息

112
00:04:21,840 --> 00:04:24,080
就是可以看到在练习一里面呢

113
00:04:24,120 --> 00:04:25,880
它在这个地方需要你去填写

114
00:04:25,920 --> 00:04:28,120
如果是在后续的练习 练习二和练习三

115
00:04:28,160 --> 00:04:29,600
那么在这个地方要填写

116
00:04:29,640 --> 00:04:30,840
这里面也知道

117
00:04:30,880 --> 00:04:32,560
比如你要完成first-fit这个算法呢

118
00:04:32,600 --> 00:04:34,640
这需要对default_ pmm.c

119
00:04:34,680 --> 00:04:36,680
这个文件呢做相应的填充

120
00:04:36,720 --> 00:04:38,560
来实现你的那些

121
00:04:38,600 --> 00:04:40,800
刚才说那些函数指针里面对应的函数

122
00:04:40,840 --> 00:04:42,520
从而可以完成正确的

123
00:04:42,560 --> 00:04:43,600
分配内存和释放内存

124
00:04:43,640 --> 00:04:46,080
以及初始化内存的工作

125
00:04:46,120 --> 00:04:47,120
  

126
00:04:47,160 --> 00:04:48,280
那这里面可以看到

127
00:04:48,320 --> 00:04:51,200
其实这些函数 列出来了一些

128
00:04:51,240 --> 00:04:55,080
但这些并不是一个正确的first-fit实现

129
00:04:55,120 --> 00:04:56,200
它也许可以工作

130
00:04:56,240 --> 00:04:57,440
但其实它没有达到

131
00:04:57,480 --> 00:05:00,400
first-fit它所要求的功能

132
00:05:00,440 --> 00:05:03,160
所以说我们需要去对此进行修改

133
00:05:03,200 --> 00:05:06,960
来完成这个对这个以页为单位的

134
00:05:07,000 --> 00:05:08,840
内存的动态分配

135
00:05:08,880 --> 00:05:10,560
这个内存是连续物理内存  

136
00:05:10,600 --> 00:05:13,760
  

137
00:05:13,800 --> 00:05:16,080
这是第一部分的内容

138
00:05:16,120 --> 00:05:17,440
那我们还希望你通过

139
00:05:17,480 --> 00:05:18,840
完成这个实验之后

140
00:05:18,880 --> 00:05:21,040
能够在你的实验报告中说明

141
00:05:21,080 --> 00:05:22,000
你设计过程中

142
00:05:22,040 --> 00:05:24,280
到底有没有进一步改进空间

143
00:05:24,320 --> 00:05:25,960
其实first-fit这个实现呢

144
00:05:26,000 --> 00:05:27,800
有多种实验方式

145
00:05:27,840 --> 00:05:30,280
你可以有一些技巧

146
00:05:30,320 --> 00:05:32,840
来使得它更加高效

147
00:05:32,880 --> 00:05:34,960
甚至说你还可以去跟worst-fit

148
00:05:35,000 --> 00:05:37,240
或者是best-fit进行比较

149
00:05:37,280 --> 00:05:38,720
当然前提是你需要去实现

150
00:05:38,760 --> 00:05:40,960
看看在你的操作系统里面

151
00:05:41,000 --> 00:05:42,360
这些算法到底哪个好

152
00:05:42,400 --> 00:05:45,760
哪个差一些 这是练习一的工作

153
00:05:45,800 --> 00:05:46,800
  

154
00:05:46,840 --> 00:05:50,440
练习二的工作主要是完成页表的

155
00:05:50,480 --> 00:05:52,200
一个更深入的理解

156
00:05:52,240 --> 00:05:55,240
通过设置页表和对应的列表项来建立

157
00:05:55,280 --> 00:05:57,360
对于某一个虚拟地址和物理地址

158
00:05:57,400 --> 00:05:58,240
一个对应关系

159
00:05:58,280 --> 00:06:01,440
所以说练习二呢 它需要去修改

160
00:06:01,480 --> 00:06:03,720
修改跟页表相关的一些位置信息

161
00:06:03,760 --> 00:06:07,520
那我们前面已经看到你修改练习二

162
00:06:07,560 --> 00:06:11,040
主要集中在pmm.c 350行这个地方

163
00:06:11,080 --> 00:06:13,360
  

164
00:06:13,400 --> 00:06:15,200
我们查一下pmm.c 

165
00:06:15,240 --> 00:06:19,720
  

166
00:06:19,760 --> 00:06:22,480
大约的位置在这儿

167
00:06:22,520 --> 00:06:28,800
这里面是要完成一个获取页表项(page table entry)

168
00:06:28,840 --> 00:06:30,040
这么一个函数的实现

169
00:06:30,080 --> 00:06:31,160
这里面讲到两点

170
00:06:31,200 --> 00:06:33,280
或者这个页表项已经建立好了

171
00:06:33,320 --> 00:06:36,440
那么你只需查找对应的这个逻辑地址

172
00:06:36,480 --> 00:06:37,960
我们称之为虚拟地址和逻辑地址

173
00:06:38,000 --> 00:06:41,200
它所对应页表项是哪一项

174
00:06:41,240 --> 00:06:42,640
把它取回来就OK了

175
00:06:42,680 --> 00:06:44,120
如果说这里面没有这一项

176
00:06:44,160 --> 00:06:46,720
对应的逻辑地址或者是线性地址

177
00:06:46,760 --> 00:06:49,760
它没有页表项对应

178
00:06:49,800 --> 00:06:51,600
那你就需要创建一个页表项

179
00:06:51,640 --> 00:06:54,040
你怎么去实现对页表项的创建

180
00:06:54,080 --> 00:06:56,760
这需要去修改相关的一些函数

181
00:06:56,800 --> 00:06:58,720
来完成对应的功能

182
00:06:58,760 --> 00:07:00,760
那我们这里其实也列的比较详细

183
00:07:00,800 --> 00:07:02,400
你到底要完成哪些步骤

184
00:07:02,440 --> 00:07:03,280
这个是肯定是错的

185
00:07:03,320 --> 00:07:05,040
但是它的注释也一样

186
00:07:05,080 --> 00:07:07,720
你需要仔细的阅读这一块的注释

187
00:07:07,760 --> 00:07:10,840
以及这里面一些要求

188
00:07:10,880 --> 00:07:12,240
这实际上给很多帮助

189
00:07:12,280 --> 00:07:13,680
你要为了完成这个功能

190
00:07:13,720 --> 00:07:15,160
你可以用我们这里面

191
00:07:15,200 --> 00:07:16,800
ucore里面已有一些函数

192
00:07:16,840 --> 00:07:17,920
到底用哪些函数

193
00:07:17,960 --> 00:07:20,640
哪些宏 可以帮助你来完成这些功能

194
00:07:20,680 --> 00:07:25,720
这是练习二要求的

195
00:07:25,760 --> 00:07:27,600
我们还可以通过understand来

196
00:07:27,640 --> 00:07:29,240
其实还可以更深入看一看

197
00:07:29,280 --> 00:07:31,560
整体的架构它怎么实现的

198
00:07:31,600 --> 00:07:32,680
这一点需要大家掌握

199
00:07:32,720 --> 00:07:34,960
就是这个get_ pte这个函数

200
00:07:35,000 --> 00:07:37,000
到底是怎么调这个函数来的

201
00:07:37,040 --> 00:07:38,120
怎么一步步过来的

202
00:07:38,160 --> 00:07:41,440
那从最开始的kern_init一直到pmm_init

203
00:07:41,480 --> 00:07:44,440
再最后获得PTE

204
00:07:44,480 --> 00:07:45,840
那我们其实在understand里面

205
00:07:45,880 --> 00:07:47,840
也很好可以看到这个过程

206
00:07:47,880 --> 00:07:49,000
在kern_init其实是

207
00:07:49,040 --> 00:07:51,880
整个内核初始化的总控函数

208
00:07:51,920 --> 00:07:55,400
我们前面还没有涉及到

209
00:07:55,440 --> 00:07:57,400
物理内存这些管理之后

210
00:07:57,440 --> 00:08:01,640
其实比如说之前中断控制器的初始化

211
00:08:01,680 --> 00:08:03,080
中断向量表初始化等等

212
00:08:03,120 --> 00:08:04,040
都在这儿来完成了

213
00:08:04,080 --> 00:08:06,920
这次呢新增加了pmm初始化

214
00:08:06,960 --> 00:08:09,240
那我们可以看看这个函数在这儿

215
00:08:09,280 --> 00:08:15,520
它的一个函数量关系比较复杂

216
00:08:15,560 --> 00:08:17,040
  

217
00:08:17,080 --> 00:08:20,560
那可以看出来这是kern_init比较小

218
00:08:20,600 --> 00:08:22,440
调到了pmm_init

219
00:08:22,480 --> 00:08:27,160
然后呢最后它还会去一层一层的去

220
00:08:27,200 --> 00:08:29,760
我们看看在哪 

221
00:08:29,800 --> 00:08:32,160
  

222
00:08:32,200 --> 00:08:33,360
比如说在这儿

223
00:08:33,400 --> 00:08:35,400
check_ pgdir这么一个函数

224
00:08:35,440 --> 00:08:36,080
这个函数会进一步

225
00:08:36,120 --> 00:08:39,760
调get_ page获取某一个页

226
00:08:39,800 --> 00:08:40,320
  

227
00:08:40,360 --> 00:08:41,960
这里面呢会调get_ pte

228
00:08:42,000 --> 00:08:43,200
这里面就可以看出来

229
00:08:43,240 --> 00:08:44,240
它有不同的调用关系

230
00:08:44,280 --> 00:08:47,120
get_ pte有好几个函数对它进行有调用

231
00:08:47,160 --> 00:08:48,360
我们双击一下这个呢

232
00:08:48,400 --> 00:08:50,680
可以在这儿重新看一下以get_ pte为准

233
00:08:50,720 --> 00:08:52,920
来看一下它被谁调用了

234
00:08:52,960 --> 00:08:54,960
那可以看出来 这里列出来了

235
00:08:55,000 --> 00:08:56,880
被这些函数所调用

236
00:08:56,920 --> 00:09:00,120
通过理解这些函数的实现能够知道

237
00:09:00,160 --> 00:09:01,440
这些函数在什么情况下

238
00:09:01,480 --> 00:09:02,840
为什么调用get_ pte

239
00:09:02,880 --> 00:09:04,840
从而可以更好地有助于完成get_ pte

240
00:09:04,880 --> 00:09:07,520
这个函数里面的需要完成的功能

241
00:09:07,560 --> 00:09:09,120
  

242
00:09:09,160 --> 00:09:11,000
另一方面我们还希望大家在实验报告中

243
00:09:11,040 --> 00:09:12,880
能够说明如下一些问题

244
00:09:12,920 --> 00:09:17,800
比如说如果你访问一个虚拟地址

245
00:09:17,840 --> 00:09:19,240
或者一个线性地址

246
00:09:19,280 --> 00:09:21,080
然后呢按道理来说应该有一个对应的

247
00:09:21,120 --> 00:09:22,320
物理地址和它对应

248
00:09:22,360 --> 00:09:24,240
如果说这个物理地址没有对应

249
00:09:24,280 --> 00:09:26,120
也意味着你的页表项或者没有

250
00:09:26,160 --> 00:09:28,760
或者是建错了 会出现页访问异常

251
00:09:28,800 --> 00:09:32,000
这时候出现什么情况 OK 

252
00:09:32,040 --> 00:09:33,440
第二个呢

253
00:09:33,480 --> 00:09:35,920
如果说出现了页访问异常那么

254
00:09:35,960 --> 00:09:37,760
我们ucore呢它应该有一个

255
00:09:37,800 --> 00:09:39,400
对应的缺页的服务例程

256
00:09:39,440 --> 00:09:41,600
中断服务例程来完成对这个

257
00:09:41,640 --> 00:09:44,120
页访问异常的进一步处理

258
00:09:44,160 --> 00:09:47,440
但是如果说这个缺页服务例程

259
00:09:47,480 --> 00:09:48,800
缺页中断服务例程

260
00:09:48,840 --> 00:09:52,080
进一步又出现了页访问异常

261
00:09:52,120 --> 00:09:55,240
那会出现什么现象 请大家思考一下

262
00:09:55,280 --> 00:09:57,840
这是练习二这一块的工作

263
00:09:57,880 --> 00:10:01,440
那练习三呢 其实是练习二的一个

264
00:10:01,480 --> 00:10:04,560
反操作或者逆操作 前面是建立

265
00:10:04,600 --> 00:10:05,800
建立对应的页表项

266
00:10:05,840 --> 00:10:07,760
从而把这个映射关系建立好

267
00:10:07,800 --> 00:10:11,400
这里面是说如果要释放一个映射关系

268
00:10:11,440 --> 00:10:12,800
把这个页给释放掉

269
00:10:12,840 --> 00:10:15,040
那么就意味着不存在了

270
00:10:15,080 --> 00:10:16,480
我们应该让它这个页表

271
00:10:16,520 --> 00:10:19,160
这个映射关系也取消 怎么做

272
00:10:19,200 --> 00:10:21,440
这里面你如果说

273
00:10:21,480 --> 00:10:23,560
对这个get_ pte有一定了解之后

274
00:10:23,600 --> 00:10:27,400
相信你来完成所谓page_ remove_ pte

275
00:10:27,440 --> 00:10:30,680
也一样可以比较好的完成相应的工作

276
00:10:30,720 --> 00:10:31,960
同样 用同样的方法

277
00:10:32,000 --> 00:10:43,280
可以用前面说到的415行是练习三

278
00:10:43,320 --> 00:10:48,680
在这里面完成这个page_ remove_ pte的

279
00:10:48,720 --> 00:10:49,720
一个大致实现

280
00:10:49,760 --> 00:10:52,400
这里面讲函数到底要干什么

281
00:10:52,440 --> 00:10:55,840
然后还讲到它大致一个实现步骤

282
00:10:55,880 --> 00:10:57,400
这里是重点需要你去填写的

283
00:10:57,440 --> 00:11:00,360
当然提醒一下你实现完之后

284
00:11:00,400 --> 00:11:01,760
把这个注释给去掉

285
00:11:01,800 --> 00:11:03,760
否则这个代码是无法

286
00:11:03,800 --> 00:11:06,560
被编译到执行码里面去的

287
00:11:06,600 --> 00:11:10,640
好 那我们完成了这个函数实现之后呢

288
00:11:10,680 --> 00:11:12,520
我们希望你能够在实验报告中

289
00:11:12,560 --> 00:11:13,720
回答如下一些问题

290
00:11:13,760 --> 00:11:15,760
第一个是关于数据结构

291
00:11:15,800 --> 00:11:18,040
page的全局变量它是什么

292
00:11:18,080 --> 00:11:19,280
它其实是一个数组

293
00:11:19,320 --> 00:11:21,200
这个数组每一项与页表中的

294
00:11:21,240 --> 00:11:22,200
页目录项或者是

295
00:11:22,240 --> 00:11:24,320
页表项有没有对应关系

296
00:11:24,360 --> 00:11:27,600
如果有这个关系那关系是啥 这是一个

297
00:11:27,640 --> 00:11:30,720
第二我们前面已经讲到在lab2中

298
00:11:30,760 --> 00:11:33,040
我们完成的虚拟地址到物理地址映射

299
00:11:33,080 --> 00:11:35,360
是有一个偏移

300
00:11:35,400 --> 00:11:38,120
就是虚地址是0xC0000000

301
00:11:38,160 --> 00:11:39,960
会映射到物理地址0

302
00:11:40,000 --> 00:11:42,200
这是一个非对等映射

303
00:11:42,240 --> 00:11:44,160
如果我们要完成对等映射也意味着

304
00:11:44,200 --> 00:11:46,640
虚拟地址的0也就是物理地址0

305
00:11:46,680 --> 00:11:49,440
如果要完成这件事情怎么做

306
00:11:49,480 --> 00:11:52,160
我们希望大家能够去尝试一下

307
00:11:52,200 --> 00:11:54,680
也同时能够在实验报告中做一个说明

308
00:11:54,720 --> 00:11:57,440
当然你如果不完成这个编程

309
00:11:57,480 --> 00:11:58,520
也是没有问题的

310
00:11:58,560 --> 00:11:59,560
我们完成的要求的编程是

311
00:11:59,600 --> 00:12:01,280
练习一二三里面明确指出的

312
00:12:01,320 --> 00:12:06,200
要修改或者扩展的几个函数

313
00:12:06,240 --> 00:12:09,080
好 接下来我们再看一下扩展练习两个

314
00:12:09,120 --> 00:12:09,800
第一个是buddy system

315
00:12:09,840 --> 00:12:11,920
第二个是slub分配算法

316
00:12:11,960 --> 00:12:13,120
那这两个分配算法呢

317
00:12:13,160 --> 00:12:14,680
在我们今年呢

318
00:12:14,720 --> 00:12:17,280
通用操作系统里面是存在的

319
00:12:17,320 --> 00:12:19,520
这两个都在Linux里面有对应的实现

320
00:12:19,560 --> 00:12:22,760
那我们可以考虑能不能在我们ucore中

321
00:12:22,800 --> 00:12:26,000
实现buddy system和slub分配算法

322
00:12:26,040 --> 00:12:28,160
一个可以给大家提示一点是说

323
00:12:28,200 --> 00:12:31,440
其实在我们早期的这个同学实验中呢

324
00:12:31,480 --> 00:12:32,920
已经完成了对这个

325
00:12:32,960 --> 00:12:36,480
buddy system和slub分配算法的一个实现

326
00:12:36,520 --> 00:12:38,160
所以说希望大家

327
00:12:38,200 --> 00:12:39,760
在有兴趣有时间的情况下

328
00:12:39,800 --> 00:12:43,360
可以尝试一下这挑战中的一个或两个

329
00:12:43,400 --> 00:12:45,680
  

330
00:12:45,720 --> 00:12:46,720
好 那我就把练习

331
00:12:46,760 --> 00:12:48,600
给大家做一个简单介绍

332
00:12:48,640 --> 00:12:50,440
那为了能够更好的完成

333
00:12:50,480 --> 00:12:52,080
更好的完成这个练习呢

334
00:12:52,120 --> 00:12:54,640
我希望大家能够把后续这个

335
00:12:54,680 --> 00:12:57,600
lab2实验执行流程能够去读一下

336
00:12:57,640 --> 00:12:59,600
从而可以在整体上知道

337
00:12:59,640 --> 00:13:01,080
lab2是怎么完成的

338
00:13:01,120 --> 00:13:02,760
读完这个文档之后

339
00:13:02,800 --> 00:13:04,560
就是lab2的实验指导书之后呢

340
00:13:04,600 --> 00:13:05,840
还需要大家能够

341
00:13:05,880 --> 00:13:08,440
去结合代码去静态的分析

342
00:13:08,480 --> 00:13:12,080
或者说是动态的调试来看我们这个

343
00:13:12,120 --> 00:13:14,120
lab2大致的一个执行过程

344
00:13:14,160 --> 00:13:16,280
和对文档描述是否一致

345
00:13:16,320 --> 00:13:19,160
从而可以对如何感知物理内存

346
00:13:19,200 --> 00:13:22,040
这个在原理课中是没有涉及到的

347
00:13:22,080 --> 00:13:24,320
如何以页为单位来管理内存

348
00:13:24,360 --> 00:13:26,280
实现段页式机制

349
00:13:26,320 --> 00:13:28,720
那么这部分在原理课中

350
00:13:28,760 --> 00:13:31,720
也很少涉及到这么详细的细节

351
00:13:31,760 --> 00:13:35,280
这是需要大家通过理解原理

352
00:13:35,320 --> 00:13:37,200
分析代码 调试代码

353
00:13:37,240 --> 00:13:38,800
完成我们的练习

354
00:13:38,840 --> 00:13:40,640
从而可以有一个更好的一个

355
00:13:40,680 --> 00:13:42,520
更深入的一个理解

356
00:13:42,560 --> 00:13:43,920
那这是最后的实验报告

357
00:13:43,960 --> 00:13:45,520
要求指出了我们要

358
00:13:45,560 --> 00:13:47,120
把我们代码提交到git server上去

359
00:13:47,160 --> 00:13:48,880
然后我们这个实验报告呢

360
00:13:48,920 --> 00:13:49,800
是markdown格式

361
00:13:49,840 --> 00:13:51,000
也需要大家提交到我们

362
00:13:51,040 --> 00:13:52,720
对应的git server的帐号

363
00:13:52,760 --> 00:13:56,560
所对应的git repo里面去

364
00:13:56,600 --> 00:13:57,240
  

365
00:13:57,280 --> 00:14:01,560
注意有lab2的注释你去写的时候

366
00:14:01,600 --> 00:14:03,120
还要将your code

367
00:14:03,160 --> 00:14:04,600
替换为你的学号

368
00:14:04,640 --> 00:14:06,720
这一点希望大家能够稍微

369
00:14:06,760 --> 00:14:09,360
在提交代码之前注意一下

370
00:14:09,400 --> 00:14:11,440
这里面附录A B C D

371
00:14:11,480 --> 00:14:14,200
是有一些相关的一些讲解

372
00:14:14,240 --> 00:14:17,720
A B C是和物理内存相关

373
00:14:17,760 --> 00:14:20,960
以及虚拟地址 物理地址的

374
00:14:21,000 --> 00:14:22,640
一个对应关系做了一个介绍

375
00:14:22,680 --> 00:14:24,720
自映射呢是一个更高级的机制

376
00:14:24,760 --> 00:14:27,440
它描述了如何通过

377
00:14:27,480 --> 00:14:29,480
虚拟地址的一个访问

378
00:14:29,520 --> 00:14:32,600
快速把这个页表给打印出来

379
00:14:32,640 --> 00:14:33,920
它还有其它一些功能

380
00:14:33,960 --> 00:14:35,160
在这里面如果有感兴趣的同学

381
00:14:35,200 --> 00:14:36,800
可以深入去分析一下

382
00:14:36,840 --> 00:14:40,080
这个附录D所描述的内容  

383
00:14:40,120 --> 00:14:43,160
  

384
00:14:43,200 --> 00:14:45,400
好 我们其实可以看看

385
00:14:45,440 --> 00:14:46,960
  

386
00:14:47,000 --> 00:14:50,400
如果说lab2你如果完成了

387
00:14:50,440 --> 00:14:52,120
正确完成了相应的工作

388
00:14:52,160 --> 00:14:54,360
我们可以执行一下

389
00:14:54,400 --> 00:14:56,760
  

390
00:14:56,800 --> 00:14:59,400
可以看到在这里面呢

391
00:14:59,440 --> 00:15:02,880
lab2已经正确完成了这个内存的分配

392
00:15:02,920 --> 00:15:04,760
建立好了相应的页表

393
00:15:04,800 --> 00:15:06,360
然后在enable了

394
00:15:06,400 --> 00:15:08,120
这个段机制和页机制之后

395
00:15:08,160 --> 00:15:09,440
所有的系统还依然能够

396
00:15:09,480 --> 00:15:11,160
正确完成相应的工作

397
00:15:11,200 --> 00:15:13,280
包括lab1里面的中断实现

398
00:15:13,320 --> 00:15:15,240
你看还在正确地一步步地

399
00:15:15,280 --> 00:15:16,680
产生相应的执行

400
00:15:16,720 --> 00:15:19,080
希望大家能够

401
00:15:19,120 --> 00:15:21,480
更好地更顺利地完成这个实验

402
00:15:21,520 --> 00:15:22,280
在这里面你也许

403
00:15:22,320 --> 00:15:24,240
会碰到一些意想不到一些困难

404
00:15:24,280 --> 00:15:26,960
希望大家能够及时到我们说的

405
00:15:27,000 --> 00:15:29,600
piazza那个问答平台去提问

406
00:15:29,640 --> 00:15:32,560
我们的助教随时解答

407
00:15:32,600 --> 00:15:34,040
大家碰到的一些问题

408
00:15:34,080 --> 00:15:35,080
好 谢谢大家

409
00:15:35,120 --> 00:15:37,200


410
00:15:37,240 --> 00:15:38,480


411
00:15:38,520 --> 00:15:41,160


412
00:15:41,200 --> 00:15:41,240


