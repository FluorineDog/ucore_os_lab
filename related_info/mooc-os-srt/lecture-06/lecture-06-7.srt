0
00:00:00,000 --> 00:00:07,000


1
00:00:07,200 --> 00:00:08,800
下面我们来讨论

2
00:00:08,920 --> 00:00:11,720
段页式存储管理

3
00:00:11,760 --> 00:00:13,160
那段页式存储管理呢

4
00:00:13,200 --> 00:00:15,480
实际上是我们前面段式和页式

5
00:00:15,520 --> 00:00:17,120
想把它做结合

6
00:00:17,160 --> 00:00:18,880
那这种结合的思路呢

7
00:00:18,920 --> 00:00:21,120
实际上是由于段式存储

8
00:00:21,160 --> 00:00:22,680
它分的块比较大

9
00:00:22,720 --> 00:00:24,440
每一块里头的

10
00:00:24,480 --> 00:00:26,880
存储的内容是同一个段

11
00:00:26,920 --> 00:00:30,680
这同一个段的访问方式和存储的数据

12
00:00:30,720 --> 00:00:33,720
都是相同的或者相类似的

13
00:00:33,760 --> 00:00:35,160
在这样一来的话

14
00:00:35,200 --> 00:00:38,800
它去做存储的保护是比较方便的

15
00:00:38,840 --> 00:00:40,920
而另一种做法 页式存储

16
00:00:40,960 --> 00:00:44,240
它是由于分了很小的标准大小的块

17
00:00:44,280 --> 00:00:46,960
那这样的话它在内存利用效率

18
00:00:47,000 --> 00:00:51,480
内存和外存之间的存储的后备

19
00:00:51,520 --> 00:00:53,760
这方面呢它是会比较有优势

20
00:00:53,800 --> 00:00:55,320
那这时候自然就会说

21
00:00:55,360 --> 00:00:57,760
这两种做法各有各自优缺点

22
00:00:57,800 --> 00:00:59,600
我们有可能把它结合吗

23
00:00:59,640 --> 00:01:03,160
那这就是说把段式和页式结合起来

24
00:01:03,200 --> 00:01:05,720
这种直观想法呢也很简单

25
00:01:05,760 --> 00:01:08,840
实际上做起来的时候呢会是啥样的

26
00:01:08,880 --> 00:01:10,880
段页式存储管理的机制呢

27
00:01:10,920 --> 00:01:14,160
它的做法呢是在段式存储管理基础上

28
00:01:14,200 --> 00:01:17,080
给每一个段呢加一级页表

29
00:01:17,120 --> 00:01:20,200
那我们原来说逻辑地址到物理地址

30
00:01:20,240 --> 00:01:21,480
这逻辑地址怎么分呢

31
00:01:21,520 --> 00:01:24,120
原来是要么是段号加段内偏移

32
00:01:24,160 --> 00:01:25,840
要么是页号加页内偏移

33
00:01:25,880 --> 00:01:30,480
变成是段号 页号然后再加上页内偏移

34
00:01:30,520 --> 00:01:34,720
如果说你在这个页表里头再是多级页表

35
00:01:34,760 --> 00:01:36,880
那这个地方页表还可以再分成多级

36
00:01:36,920 --> 00:01:37,920
然后从这儿呢

37
00:01:37,960 --> 00:01:41,120
最后变到的是物理页号加页内偏移

38
00:01:41,160 --> 00:01:43,640
那它怎么来做呢

39
00:01:43,680 --> 00:01:48,680
首先是段号由进程的段基址

40
00:01:48,720 --> 00:01:51,120
找到相应的段表基址

41
00:01:51,160 --> 00:01:54,160
找到相应的段表项

42
00:01:54,200 --> 00:01:56,480
这个段表项里头呢

43
00:01:56,520 --> 00:01:59,920
有相应段的段长度和段基址

44
00:01:59,960 --> 00:02:04,160
那这些呢加在一起 我们得到一个

45
00:02:04,200 --> 00:02:08,280
相应段的页表的基址

46
00:02:08,320 --> 00:02:09,880
好 这个再加上页号

47
00:02:09,920 --> 00:02:12,080
我就可以得到相应的页表项

48
00:02:12,120 --> 00:02:14,000
页表项里头呢就有

49
00:02:14,040 --> 00:02:16,480
对应的物理页的页号

50
00:02:16,520 --> 00:02:17,800
物理页帧号

51
00:02:17,840 --> 00:02:21,320
这个页帧号和你的页内偏移加在一起

52
00:02:21,360 --> 00:02:24,080
就可以访问到实际的物理存储单元了

53
00:02:24,120 --> 00:02:26,080
那这种做法呢

54
00:02:26,120 --> 00:02:27,440
它可以在这个基础上

55
00:02:27,480 --> 00:02:28,800
我可以很方便地

56
00:02:28,840 --> 00:02:32,480
实现我们的内存共享

57
00:02:32,520 --> 00:02:34,600
那么共享的办法是什么呢

58
00:02:34,640 --> 00:02:37,080
我可以在段表的基址上

59
00:02:37,120 --> 00:02:38,840
加上一个共享段

60
00:02:38,880 --> 00:02:40,160
指向相同的页表

61
00:02:40,200 --> 00:02:41,560
那这两个段就共享了

62
00:02:41,600 --> 00:02:45,080
那我们具体看一下

63
00:02:45,120 --> 00:02:50,320
这是我们一个段页式的访问方式

64
00:02:50,360 --> 00:02:54,000
段表其中有一个段指向它的页表

65
00:02:54,040 --> 00:02:57,600
它的页表指向它的存储地址空间

66
00:02:57,640 --> 00:02:59,000
那如果说我想把这个段

67
00:02:59,040 --> 00:03:00,520
和另一个进程共享怎么办

68
00:03:00,560 --> 00:03:06,280
另一个进程它有自己的段表

69
00:03:06,320 --> 00:03:09,000
那么这里头我们俩是同一个段

70
00:03:09,040 --> 00:03:11,440
这是我指向同一个页表

71
00:03:11,480 --> 00:03:13,400
那这一块区域

72
00:03:13,440 --> 00:03:15,720
那就变成是它们俩共享的

73
00:03:15,760 --> 00:03:17,560
那我们看到这里头呢

74
00:03:17,600 --> 00:03:20,640
在页式 段式和段页式里头呢

75
00:03:20,680 --> 00:03:23,720
这共享的做法呢都是类似的

76
00:03:23,760 --> 00:03:25,680
好 到这个地方为止

77
00:03:25,720 --> 00:03:27,440
我们说清楚了

78
00:03:27,480 --> 00:03:31,920
非连续内存分配的几种做法

79
00:03:31,960 --> 00:03:35,240
段式 页式和段页式

80
00:03:35,280 --> 00:03:38,280
它们的共同点呢是

81
00:03:38,320 --> 00:03:41,080
我分配给一个进程的内存块

82
00:03:41,120 --> 00:03:43,600
它是可以不连续的

83
00:03:43,640 --> 00:03:45,520
那它们的区别是在于

84
00:03:45,560 --> 00:03:49,240
我在这里头分配块大小有不同

85
00:03:49,280 --> 00:03:52,560
段式分配的块是很大的

86
00:03:52,600 --> 00:03:53,680
以一个段为单位

87
00:03:53,720 --> 00:03:56,000
页式分配的块是很小的

88
00:03:56,040 --> 00:03:59,040
以你比如说是1K几K这种尺度

89
00:03:59,080 --> 00:04:01,120
作为一个最小单位

90
00:04:01,160 --> 00:04:03,880
而段页式呢是把这两种结合起来

91
00:04:03,920 --> 00:04:08,000
把这种非连续内存分配做法里

92
00:04:08,040 --> 00:04:09,360
所面临的问题就是

93
00:04:09,400 --> 00:04:12,720
中间要加一级页表或者段表

94
00:04:12,760 --> 00:04:14,680
这个表的加入会使得

95
00:04:14,720 --> 00:04:17,960
我原来连续存储方式里所没有的

96
00:04:18,000 --> 00:04:19,520
一些问题在这里出现

97
00:04:19,560 --> 00:04:22,040
比如说页表大小很大

98
00:04:22,080 --> 00:04:25,360
针对这种做法我们又有一系列的做法

99
00:04:25,400 --> 00:04:27,720
比如说像快表做缓存

100
00:04:27,760 --> 00:04:31,680
比如像多级页表做间接存储访问

101
00:04:31,720 --> 00:04:33,560
或者说反置页表

102
00:04:33,600 --> 00:04:37,040
那这些做法都可以改进我们

103
00:04:37,080 --> 00:04:40,680
由于引入非连续存储所带来的麻烦

104
00:04:40,720 --> 00:04:42,320
那当然我们在这里说的

105
00:04:42,360 --> 00:04:44,360
是它的基本做法

106
00:04:44,400 --> 00:04:45,760
在实际系统里 

107
00:04:45,800 --> 00:04:48,720
做法跟基本原理都是类似的

108
00:04:48,760 --> 00:04:50,800
但是其中有很多的实现细节

109
00:04:50,840 --> 00:04:53,080
需要我们在后续阅读当中

110
00:04:53,120 --> 00:04:54,680
来进一步了解

111
00:04:54,720 --> 00:04:57,320
好 今天的课就上到这里 下课

112
00:04:57,360 --> 00:04:57,400
    

