0
00:00:00,000 --> 00:00:07,040


1
00:00:07,080 --> 00:00:11,640
下面我们来介绍优先级反置

2
00:00:11,680 --> 00:00:14,400
优先级反置呢指的是说

3
00:00:14,440 --> 00:00:17,160
我们在操作系统当中

4
00:00:17,200 --> 00:00:20,440
出现高优先级的进程    

5
00:00:20,480 --> 00:00:24,400
由于等待低优先级进程所占用的资源

6
00:00:24,440 --> 00:00:26,200
而导致高优先级进程

7
00:00:26,240 --> 00:00:28,320
长期等待的现象

8
00:00:28,360 --> 00:00:30,880
这是一个例子

9
00:00:30,920 --> 00:00:34,400
进程T1它的优先级是40

10
00:00:34,440 --> 00:00:38,080
然后它占用的资源L1

11
00:00:38,120 --> 00:00:40,280
这时候另外一个进程T2

12
00:00:40,320 --> 00:00:42,000
它的优先级是50

13
00:00:42,040 --> 00:00:43,880
那它的运行过程当中

14
00:00:43,920 --> 00:00:46,160
要申请资源L1

15
00:00:46,200 --> 00:00:48,560
由于T1已经占用资源L1

16
00:00:48,600 --> 00:00:52,120
所以这时候它处于等待的状态

17
00:00:52,160 --> 00:00:53,760
那么按照正常情况下呢

18
00:00:53,800 --> 00:00:56,240
这时候T1就应该

19
00:00:56,280 --> 00:00:57,880
进入运行状态

20
00:00:57,920 --> 00:00:59,800
然后等到它释放资源

21
00:00:59,840 --> 00:01:01,360
然后高优先级的这个进程

22
00:01:01,400 --> 00:01:03,720
再获取这个资源

23
00:01:03,760 --> 00:01:05,480
但是在这个过程当中

24
00:01:05,520 --> 00:01:07,680
如果有另外一个进程T3

25
00:01:07,720 --> 00:01:09,280
它的优先级是46

26
00:01:09,320 --> 00:01:12,400
在高优先级的进程进入组合状态之后

27
00:01:12,440 --> 00:01:15,920
低优先级进程还没有得到CPU使用权 

28
00:01:15,960 --> 00:01:17,360
投入运行状态之前

29
00:01:17,400 --> 00:01:19,520
那T3进入运行状态

30
00:01:19,560 --> 00:01:23,040
那么这时候呢T1就没有办法继续执行

31
00:01:23,080 --> 00:01:24,760
那它所占用资源呢

32
00:01:24,800 --> 00:01:26,080
也就没有办法释放

33
00:01:26,120 --> 00:01:27,120
那这样的话 

34
00:01:27,160 --> 00:01:29,360
T2这个高优先级的进程呢

35
00:01:29,400 --> 00:01:30,880
就会一直等待下去

36
00:01:30,920 --> 00:01:31,960
这种情况呢 

37
00:01:32,000 --> 00:01:34,720
就是我们这里说的优先级反置

38
00:01:34,760 --> 00:01:36,160
优先级反置导致

39
00:01:36,200 --> 00:01:38,720
这个进程长期进入等待状态

40
00:01:38,760 --> 00:01:42,160
在什么时候会出现这种情况呢

41
00:01:42,200 --> 00:01:44,920
只要你是用的是基于优先级的

42
00:01:44,960 --> 00:01:46,960
并且是抢占的调度算法

43
00:01:47,000 --> 00:01:49,320
那么都会存在这种情况

44
00:01:49,360 --> 00:01:51,160
好那这种情况怎么处理呢

45
00:01:51,200 --> 00:01:54,880
我们在这儿介绍两种基本的做法

46
00:01:54,920 --> 00:01:58,200
一种呢称之为优先级进程

47
00:01:58,240 --> 00:02:00,680
优先级进程是指

48
00:02:00,720 --> 00:02:03,560
占用资源的低优先级进程

49
00:02:03,600 --> 00:02:09,080
继承申请资源的高优先级进程的优先级

50
00:02:09,120 --> 00:02:10,840
这种做法我们可以通过

51
00:02:10,880 --> 00:02:14,480
这样一个图式来展示

52
00:02:14,520 --> 00:02:17,560
在这里呢有三个进程

53
00:02:17,600 --> 00:02:19,400
T1 T2 T3

54
00:02:19,440 --> 00:02:23,440
它们这3条线呢代表不同的优先级

55
00:02:23,480 --> 00:02:26,520
底下T3优先级比较低

56
00:02:26,560 --> 00:02:31,440
那首先呢是T3进入执行状态

57
00:02:31,480 --> 00:02:35,920
那到T2时刻 它占用资源

58
00:02:35,960 --> 00:02:38,920
然后在临界区进行执行

59
00:02:38,960 --> 00:02:41,520
在临界区执行的过程当中呢

60
00:02:41,560 --> 00:02:42,760
这时候 有一个

61
00:02:42,800 --> 00:02:46,080
优先级比它高的进程T1

62
00:02:46,120 --> 00:02:47,400
进入执行状态

63
00:02:47,440 --> 00:02:50,200
那么它这时候呢被抢先

64
00:02:50,240 --> 00:02:53,080
好 T1开始执行

65
00:02:53,120 --> 00:02:57,880
在T1执行过程当中它申请资源S

66
00:02:57,920 --> 00:03:02,080
好 那这时候 T1的申请

67
00:03:02,120 --> 00:03:06,200
导致T3的优先级提升

68
00:03:06,240 --> 00:03:07,800
那提升上来之后

69
00:03:07,840 --> 00:03:10,800
那么这时候呢它继续往下执行

70
00:03:10,840 --> 00:03:13,960
它执行到释放资源S

71
00:03:14,000 --> 00:03:16,320
那 释放资源S之后

72
00:03:16,360 --> 00:03:22,040
那这时候T1就可以获取这个资源

73
00:03:22,080 --> 00:03:24,880
然后继续它的临界区执行

74
00:03:24,920 --> 00:03:27,280
等到它释放资源之后

75
00:03:27,320 --> 00:03:29,640
那它再继续执行

76
00:03:29,680 --> 00:03:30,600
在这个过程当中

77
00:03:30,640 --> 00:03:31,960
如果说有T2出现

78
00:03:32,000 --> 00:03:34,440
那么它必须等到T1结束之后

79
00:03:34,480 --> 00:03:38,240
它才能占用CPU来继续执行

80
00:03:38,280 --> 00:03:39,640
在这个过程当中

81
00:03:39,680 --> 00:03:43,640
由于T3被T1强占

82
00:03:43,680 --> 00:03:46,480
所以这时候 会有高优先级

83
00:03:46,520 --> 00:03:48,960
等低优先级的这种情况

84
00:03:49,000 --> 00:03:51,400
T3申请到资源

85
00:03:51,440 --> 00:03:53,480
而高优先级的T1

86
00:03:53,520 --> 00:03:55,200
进入执行状态的时候

87
00:03:55,240 --> 00:03:58,720
那么这时候T3被阻塞

88
00:03:58,760 --> 00:04:00,880
它申请资源的时候呢

89
00:04:00,920 --> 00:04:02,400
如果它申请的正好是

90
00:04:02,440 --> 00:04:05,440
T3所占用的这个资源

91
00:04:05,480 --> 00:04:07,280
那么T3的优先级

92
00:04:07,320 --> 00:04:09,840
就会提到跟它一样的高度

93
00:04:09,880 --> 00:04:12,760
好 那这时候呢它就可以进入执行状态

94
00:04:12,800 --> 00:04:14,560
等到它释放资源

95
00:04:14,600 --> 00:04:16,600
好 那么这时候它优先级又回来了

96
00:04:16,640 --> 00:04:18,600
回来之后 那这时候呢

97
00:04:18,640 --> 00:04:22,640
T1就可以获取到这个资源

98
00:04:22,680 --> 00:04:24,000
因为它这时候进入执行状态

99
00:04:24,040 --> 00:04:27,200
并且它的申请呢就能获得批准

100
00:04:27,240 --> 00:04:29,360
好 然后一直到它释放

101
00:04:29,400 --> 00:04:30,760
那它正常执行

102
00:04:30,800 --> 00:04:33,200
那我们说 在这种情况下

103
00:04:33,240 --> 00:04:36,440
优先级反置的现象呢就没有了

104
00:04:36,480 --> 00:04:38,440
那在这儿呢 需要说明的是

105
00:04:38,480 --> 00:04:41,800
这个占有资源的低优先级进程

106
00:04:41,840 --> 00:04:43,680
只有在被阻塞的情况下

107
00:04:43,720 --> 00:04:46,560
它才会提升优先级

108
00:04:46,600 --> 00:04:47,640
如果不是这样的话

109
00:04:47,680 --> 00:04:50,480
那么它的优先级是不会被提升的

110
00:04:50,520 --> 00:04:54,840
另一种做法呢 叫优先级天花板协议

111
00:04:54,880 --> 00:04:55,840
它的做法是什么呢

112
00:04:55,880 --> 00:04:59,680
就是占有资源的进程

113
00:04:59,720 --> 00:05:04,360
和所有可能申请该资源的进程相比较

114
00:05:04,400 --> 00:05:06,960
那把它的优先级呢设置成

115
00:05:07,000 --> 00:05:09,440
这些可能申请资源的进程里

116
00:05:09,480 --> 00:05:11,600
优先级里最高一个

117
00:05:11,640 --> 00:05:12,880
用这种办法的话

118
00:05:12,920 --> 00:05:14,560
那它占用资源的时候

119
00:05:14,600 --> 00:05:16,440
其它的任何进程都不会

120
00:05:16,480 --> 00:05:18,880
阻止它使用这个资源了

121
00:05:18,920 --> 00:05:23,400
那这种做法呢 不管是否发生等待

122
00:05:23,440 --> 00:05:25,280
我的优先级都会提高

123
00:05:25,320 --> 00:05:26,760
实际上在这种做法里

124
00:05:26,800 --> 00:05:29,440
可能会有优先级滥用的情况

125
00:05:29,480 --> 00:05:30,400
也就是大家会把

126
00:05:30,440 --> 00:05:32,240
自己的优先级提的很高

127
00:05:32,280 --> 00:05:34,240
实际上所有都提到最高优先级的话

128
00:05:34,280 --> 00:05:37,400
提高优先级已经没有意义了

129
00:05:37,440 --> 00:05:38,720
好 所以在这儿呢

130
00:05:38,760 --> 00:05:40,160
由于高于系统当中

131
00:05:40,200 --> 00:05:42,520
所有被锁定资源的优先级

132
00:05:42,560 --> 00:05:43,440
好那这时候呢

133
00:05:43,480 --> 00:05:45,280
它在执行临界区的时候

134
00:05:45,320 --> 00:05:46,800
就不会被堵塞了

135
00:05:46,840 --> 00:05:49,800
这是两种理论上的做法

136
00:05:49,840 --> 00:05:51,280
在我们实际系统里头呢

137
00:05:51,320 --> 00:05:55,360
通常情况下都跟这有很大的区别

138
00:05:55,400 --> 00:05:56,400
详细的情况呢

139
00:05:56,440 --> 00:05:58,320
希望大家去看实际系统当中的

140
00:05:58,360 --> 00:06:01,720
相关的文档和代码

141
00:06:01,760 --> 00:06:04,440
好 到现在为止呢

142
00:06:04,480 --> 00:06:06,520
我们就讨论清楚了

143
00:06:06,560 --> 00:06:09,600
操作系统当中的处理机调度的

144
00:06:09,640 --> 00:06:13,040
基本原理和我们这些调度算法

145
00:06:13,080 --> 00:06:16,960
以及于对实时调度和多处理机调度呢

146
00:06:17,000 --> 00:06:18,600
有一个简要的介绍

147
00:06:18,640 --> 00:06:20,600
最后说明了在调度算法当中

148
00:06:20,640 --> 00:06:24,240
可能出现的优先级反置现象

149
00:06:24,280 --> 00:06:27,880
好 今天的课呢就到这里 下课

150
00:06:27,920 --> 00:06:28,000


151
00:06:28,040 --> 00:06:28,080


