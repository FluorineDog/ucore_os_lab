0
00:00:00,000 --> 00:00:07,120


1
00:00:07,440 --> 00:00:09,920
各位同学好 那么接下来我们介绍一下

2
00:00:09,960 --> 00:00:14,080
有关lab1的具体的实验的一些细节

3
00:00:14,120 --> 00:00:17,120
那前面我们已经给大家在讲解了一下

4
00:00:17,160 --> 00:00:20,480
有关lab1的一些基本的一些知识

5
00:00:20,520 --> 00:00:24,360
包括我们说这里面看到CPU的分段机制

6
00:00:24,400 --> 00:00:26,680
CPU 特别是X86这个架构

7
00:00:26,720 --> 00:00:28,520
以及X86中断处理机制

8
00:00:28,560 --> 00:00:32,200
然后在lab1里面其实这些方面都可以涉及到

9
00:00:32,240 --> 00:00:33,280
那我们lab1主要干什么呢

10
00:00:33,320 --> 00:00:36,200
我们看看 它的实验目的 

11
00:00:36,240 --> 00:00:38,120
那lab1的实验目的是希望

12
00:00:38,160 --> 00:00:43,000
能够把这个OS给加载到内存中去执行

13
00:00:43,040 --> 00:00:44,960
那么能够加载OS呢 我们也知道

14
00:00:45,000 --> 00:00:46,120
我们还需要一个Bootloader

15
00:00:46,160 --> 00:00:48,560
所以说在这里面包含了怎么去设计

16
00:00:48,600 --> 00:00:51,800
Bootloader以及把这个OS加载进去之后呢

17
00:00:51,840 --> 00:00:55,200
它能够去管理中断还有就是

18
00:00:55,240 --> 00:00:57,600
有基本的一个外设的一个处理

19
00:00:57,640 --> 00:00:59,280
那在这里面我们学到什么呢

20
00:00:59,320 --> 00:01:00,840
希望通过这个lab1

21
00:01:00,880 --> 00:01:03,400
我们知道在计算机原理这一块呢

22
00:01:03,440 --> 00:01:04,960
可以看到它涉及到是

23
00:01:05,000 --> 00:01:07,560
CPU的编址与寻址这一点很重要

24
00:01:07,600 --> 00:01:09,760
因为我们的Bootloader

25
00:01:09,800 --> 00:01:13,760
我们的uCore OS都会加载到内存中去运行

26
00:01:13,800 --> 00:01:16,960
在CPU里面如何寻址

27
00:01:17,000 --> 00:01:19,200
如何对内存进行编址这一点很重要

28
00:01:19,240 --> 00:01:21,760
没有这个相应的一个处理的话

29
00:01:21,800 --> 00:01:26,640
那么我们后续就很难对内存进行有效的管理

30
00:01:26,680 --> 00:01:29,080
这里面可以看到基于分段机制内存管理

31
00:01:29,120 --> 00:01:31,480
这是我们X86里面一个很有特色的一个地方

32
00:01:31,520 --> 00:01:34,680
当然这里面我们用很简单的分段机制

33
00:01:34,720 --> 00:01:38,080
第二是CPU的中断处理这

34
00:01:38,120 --> 00:01:39,360
是我们需要去了解的

35
00:01:39,400 --> 00:01:43,560
第三个 我们可以看到它可以有外设

36
00:01:43,600 --> 00:01:46,680
它可以通过相应的一些控制机制

37
00:01:46,720 --> 00:01:50,440
能够跟外设打交道来完成最基本的一些处理

38
00:01:50,480 --> 00:01:52,920
比如说在lab1里面会涉及到什么呢

39
00:01:52,960 --> 00:01:56,600
串口 并口 CGA 就是我们的显示器

40
00:01:56,640 --> 00:02:00,360
以及时钟 就是产生时钟中断

41
00:02:00,400 --> 00:02:04,200
有时钟 还有硬盘的读取 这些操作呢

42
00:02:04,240 --> 00:02:07,200
其实都是计算机原理中会涉及到内容

43
00:02:07,240 --> 00:02:10,200
在我们的lab1里面就一下子都反映到了

44
00:02:10,240 --> 00:02:15,120
虽然看的很多 但其实还是很简单的

45
00:02:15,160 --> 00:02:18,560
为了能够充分的利用这些外设

46
00:02:18,600 --> 00:02:21,560
我们有两个软件 这里面其实包含了两个软件

47
00:02:21,600 --> 00:02:23,400
一个是Bootloader 一个是uCore 

48
00:02:23,440 --> 00:02:24,360
在Bootloader里面呢

49
00:02:24,400 --> 00:02:27,720
我们会学到如何去编译 运行 调试

50
00:02:27,760 --> 00:02:29,480
Bootloader这个软件

51
00:02:29,520 --> 00:02:31,440
第二个也会学到 uCore其实也是一样

52
00:02:31,480 --> 00:02:33,240
也需要有编译 运行 调试

53
00:02:33,280 --> 00:02:35,000
这是一些通用一些技术

54
00:02:35,040 --> 00:02:36,120
把这个掌握之后呢

55
00:02:36,160 --> 00:02:39,120
其实对大家后续学习其他的lab

56
00:02:39,160 --> 00:02:40,280
完成其他的lab实验呢

57
00:02:40,320 --> 00:02:42,320
会打下一个比较好的基础

58
00:02:42,360 --> 00:02:44,480
第二个呢我们会看到在Bootloader里面

59
00:02:44,520 --> 00:02:47,000
它会涉及到对文件的读取

60
00:02:47,040 --> 00:02:49,640
那么ELF去执行文件 它怎么去读取的

61
00:02:49,680 --> 00:02:51,240
第三是外设 怎么去访问

62
00:02:51,280 --> 00:02:55,120
它至少能够把硬盘中的数据读到内存中来

63
00:02:55,160 --> 00:02:57,160
第一个 第二个能够显示字符串

64
00:02:57,200 --> 00:02:59,240
这是Bootloader能够完成的

65
00:02:59,280 --> 00:03:00,400
一个很重要的事情

66
00:03:00,440 --> 00:03:03,160
其实它还有个很重要的工作

67
00:03:03,200 --> 00:03:08,320
就是能够把这个CPU

68
00:03:08,360 --> 00:03:10,520
让CPU进入保护模式

69
00:03:10,560 --> 00:03:13,720
这是Bootloader干的很重要的一个事情

70
00:03:13,760 --> 00:03:15,520
在uCoreOS里面呢 

71
00:03:15,560 --> 00:03:18,560
Bootloader首先会把uCoreOS加载进来

72
00:03:18,600 --> 00:03:21,080
然后把控制权交给uCoreOS去运行

73
00:03:21,120 --> 00:03:24,600
所以我们还会知道uCore OS它怎么启动的

74
00:03:24,640 --> 00:03:27,040
第二个呢 我们怎么能够去分析

75
00:03:27,080 --> 00:03:29,480
在uCoreOS中的这个函数的调用关系

76
00:03:29,520 --> 00:03:33,480
还有 在uCoreOS里面需要考虑中断

77
00:03:33,520 --> 00:03:38,320
因为它要为接下来这个实验做好一个准备

78
00:03:38,360 --> 00:03:40,200
有了中断这个管理机制之后呢

79
00:03:40,240 --> 00:03:42,600
当外设发出请求之后呢

80
00:03:42,640 --> 00:03:46,040
我们的CPU可以通过中断机制得到响应

81
00:03:46,080 --> 00:03:48,360
第二个呢 当你产生异常

82
00:03:48,400 --> 00:03:50,680
或者发出系统调用的时候 我们的软件 

83
00:03:50,720 --> 00:03:53,160
我们的软件由于你某种不恰当的操作

84
00:03:53,200 --> 00:03:55,040
产生某种异常或者系统调用

85
00:03:55,080 --> 00:03:56,760
或者是一些错误的时候呢

86
00:03:56,800 --> 00:03:58,440
那通过这个中断管理机制呢

87
00:03:58,480 --> 00:04:01,520
能够感知到这种现象的存在

88
00:04:01,560 --> 00:04:02,920
并进行相应的处理

89
00:04:02,960 --> 00:04:05,080
所以中断这个机制很重要

90
00:04:05,120 --> 00:04:07,000
第三 在uCore里面还能看到

91
00:04:07,040 --> 00:04:10,000
有了中断管理机制之后我们就可以控制外设

92
00:04:10,040 --> 00:04:13,240
让外设定期地产生时钟中断

93
00:04:13,280 --> 00:04:14,960
比如这个时钟就是一种外设

94
00:04:15,000 --> 00:04:18,360
OK 那这是我们lab1会涉及到内容

95
00:04:18,400 --> 00:04:20,120
相对而言我们可以看到它

96
00:04:20,160 --> 00:04:22,760
和我们原理课对应在什么地方呢

97
00:04:22,800 --> 00:04:27,560
原理课我们的前几节课其实会讲到中断

98
00:04:27,600 --> 00:04:30,880
会讲到系统调用 会讲到异常 这一块呢

99
00:04:30,920 --> 00:04:34,000
在这里面有一个中断管理好像是直接对应的

100
00:04:34,040 --> 00:04:37,040
第二个讲到连续物理空间的分配

101
00:04:37,080 --> 00:04:38,960
而连续物理空间的分配呢

102
00:04:39,000 --> 00:04:41,680
是和我们这边说到这个CPU的编址 

103
00:04:41,720 --> 00:04:45,000
寻址基于分段机制的内存管理是有紧密联系的

104
00:04:45,040 --> 00:04:46,880
因为我们这里面把这个分段机制

105
00:04:46,920 --> 00:04:48,680
就可以看成是一种简单的

106
00:04:48,720 --> 00:04:51,400
这种连续物理内存一种管理机制

107
00:04:51,440 --> 00:04:55,440
在这种机制下我们怎么有效去完成后续的

108
00:04:55,480 --> 00:04:58,040
我们在lab2中会碰到物理内存管理

109
00:04:58,080 --> 00:05:00,440
首先得要有这个基础 这个基础要打好

110
00:05:00,480 --> 00:05:04,200
所以我们可以看到 这里面做lab1

111
00:05:04,240 --> 00:05:06,000
它和我们原理课的关系

112
00:05:06,040 --> 00:05:08,960
这里可以看出 有两个很重要的关系

113
00:05:09,000 --> 00:05:11,720
一个是连续内存的管理

114
00:05:11,760 --> 00:05:13,600
第二个是中断的处理

115
00:05:13,640 --> 00:05:15,320
其他部分呢 都是说为了能够

116
00:05:15,360 --> 00:05:18,360
让一个OS能够正常的运转起来

117
00:05:18,400 --> 00:05:21,480
所不得不涉及各方面一些知识

118
00:05:21,520 --> 00:05:22,880
这个知识了解之后

119
00:05:22,920 --> 00:05:26,480
我想对大家后续完成各种实验

120
00:05:26,520 --> 00:05:29,360
会打一个很好的一个基础

121
00:05:29,400 --> 00:05:31,320
那接下来我们可以看看

122
00:05:31,360 --> 00:05:34,600
我们到底要完成哪些练习

123
00:05:34,640 --> 00:05:36,080
为了能够实现lab1这个目标呢

124
00:05:36,120 --> 00:05:40,200
我们大致提供了6个基本练习和一个扩展练习

125
00:05:40,240 --> 00:05:43,840
比较多 确实这个lab1的相对来说

126
00:05:43,880 --> 00:05:49,080
它容量比较大 但是我相信大家通过仔细的阅读

127
00:05:49,120 --> 00:05:53,600
相应的实验指导书以及仔细的阅读代码

128
00:05:53,640 --> 00:05:57,880
了解自己的所不知道的一些知识之后呢

129
00:05:57,920 --> 00:06:03,160
能够很快的完成这些实验 我们看一下lab1 

130
00:06:03,200 --> 00:06:04,040
lab1什么意思呢 

131
00:06:04,080 --> 00:06:07,120
lab1其实主要是让大家熟悉这个实验的过程

132
00:06:07,160 --> 00:06:09,760
它要能够理解如何通过Make

133
00:06:09,800 --> 00:06:12,160
来生成执行文件的过程

134
00:06:12,200 --> 00:06:13,640
这里面其实我们可以看看

135
00:06:13,680 --> 00:06:18,080
我们这里给大家做一个demo

136
00:06:18,120 --> 00:06:20,840
这是我们这个lab1这个答案的这个目录

137
00:06:20,880 --> 00:06:22,560
在这儿 就是lab result

138
00:06:22,600 --> 00:06:24,960
首先我们make clean一下

139
00:06:25,000 --> 00:06:28,680
可以把这个刚才编译这些都给它删除掉

140
00:06:28,720 --> 00:06:32,400
然后呢 make V= 

141
00:06:32,440 --> 00:06:35,000
这实际上就是设置一个标记

142
00:06:35,040 --> 00:06:37,560
使得我们Make它的执行过程能够展现出来

143
00:06:37,600 --> 00:06:41,080
详细的这个编译执行过程会展现出来

144
00:06:41,120 --> 00:06:43,480
那可以看到它调了GCC

145
00:06:43,520 --> 00:06:47,400
GCC来把一些C的源代码

146
00:06:47,440 --> 00:06:51,040
编译成了所谓的.O文件是目标文件

147
00:06:51,080 --> 00:06:56,520
然后通过ld，ld会把这些目标文件呢

148
00:06:56,560 --> 00:06:58,400
会转换成一个执行程序

149
00:06:58,440 --> 00:07:03,120
比如说在这里面会转换成这个bootblock.out

150
00:07:03,160 --> 00:07:04,760
这个实际上是可以理解为

151
00:07:04,800 --> 00:07:10,320
是一个Bootloader一个执行程序

152
00:07:10,360 --> 00:07:12,360
还有一些程序比如说用dd呢

153
00:07:12,400 --> 00:07:14,520
最后可以把这个Bootloader

154
00:07:14,560 --> 00:07:17,440
把Bootloader放到一个虚拟的硬盘里面去

155
00:07:17,480 --> 00:07:20,760
我们这儿生成一个虚拟硬盘叫uCore.img count

156
00:07:20,800 --> 00:07:21,840
我们硬件模拟器呢

157
00:07:21,880 --> 00:07:24,280
就会基于这个虚拟硬盘中的数据

158
00:07:24,320 --> 00:07:28,040
来执行相应的这个代码

159
00:07:28,080 --> 00:07:31,000
当然后面还看到这里面其实生成了两个软件

160
00:07:31,040 --> 00:07:33,560
第一个是Bootloader 第二叫kernel

161
00:07:33,600 --> 00:07:36,520
kernel实际上是uCore的组成部分

162
00:07:36,560 --> 00:07:39,360
所以说可以通过刚才这条命令

163
00:07:39,400 --> 00:07:44,560
能够知道Bootloader

164
00:07:44,600 --> 00:07:48,560
以及uCore是如何一步步生成的

165
00:07:48,600 --> 00:07:53,360
当然它取决于我们一个文件 Makefile

166
00:07:53,400 --> 00:07:55,320
这个文件相对来说比较复杂

167
00:07:55,360 --> 00:07:59,120
大家一开始的时候其实不用太去管这个文件

168
00:07:59,160 --> 00:08:04,320
你只要管 你到底要去用到了哪些.C程序

169
00:08:04,360 --> 00:08:08,600
来最后生成了Bootloader和uCore就OK了

170
00:08:08,640 --> 00:08:12,040
如果大家感兴趣的话可以再做进一步的了解

171
00:08:12,080 --> 00:08:20,440
我们说刚才已经看到uCore.img如何生成的

172
00:08:20,480 --> 00:08:22,000
给大家做了简单介绍 

173
00:08:22,040 --> 00:08:28,360
第二个问题 一个被系统认为是符合规范的

174
00:08:28,400 --> 00:08:30,080
硬件主引导扇区的特征是什么

175
00:08:30,120 --> 00:08:32,040
这个呢其实也是一个小的一个细节

176
00:08:32,080 --> 00:08:34,080
就是我们怎么知道

177
00:08:34,120 --> 00:08:35,600
特别是我们说BIOS

178
00:08:35,640 --> 00:08:38,400
在引导这个主引导扇区的时候

179
00:08:38,440 --> 00:08:40,880
它怎么知道主引导扇区是符合规范的

180
00:08:40,920 --> 00:08:42,400
那它有一定的特征

181
00:08:42,440 --> 00:08:46,400
这个特征呢其实大家需要看一下

182
00:08:46,440 --> 00:08:50,440
提示一下 需要看一下一个文件

183
00:08:50,480 --> 00:08:52,760
在哪呢 在这个tools里面

184
00:08:52,800 --> 00:08:56,800
它最后有一个 有这么一个文件

185
00:08:56,840 --> 00:09:02,120
sign.c 在这个文件里面

186
00:09:02,160 --> 00:09:06,880
它完成了特征的标记

187
00:09:06,920 --> 00:09:08,080
需要大家去读一读

188
00:09:08,120 --> 00:09:10,960
看看到底哪个是这个特征的标记

189
00:09:11,000 --> 00:09:15,160
好 那练习一呢 就给大家简单介绍到这儿

190
00:09:15,200 --> 00:09:15,240


