0
00:00:00,000 --> 00:00:07,160


1
00:00:07,400 --> 00:00:12,760
我们再接下来看一下练习二

2
00:00:12,840 --> 00:00:14,880
练习二也是一个实践的过程

3
00:00:14,920 --> 00:00:18,600
我们希望大家能够通过

4
00:00:18,640 --> 00:00:21,960
我们硬件模拟器qemu 还有GDB

5
00:00:22,000 --> 00:00:26,840
能够执行和调试lab1中的软件

6
00:00:26,880 --> 00:00:28,400
这里面给出一些小的练习

7
00:00:28,440 --> 00:00:31,760
比如说我们能不能单步跟踪BIOS

8
00:00:31,800 --> 00:00:34,240
单步跟踪0x7C00处的设置断点

9
00:00:34,280 --> 00:00:38,480
然后把它整个执行过程代码给记录下来等等

10
00:00:38,520 --> 00:00:40,920
这是我们后续要去完成的实验

11
00:00:40,960 --> 00:00:43,600
这里面呢 我们可以看到

12
00:00:43,640 --> 00:00:45,240
这里也给出了提示

13
00:00:45,280 --> 00:00:49,520
我们在这里有一个叫做makelab1-mon

14
00:00:49,560 --> 00:01:01,000
这是一个什么呢

15
00:01:01,040 --> 00:01:02,960
那这条命令你可以看出来

16
00:01:03,000 --> 00:01:05,160
它这里面大致是干了两个事情

17
00:01:05,200 --> 00:01:10,280
第一个是让qemu把它执行的指令给记录下来

18
00:01:10,320 --> 00:01:12,040
把log信息给记录下来

19
00:01:12,080 --> 00:01:13,920
放到这个地方 q.log

20
00:01:13,960 --> 00:01:20,800
第二个是和我们的GDB结合

21
00:01:20,840 --> 00:01:22,520
结合来调试

22
00:01:22,560 --> 00:01:27,120
来可以调试正在执行的Bootloader

23
00:01:27,160 --> 00:01:30,680
需要注意 这里面还没有到uCore

24
00:01:30,720 --> 00:01:32,280
还在Bootloader阶段

25
00:01:32,320 --> 00:01:33,440
这个比较重要

26
00:01:33,480 --> 00:01:35,160
它是以前初始化的一些执行指令

27
00:01:35,200 --> 00:01:46,200
我们看看这里面有什么内容

28
00:01:46,240 --> 00:01:47,800
 那这个呢都是GDB

29
00:01:47,840 --> 00:01:49,880
GDB能够识别的一些命令

30
00:01:49,920 --> 00:01:53,240
它第一个 比如说加载bin/kernel

31
00:01:53,280 --> 00:01:55,200
这是加载符号信息了

32
00:01:55,240 --> 00:01:56,680
这实际上是uCore的信息

33
00:01:56,720 --> 00:01:58,240
这里其实还没用到 第二个呢是 

34
00:01:58,280 --> 00:02:02,120
第二条指令是与qemu进行连接

35
00:02:02,160 --> 00:02:04,600
通过这个TRP进行连接

36
00:02:04,640 --> 00:02:06,200
刚开始的时候

37
00:02:06,240 --> 00:02:10,640
BIOS是进入是8086的16位实模式方式

38
00:02:10,680 --> 00:02:15,120
那一直到0x7C00在BIOS这个阶段启动

39
00:02:15,160 --> 00:02:16,920
最后把Bootloader加载进去

40
00:02:16,960 --> 00:02:18,760
把控制权交给Bootloader

41
00:02:18,800 --> 00:02:20,800
那么Bootloader第一条指令

42
00:02:20,840 --> 00:02:23,160
就是在0X7C00处

43
00:02:23,200 --> 00:02:24,040
所以说 在这个地方

44
00:02:24,080 --> 00:02:26,640
我们设一个断点break 

45
00:02:26,680 --> 00:02:28,600
break 0X7C00

46
00:02:28,640 --> 00:02:31,840
然后让这个系统继续运行

47
00:02:31,880 --> 00:02:32,520
那我们就可以看到

48
00:02:32,560 --> 00:02:35,000
它会在这个断点处停下来

49
00:02:35,040 --> 00:02:38,080
那我们可以把相应的这个指令给打印出来

50
00:02:38,120 --> 00:02:40,880
最后一条是x /2i $pc

51
00:02:40,920 --> 00:02:43,360
就是把这个 我们PC 就是我们EIP

52
00:02:43,400 --> 00:02:45,880
也就是指令的指针寄存器

53
00:02:45,920 --> 00:02:49,600
它存当前正在执行这个指令的地址

54
00:02:49,640 --> 00:02:51,880
那么X是显示的意思

55
00:02:51,920 --> 00:02:56,880
/2i是显示两条 i 是指令 是个含义

56
00:02:56,920 --> 00:03:03,560
那么我们可以看看执行下会是怎么一个结果

57
00:03:03,600 --> 00:03:09,520
比如说make lab1 mon

58
00:03:09,560 --> 00:03:11,720
它前两个窗口 一个是qemu

59
00:03:11,760 --> 00:03:15,120
这里面是qemu 可以看到已经启动起来了

60
00:03:15,160 --> 00:03:17,440
但是它断下来了 断在哪呢

61
00:03:17,480 --> 00:03:20,160
0X7C00处 我们这已经看到了

62
00:03:20,200 --> 00:03:23,920
那这里面 其实还可以显示更多条数信息

63
00:03:23,960 --> 00:03:32,560
比如说我们可以在x/10i $pc

64
00:03:32,600 --> 00:03:35,040
可以把当前的10条指令都显示出来

65
00:03:35,080 --> 00:03:37,680
那这些指令在哪呢

66
00:03:37,720 --> 00:03:45,560
大家想 这个指令在什么地方

67
00:03:45,600 --> 00:03:48,280
我们启动代码这个目录下存放

68
00:03:48,320 --> 00:03:52,000
就是Bootloader那 其实也可以看到

69
00:03:52,040 --> 00:03:58,280
在这边 从第16行开始 它这个指令

70
00:03:58,320 --> 00:04:01,640
和我们刚才看到的GDB里面的指令

71
00:04:01,680 --> 00:04:06,320
我把这个先关掉 

72
00:04:06,360 --> 00:04:10,880
和我们看到GDB里面的指令是一样的

73
00:04:10,920 --> 00:04:12,600
可以看到其实我们现在

74
00:04:12,640 --> 00:04:15,360
已经断到了Bootloader起始的位置

75
00:04:15,400 --> 00:04:19,440
我们接下来可以让它继续运行

76
00:04:19,480 --> 00:04:21,040
那我们可以看到这个效果

77
00:04:21,080 --> 00:04:23,760
我们可以把这个显示在这儿

78
00:04:23,800 --> 00:04:26,920
让它一直位于顶端 OK

79
00:04:26,960 --> 00:04:28,720
那这时候它就一直会出现

80
00:04:28,760 --> 00:04:30,560
continuing一下 好

81
00:04:30,600 --> 00:04:32,400
你可以看到 这时候它跑的很快

82
00:04:32,440 --> 00:04:33,440
就是这里面 

83
00:04:33,480 --> 00:04:35,720
它已经把我们uCore都加起来了

84
00:04:35,760 --> 00:04:37,280
可以进去运行了

85
00:04:37,320 --> 00:04:38,680
Ctrl+C断掉

86
00:04:38,720 --> 00:04:40,360
OK那现在就停下来了

87
00:04:40,400 --> 00:04:44,120
这就是一个很方便的调试Bootloader的方法

88
00:04:44,160 --> 00:04:53,960
包括后续的uCore也是一样 很类似

89
00:04:54,000 --> 00:04:57,840
好 那这是一些提示信息

90
00:04:57,880 --> 00:04:59,520
比如GDB里面怎么去单步调试

91
00:04:59,560 --> 00:05:00,880
那这是命令方式

92
00:05:00,920 --> 00:05:03,720
我们上次讲lab0所以给大家提示过

93
00:05:03,760 --> 00:05:06,160
怎么能够在ECLIPSE环境下

94
00:05:06,200 --> 00:05:10,280
来提升它调试 这个命令比较简单

95
00:05:10,320 --> 00:05:12,360
所以我们用GDB直接来调试了

96
00:05:12,400 --> 00:05:12,440


