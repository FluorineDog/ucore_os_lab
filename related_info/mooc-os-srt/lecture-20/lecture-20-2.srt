0
00:00:00,000 --> 00:00:07,040


1
00:00:07,080 --> 00:00:11,960
下面我们来讨论死锁的处理方法

2
00:00:12,000 --> 00:00:13,240
死锁的处理方法呢

3
00:00:13,280 --> 00:00:15,400
我们通常情况下可以理解为

4
00:00:15,440 --> 00:00:18,360
跟我们的消防的方法是很类似的

5
00:00:18,400 --> 00:00:20,680
这里头呢 我们基本上可以按照

6
00:00:20,720 --> 00:00:25,040
消防的那些处理方法来进行类比

7
00:00:25,080 --> 00:00:29,280
首先第一个 就是死锁预防

8
00:00:29,320 --> 00:00:32,760
确保系统永远不会进入死锁状态

9
00:00:32,800 --> 00:00:34,640
比如说我们在消防里头

10
00:00:34,680 --> 00:00:36,080
为了避免火灾

11
00:00:36,120 --> 00:00:37,920
我在一些敏感的区域里头

12
00:00:37,960 --> 00:00:39,880
我就会限定 在这个区域里头

13
00:00:39,920 --> 00:00:42,400
不允许用任何的火

14
00:00:42,440 --> 00:00:43,560
好 那这样一来的话

15
00:00:43,600 --> 00:00:45,040
在这个区域里出现火灾的

16
00:00:45,080 --> 00:00:46,480
可能性也就没有了

17
00:00:46,520 --> 00:00:47,720
那对于死锁来说呢

18
00:00:47,760 --> 00:00:48,920
我们也是一样的

19
00:00:48,960 --> 00:00:49,640
我们在那里呢

20
00:00:49,680 --> 00:00:51,120
死锁可能出现的时候

21
00:00:51,160 --> 00:00:52,520
有四个必要条件

22
00:00:52,560 --> 00:00:54,160
那我们把那四个必要条件里的

23
00:00:54,200 --> 00:00:55,280
任何一个去掉

24
00:00:55,320 --> 00:00:57,520
它就不会进入死锁了

25
00:00:57,560 --> 00:00:58,320
但是这时候呢

26
00:00:58,360 --> 00:01:00,560
实际上它的问题是说

27
00:01:00,600 --> 00:01:03,520
你不让它使用这些资源

28
00:01:03,560 --> 00:01:05,880
不让那四个条件得到满足

29
00:01:05,920 --> 00:01:07,920
那这时候呢 实际上可能的问题是

30
00:01:07,960 --> 00:01:11,280
系统的资源利用效率比较低

31
00:01:11,320 --> 00:01:12,880
那这就是第二种做法

32
00:01:12,920 --> 00:01:14,480
就是死锁避免

33
00:01:14,520 --> 00:01:15,920
这可以理解为

34
00:01:15,960 --> 00:01:18,960
我们采用严格的监管措施

35
00:01:19,000 --> 00:01:22,040
到底是否是允许用火

36
00:01:22,080 --> 00:01:24,560
有一个严格的审批流程

37
00:01:24,600 --> 00:01:26,720
比如说在某些区域里头

38
00:01:26,760 --> 00:01:30,360
你不可以完全禁止用火

39
00:01:30,400 --> 00:01:31,760
那这时候呢 我就会说

40
00:01:31,800 --> 00:01:33,880
什么样的人 有什么样的资质的人

41
00:01:33,920 --> 00:01:35,880
能够处理这个问题的人 你可以用

42
00:01:35,920 --> 00:01:39,000
比如说在林区的防火

43
00:01:39,040 --> 00:01:41,280
只有相应的 有资质的人

44
00:01:41,320 --> 00:01:42,600
你可以在这里头去使用

45
00:01:42,640 --> 00:01:44,680
这是我们这里的第二种做法

46
00:01:44,720 --> 00:01:47,520
在使用之前进行判断

47
00:01:47,560 --> 00:01:51,200
只允许不会出现死锁的进程请求资源

48
00:01:51,240 --> 00:01:54,360
这就是我们在这里头 死锁避免

49
00:01:54,400 --> 00:01:55,960
再有一种做法呢

50
00:01:56,000 --> 00:01:58,360
是我在管理不过来的时候

51
00:01:58,400 --> 00:02:00,120
那我就会允许第三种做法

52
00:02:00,160 --> 00:02:02,640
死锁检测和恢复

53
00:02:02,680 --> 00:02:04,200
是否会出现死锁

54
00:02:04,240 --> 00:02:05,280
这个事我管不过来

55
00:02:05,320 --> 00:02:06,680
那我也就不管了

56
00:02:06,720 --> 00:02:10,120
比如说像在居民用火

57
00:02:10,160 --> 00:02:12,200
你不允许他不用火是不可能的

58
00:02:12,240 --> 00:02:16,040
你进行严格的监管呢也做不到

59
00:02:16,080 --> 00:02:16,840
那这怎么办呢

60
00:02:16,880 --> 00:02:18,840
我们就预备一个消防队

61
00:02:18,880 --> 00:02:21,000
出了问题之后我派消防队去

62
00:02:21,040 --> 00:02:22,520
那么这也是一样的

63
00:02:22,560 --> 00:02:26,720
我检测到系统进入死锁状态后

64
00:02:26,760 --> 00:02:28,960
那我就进行恢复

65
00:02:29,000 --> 00:02:31,120
而在我们这几种做法里头呢

66
00:02:31,160 --> 00:02:32,880
在我们实际的操作系统里呢

67
00:02:32,920 --> 00:02:35,480
通常情况下我们把这件事情

68
00:02:35,520 --> 00:02:37,840
指派给应用进程来处理

69
00:02:37,880 --> 00:02:41,520
通常操作系统是忽略死锁的存在

70
00:02:41,560 --> 00:02:42,800
这是我们目前

71
00:02:42,840 --> 00:02:45,320
大多数操作系统的做法

72
00:02:45,360 --> 00:02:47,600
那有了这样一个非常粗的介绍之后

73
00:02:47,640 --> 00:02:49,680
我们下边就来具体看一下

74
00:02:49,720 --> 00:02:53,080
这三种做法里的情况

75
00:02:53,120 --> 00:02:55,000
第一个 死锁预防

76
00:02:55,040 --> 00:02:55,360
也就是说

77
00:02:55,400 --> 00:03:00,520
我们限制进程申请资源的方式

78
00:03:00,560 --> 00:03:01,760
那怎么来限制呢

79
00:03:01,800 --> 00:03:04,840
就是限制的结果是

80
00:03:04,880 --> 00:03:08,840
不满足死锁的必要条件

81
00:03:08,880 --> 00:03:10,880
怎么能做到不满足死锁的必要条件呢

82
00:03:10,920 --> 00:03:13,040
我们有四个条件

83
00:03:13,080 --> 00:03:14,840
任何一个不满足就可以了

84
00:03:14,880 --> 00:03:16,200
比如说第一个互斥

85
00:03:16,240 --> 00:03:19,240
我们把需要互斥访问的资源

86
00:03:19,280 --> 00:03:22,080
封装成可以同时访问的

87
00:03:22,120 --> 00:03:23,600
那这件事情就没了

88
00:03:23,640 --> 00:03:26,240
一个实际的例子是说我们的打印机

89
00:03:26,280 --> 00:03:28,520
在早期的时候 打印机每个进程

90
00:03:28,560 --> 00:03:31,440
可以往打印机上送打印作业

91
00:03:31,480 --> 00:03:33,400
那这时候 在送的过程当中呢

92
00:03:33,440 --> 00:03:36,160
是必须互斥的

93
00:03:36,200 --> 00:03:40,240
如果说两个进程同时往一台打印机上

94
00:03:40,280 --> 00:03:41,200
送打印作业

95
00:03:41,240 --> 00:03:42,280
那这时候打出来的结果

96
00:03:42,320 --> 00:03:43,800
是谁也不能用了

97
00:03:43,840 --> 00:03:46,280
而现在呢 我们在使用打印机的时候

98
00:03:46,320 --> 00:03:48,080
你基本上感觉不到这一条

99
00:03:48,120 --> 00:03:51,360
原因在于 我们在打印机里加了缓冲

100
00:03:51,400 --> 00:03:53,160
只有当前一个送完了之后

101
00:03:53,200 --> 00:03:57,160
它才会去接收另一个的打印请求

102
00:03:57,200 --> 00:03:58,440
那这就是我们现在的

103
00:03:58,480 --> 00:04:00,160
网络打印机的做法

104
00:04:00,200 --> 00:04:01,040
好 那这样一来的话

105
00:04:01,080 --> 00:04:02,880
它就可以大家一起使用

106
00:04:02,920 --> 00:04:04,360
只是说在打印机内部

107
00:04:04,400 --> 00:04:06,840
它给你协调谁先谁后

108
00:04:06,880 --> 00:04:09,760
这是第一个 把互斥条件去掉

109
00:04:09,800 --> 00:04:12,480
第二个是说 我把持有并等待

110
00:04:12,520 --> 00:04:14,120
这个条件给去掉

111
00:04:14,160 --> 00:04:15,560
那在这个条件里头呢

112
00:04:15,600 --> 00:04:17,680
实际上是我申请到的一部分资源

113
00:04:17,720 --> 00:04:19,960
我再去申请另一部分资源

114
00:04:20,000 --> 00:04:21,640
那我怎么可以把它去掉呢

115
00:04:21,680 --> 00:04:24,400
一种做法是说你在请求资源的时候

116
00:04:24,440 --> 00:04:26,840
你不能占用任何资源

117
00:04:26,880 --> 00:04:27,880
这指什么意思呢

118
00:04:27,920 --> 00:04:30,120
这指是说你要想申请资源的话

119
00:04:30,160 --> 00:04:31,320
你就必须一次

120
00:04:31,360 --> 00:04:33,680
把所有的资源全部申请到

121
00:04:33,720 --> 00:04:35,840
如果说你已经申请了一部分

122
00:04:35,880 --> 00:04:37,120
然后再去申请的话

123
00:04:37,160 --> 00:04:40,320
那就会出现死锁的可能性

124
00:04:40,360 --> 00:04:42,720
这个呢 有一个形象的比喻是说

125
00:04:42,760 --> 00:04:45,280
我们在贷款的时候

126
00:04:45,320 --> 00:04:48,080
你希望去做一个项目

127
00:04:48,120 --> 00:04:48,840
好 这时候呢

128
00:04:48,880 --> 00:04:50,480
需要银行给你贷款

129
00:04:50,520 --> 00:04:52,480
那你可以说 我一次把所有

130
00:04:52,520 --> 00:04:54,360
我需要的钱全部贷出来

131
00:04:54,400 --> 00:04:56,120
这样就避免一种情况是说

132
00:04:56,160 --> 00:04:58,280
我做到一半 我钱不够用了

133
00:04:58,320 --> 00:04:59,640
这种情况

134
00:04:59,680 --> 00:05:01,680
但是这时候呢 它的问题是

135
00:05:01,720 --> 00:05:04,240
它的资源效率会是利用比较低的

136
00:05:04,280 --> 00:05:05,960
这种做法更细化下去的一种

137
00:05:06,000 --> 00:05:07,840
可以操作的做法就是

138
00:05:07,880 --> 00:05:09,920
我进程在开始的时候

139
00:05:09,960 --> 00:05:13,200
申请所有需要的资源

140
00:05:13,240 --> 00:05:14,560
如果说我不满足

141
00:05:14,600 --> 00:05:15,680
我这个申请的要求的话

142
00:05:15,720 --> 00:05:17,080
那就不允许它开始

143
00:05:17,120 --> 00:05:19,120
那这样一来每一个开始进程

144
00:05:19,160 --> 00:05:21,440
它就确信它一定能执行到结束

145
00:05:21,480 --> 00:05:23,600
这样的话我这个问题也解决掉了

146
00:05:23,640 --> 00:05:25,200


147
00:05:25,240 --> 00:05:26,880
这是它最主要的问题

148
00:05:26,920 --> 00:05:28,520
资源利用效率太低

149
00:05:28,560 --> 00:05:30,840
你比如说像我们修一个水电站

150
00:05:30,880 --> 00:05:32,640
持续几年 十几年的时间

151
00:05:32,680 --> 00:05:33,960
那你最开始的时候

152
00:05:34,000 --> 00:05:36,480
一口气把它需要的资金全部到位

153
00:05:36,520 --> 00:05:37,320
那这时候实际上

154
00:05:37,360 --> 00:05:39,920
它的利用效率是非常低的

155
00:05:39,960 --> 00:05:43,160
那第三个做法呢 是非抢占

156
00:05:43,200 --> 00:05:45,400
我们在前边说有一个条件

157
00:05:45,440 --> 00:05:47,640
你分配资源之后

158
00:05:47,680 --> 00:05:49,760
进程不主动放弃的话

159
00:05:49,800 --> 00:05:51,080
我是没有办法回收的

160
00:05:51,120 --> 00:05:53,040
这样的话 我才能构成

161
00:05:53,080 --> 00:05:56,000
循环无限期等待

162
00:05:56,040 --> 00:05:57,280
如果说在这里头加一个条件

163
00:05:57,320 --> 00:06:00,640
一旦你申请的资源不能立即分配

164
00:06:00,680 --> 00:06:03,840
你就释放你已经占用的所有资源

165
00:06:03,880 --> 00:06:05,160
如果说我们有这一条的话

166
00:06:05,200 --> 00:06:06,520
那这件事情也没有了

167
00:06:06,560 --> 00:06:08,160
这个对于我们刚才说的

168
00:06:08,200 --> 00:06:10,120
单向通行桥梁的情况

169
00:06:10,160 --> 00:06:12,640
就是一旦两辆车撞上了

170
00:06:12,680 --> 00:06:15,360
那这时候两辆车都会往回倒

171
00:06:15,400 --> 00:06:16,560
那再来申请的时候

172
00:06:16,600 --> 00:06:19,040
这个单向通行的桥梁呢

173
00:06:19,080 --> 00:06:20,640
也就能通行了

174
00:06:20,680 --> 00:06:23,840
只有在这里头 进程能够获取到

175
00:06:23,880 --> 00:06:25,320
它所有需要的资源

176
00:06:25,360 --> 00:06:26,880
它才给它分配

177
00:06:26,920 --> 00:06:28,120
这样的话实际上某种角度上

178
00:06:28,160 --> 00:06:29,640
跟我们前面说的

179
00:06:29,680 --> 00:06:32,880
去掉持有并等待这个条件的做法

180
00:06:32,920 --> 00:06:34,400
有类似的地方

181
00:06:34,440 --> 00:06:36,000
也相当于在那里头呢

182
00:06:36,040 --> 00:06:38,520
我是要申请一次全部申请

183
00:06:38,560 --> 00:06:40,280
在这地方呢 我申请

184
00:06:40,320 --> 00:06:42,040
在我再申请的时候

185
00:06:42,080 --> 00:06:44,040
我必须需要的资源都有

186
00:06:44,080 --> 00:06:45,600
我才能够往下申请

187
00:06:45,640 --> 00:06:48,920


188
00:06:48,960 --> 00:06:50,640
最后一个 循环等待

189
00:06:50,680 --> 00:06:51,920
我们怎么把它去掉呢

190
00:06:51,960 --> 00:06:53,640
实际上就是对资源排序

191
00:06:53,680 --> 00:06:57,080
按照我们固定的顺序来申请资源

192
00:06:57,120 --> 00:06:59,840
这时候我就不存在循环等待了

193
00:06:59,880 --> 00:07:01,000
这时候它会有啥问题呢

194
00:07:01,040 --> 00:07:03,600
和我们前边的做法有类似的地方

195
00:07:03,640 --> 00:07:04,880
按照顺序来申请

196
00:07:04,920 --> 00:07:07,040
可能你先申请的某一项资源

197
00:07:07,080 --> 00:07:08,280
实际上我是后用到

198
00:07:08,320 --> 00:07:10,360
这时候也会有效率下降的问题

199
00:07:10,400 --> 00:07:13,400
这是我们说到的死锁预防

200
00:07:13,440 --> 00:07:14,720
通过这一类办法呢

201
00:07:14,760 --> 00:07:17,840
我们可以避免死锁出现的四个条件

202
00:07:17,880 --> 00:07:21,080
任何一个不成立 那这事就没了

203
00:07:21,120 --> 00:07:24,720
第二类做法呢 是死锁避免

204
00:07:24,760 --> 00:07:26,360
这是针对第一类做法

205
00:07:26,400 --> 00:07:28,440
如果说我想完全禁止掉

206
00:07:28,480 --> 00:07:29,600
它出现死锁的话

207
00:07:29,640 --> 00:07:32,120
那这时候呢 我的资源利用效率低

208
00:07:32,160 --> 00:07:34,280
那提高资源利用效率的办法呢

209
00:07:34,320 --> 00:07:37,320
就是给我自己分配资源的时候

210
00:07:37,360 --> 00:07:39,240
把这个手续变得更复杂

211
00:07:39,280 --> 00:07:40,640
那这里做法就是

212
00:07:40,680 --> 00:07:44,280
我利用额外的先验信息

213
00:07:44,320 --> 00:07:45,920
在分配资源的时候

214
00:07:45,960 --> 00:07:48,880
我来判断是否会出现死锁

215
00:07:48,920 --> 00:07:51,400
如果说有可能出现死锁

216
00:07:51,440 --> 00:07:53,280
那我就不分配给你

217
00:07:53,320 --> 00:07:55,640
那只是没有可能出现死锁的情况

218
00:07:55,680 --> 00:07:56,600
我才分配给你

219
00:07:56,640 --> 00:07:58,840
这就是我们这里说的死锁避免

220
00:07:58,880 --> 00:08:02,320
这就有点像在银行里 你去借款

221
00:08:02,360 --> 00:08:05,480
它依据你的信用情况

222
00:08:05,520 --> 00:08:07,720
来判断我借给你之后

223
00:08:07,760 --> 00:08:10,480
你是否会如期归还

224
00:08:10,520 --> 00:08:13,160
如果说我判断完的结果

225
00:08:13,200 --> 00:08:15,040
你是有可能不如期归还

226
00:08:15,080 --> 00:08:17,000
当然我判断完之后

227
00:08:17,040 --> 00:08:18,160
你有可能不如期归还

228
00:08:18,200 --> 00:08:20,760
你也有可能是能归还的

229
00:08:20,800 --> 00:08:22,440
好 我判断完了之后

230
00:08:22,480 --> 00:08:24,080
只是信用比较好的

231
00:08:24,120 --> 00:08:26,040
我才分配给它资源

232
00:08:26,080 --> 00:08:28,160
当然这种情况它也是有风险的

233
00:08:28,200 --> 00:08:29,600
那在计算机系统里头呢

234
00:08:29,640 --> 00:08:31,640
就是你对先验知识的准确性了

235
00:08:31,680 --> 00:08:33,240


236
00:08:33,280 --> 00:08:34,920
具体做法是这样的

237
00:08:34,960 --> 00:08:39,360
要求进程事先声明你的需求量

238
00:08:39,400 --> 00:08:42,800
也就是说你最大的需求资源数是多少

239
00:08:42,840 --> 00:08:45,560
银行里头可以满足这个资源数

240
00:08:45,600 --> 00:08:48,600
那我就把这资源分配给你

241
00:08:48,640 --> 00:08:50,120
那这时候呢 实际上相当于

242
00:08:50,160 --> 00:08:52,560
我限定提供和分配资源的时候

243
00:08:52,600 --> 00:08:56,680
我必须能确保满足进程的最大需求

244
00:08:56,720 --> 00:08:58,280
如果不能满足的话

245
00:08:58,320 --> 00:09:01,480
我就是会有麻烦的 会出现死锁

246
00:09:01,520 --> 00:09:03,200
那我就不分配给你

247
00:09:03,240 --> 00:09:05,560
那这时候说 我们怎么知道

248
00:09:05,600 --> 00:09:08,920
它是否会有麻烦呢

249
00:09:08,960 --> 00:09:11,560
那这时候就是 我们动态进行检查

250
00:09:11,600 --> 00:09:13,600
那这时候就是我们前面说到的

251
00:09:13,640 --> 00:09:16,400
资源分配图 在这就能用得上了

252
00:09:16,440 --> 00:09:18,720
我判断分配给你这个资源之后

253
00:09:18,760 --> 00:09:20,720
不会出现死锁

254
00:09:20,760 --> 00:09:22,000
我就把它分配给你

255
00:09:22,040 --> 00:09:24,280
这是第二种做法

256
00:09:24,320 --> 00:09:25,920
那在这第二种做法里头呢

257
00:09:25,960 --> 00:09:27,520
就有一个比较麻烦的事

258
00:09:27,560 --> 00:09:31,400
银行或者说系统必须来动态地判断

259
00:09:31,440 --> 00:09:33,120
我是否分配给你资源之后

260
00:09:33,160 --> 00:09:34,560
不会出现死锁

261
00:09:34,600 --> 00:09:36,440
那这就是我们这里说到的

262
00:09:36,480 --> 00:09:38,720
系统资源分配安全状态

263
00:09:38,760 --> 00:09:42,960
你在请求的时候系统判断是否安全

264
00:09:43,000 --> 00:09:44,360
安全了我才分配给你

265
00:09:44,400 --> 00:09:46,160
那怎么算是安全呢 

266
00:09:46,200 --> 00:09:47,960
实际上就是针对

267
00:09:48,000 --> 00:09:52,720
所有进程已占用的资源

268
00:09:52,760 --> 00:09:56,760
我来找出一个进程的执行序列

269
00:09:56,800 --> 00:09:58,080
这个序列执行

270
00:09:58,120 --> 00:10:00,200
保证我已有的资源能够满足

271
00:10:00,240 --> 00:10:02,200
这个序列执行到结束

272
00:10:02,240 --> 00:10:03,920
如果能行的话

273
00:10:03,960 --> 00:10:06,200
我这系统的状态就是安全的

274
00:10:06,240 --> 00:10:08,240
好 你要求分配的资源

275
00:10:08,280 --> 00:10:10,120
我就是可以分配给你了

276
00:10:10,160 --> 00:10:12,280
稍微具体一点是这样的

277
00:10:12,320 --> 00:10:15,880
我当前所有占用资源的进程

278
00:10:15,920 --> 00:10:17,280
P1到Pn 

279
00:10:17,320 --> 00:10:19,720
我在这里给它做一个排序

280
00:10:19,760 --> 00:10:22,600
这个排序有这样一个要求

281
00:10:22,640 --> 00:10:24,640
Pi要求的资源

282
00:10:24,680 --> 00:10:28,800
它小于我当前可用的空闲资源

283
00:10:28,840 --> 00:10:32,480
和Pj已经占用的资源

284
00:10:32,520 --> 00:10:34,360
这个Pj是在这个序列当中

285
00:10:34,400 --> 00:10:36,800
小于i的所有之间

286
00:10:36,840 --> 00:10:38,240
也就是说在它之前的

287
00:10:38,280 --> 00:10:41,000
这些进程已经占用的资源

288
00:10:41,040 --> 00:10:45,560
加上现在可用的这些空闲的资源

289
00:10:45,600 --> 00:10:46,440
它俩搁在一起

290
00:10:46,480 --> 00:10:49,320
是否能满足进程PI的要求

291
00:10:49,360 --> 00:10:50,960
如果能满足

292
00:10:51,000 --> 00:10:53,000
对于所有这些都能满足的话

293
00:10:53,040 --> 00:10:54,960
那这就是安全的

294
00:10:55,000 --> 00:10:57,080
这就相当于是什么样的做法呢

295
00:10:57,120 --> 00:11:00,560
就是第一个进程Pi

296
00:11:00,600 --> 00:11:02,760
它没有再往前的进程了

297
00:11:02,800 --> 00:11:04,000
所以这时候呢

298
00:11:04,040 --> 00:11:05,200
当前可用的资源

299
00:11:05,240 --> 00:11:07,800
必须能够满足P1的需求

300
00:11:07,840 --> 00:11:10,520
那这时候它就是安全的

301
00:11:10,560 --> 00:11:12,720
如果说后续的某一个Pi

302
00:11:12,760 --> 00:11:14,080
它请求的时候

303
00:11:14,120 --> 00:11:15,920
当前可用的不够

304
00:11:15,960 --> 00:11:18,480
前边还有一些被其他进程占用了

305
00:11:18,520 --> 00:11:21,040
那这时候它就等待

306
00:11:21,080 --> 00:11:23,520
等待你前边的这些进程执行结束

307
00:11:23,560 --> 00:11:25,280
那你的占用资源不就回来了吗

308
00:11:25,320 --> 00:11:28,520
由于有上边的一条回来的资源

309
00:11:28,560 --> 00:11:30,200
就能够满足我的要求了

310
00:11:30,240 --> 00:11:33,520
搁在一起我就可以执行完毕了

311
00:11:33,560 --> 00:11:34,360
执行完之后

312
00:11:34,400 --> 00:11:36,240
我这事就行了

313
00:11:36,280 --> 00:11:38,000
等到整个序列当中的

314
00:11:38,040 --> 00:11:40,640
任何一个进程都执行结束

315
00:11:40,680 --> 00:11:43,920
最后一个也就能满足它的需求

316
00:11:43,960 --> 00:11:46,640
到这我们整个系统里的

317
00:11:46,680 --> 00:11:49,320
占有资源的进程都能正常的完成

318
00:11:49,360 --> 00:11:52,000
那我的系统就是安全的

319
00:11:52,040 --> 00:11:53,560
有了这个描述之后

320
00:11:53,600 --> 00:11:57,240
我们的安全和死锁之间的关系呢

321
00:11:57,280 --> 00:11:59,040
就可以用这个图来表示

322
00:11:59,080 --> 00:12:01,720
说我们在这个系统里头

323
00:12:01,760 --> 00:12:03,200
处于安全状态的

324
00:12:03,240 --> 00:12:05,560
它一定不会出现死锁

325
00:12:05,600 --> 00:12:08,520
那是不是说我不安全的

326
00:12:08,560 --> 00:12:09,640
就一定会死锁呢

327
00:12:09,680 --> 00:12:10,440
也不是这样的

328
00:12:10,480 --> 00:12:11,560
就好比说银行

329
00:12:11,600 --> 00:12:13,640
我把这个款贷出去

330
00:12:13,680 --> 00:12:15,960
有可能对方还不了我

331
00:12:16,000 --> 00:12:18,280
但是他也有可能能还我

332
00:12:18,320 --> 00:12:19,520
如果他能还的话

333
00:12:19,560 --> 00:12:22,040
这件事情也是可做的

334
00:12:22,080 --> 00:12:23,440
这就看你的风险有多大了

335
00:12:23,480 --> 00:12:26,200
实际上我们在这画了一个更大的圈

336
00:12:26,240 --> 00:12:28,880
用不安全其中包括死锁状态

337
00:12:28,920 --> 00:12:31,840
我只是对于安全情况我来分配资源

338
00:12:31,880 --> 00:12:32,360
这样的话

339
00:12:32,400 --> 00:12:34,320
从而保证我系统不会出现死锁

340
00:12:34,360 --> 00:12:35,760
如果说不安全

341
00:12:35,800 --> 00:12:38,120
是有可能出现死锁的

342
00:12:38,160 --> 00:12:40,120
我们避免出现死锁

343
00:12:40,160 --> 00:12:41,840
我就在这画的这条线上

344
00:12:41,880 --> 00:12:44,800
来保证我系统是处于安全的状态

345
00:12:44,840 --> 00:12:46,760
到这我们说清楚了

346
00:12:46,800 --> 00:12:49,280
死锁的处理的三类办法

347
00:12:49,320 --> 00:12:51,280
基本上是按照我们消防的

348
00:12:51,320 --> 00:12:53,600
那三类办法来做处理

349
00:12:53,640 --> 00:12:53,920


350
00:12:53,960 --> 00:12:54,480


351
00:12:54,520 --> 00:12:54,560


