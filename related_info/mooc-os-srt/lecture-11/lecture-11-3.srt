0
00:00:00,000 --> 00:00:06,360


1
00:00:06,400 --> 00:00:10,320
接下来我们讨论进程的状态

2
00:00:10,360 --> 00:00:13,440
进程的状态呢是指操作系统为了

3
00:00:13,480 --> 00:00:16,960
维护进程执行的过程当中的

4
00:00:17,000 --> 00:00:18,520
所有信息的变化

5
00:00:18,560 --> 00:00:20,240
那它有必要知道进程

6
00:00:20,280 --> 00:00:22,960
在执行过程当中会出现哪些状态

7
00:00:23,000 --> 00:00:26,280
它会在什么情况下会发生变化

8
00:00:26,320 --> 00:00:28,320
那这是呢我们对进程

9
00:00:28,360 --> 00:00:30,200
在整个生命周期当中

10
00:00:30,240 --> 00:00:32,960
它可能出现的一些事件的划分

11
00:00:33,000 --> 00:00:34,640
这种划分呢在不同的

12
00:00:34,680 --> 00:00:36,760
操作系统当中它会不一样

13
00:00:36,800 --> 00:00:38,040
比如说在我们这里头

14
00:00:38,080 --> 00:00:39,520
把它划分成创建

15
00:00:39,560 --> 00:00:42,040
有可能你需要其中一个程序执行

16
00:00:42,080 --> 00:00:42,880
那这个启动过程

17
00:00:42,920 --> 00:00:45,480
就会导致一个新的进程的创建

18
00:00:45,520 --> 00:00:47,200
那创建完了之后呢

19
00:00:47,240 --> 00:00:50,120
它就会是程序进入执行的状态

20
00:00:50,160 --> 00:00:51,160
这是第二个

21
00:00:51,200 --> 00:00:53,200
它会占用CPU来执行

22
00:00:53,240 --> 00:00:56,960
在执行的过程当中它可能会由于

23
00:00:57,000 --> 00:00:58,520
等待某个资源或者

24
00:00:58,560 --> 00:01:01,560
等待某个数据而进入等待状态

25
00:01:01,600 --> 00:01:02,560
好那这个时候呢

26
00:01:02,600 --> 00:01:05,200
就导致进程进行等待

27
00:01:05,240 --> 00:01:06,720
好在执行的过程当中

28
00:01:06,760 --> 00:01:08,200
还会有另外一种情况

29
00:01:08,240 --> 00:01:08,640
你比如说

30
00:01:08,680 --> 00:01:11,480
我一个优先级低的进程正在执行

31
00:01:11,520 --> 00:01:13,960
这时候有一个高优先级的进程

32
00:01:14,000 --> 00:01:16,520
有等待状态结束

33
00:01:16,560 --> 00:01:18,520
就是它等待的条件已经成熟了

34
00:01:18,560 --> 00:01:19,600
已经满足了

35
00:01:19,640 --> 00:01:22,080
好那这时候它要马上开始投入运行

36
00:01:22,120 --> 00:01:25,040
有可能我当前这个进程是会抢先

37
00:01:25,080 --> 00:01:26,720
那这时候呢我这个

38
00:01:26,760 --> 00:01:29,760
先进入就绪状态这个进程叫抢先

39
00:01:29,800 --> 00:01:32,000
而当前正在执行这个进程呢

40
00:01:32,040 --> 00:01:34,480
叫做被抢占

41
00:01:34,520 --> 00:01:37,520
好那处于等待状态的进程呢

42
00:01:37,560 --> 00:01:39,920
它会碰到被唤醒的情况

43
00:01:39,960 --> 00:01:42,640
在外界条件满足的时候它会被唤醒

44
00:01:42,680 --> 00:01:43,480
唤醒之后呢

45
00:01:43,520 --> 00:01:45,920
又排到这个就绪队列里头

46
00:01:45,960 --> 00:01:49,080
也就说它等待占用CPU来继续执行

47
00:01:49,120 --> 00:01:51,280
那等最后回到CPU上执行

48
00:01:51,320 --> 00:01:52,920
执行到最后的某种状态呢

49
00:01:52,960 --> 00:01:54,800
整个程序的工作全部执行完

50
00:01:54,840 --> 00:01:58,600
那就有可能进到进程结束的状态

51
00:01:58,640 --> 00:01:59,920
那这时候到达结束

52
00:01:59,960 --> 00:02:02,160
那整个呢这是我们在这里头

53
00:02:02,200 --> 00:02:06,080
对进程的生命周期的一个划分

54
00:02:06,120 --> 00:02:08,000
这种划分呢在不同系统里呢

55
00:02:08,040 --> 00:02:09,880
会有一些变化

56
00:02:09,920 --> 00:02:12,440
大致的情况呢基本上就是这几种

57
00:02:12,480 --> 00:02:14,160
那我们具体来讨论一下

58
00:02:14,200 --> 00:02:15,400
这些状态的变化

59
00:02:15,440 --> 00:02:18,040
首先一个进程创建

60
00:02:18,080 --> 00:02:19,280
要创建一个进程

61
00:02:19,320 --> 00:02:20,400
实际上我们在前面说

62
00:02:20,440 --> 00:02:22,160
每一个进程有一个进程控制块

63
00:02:22,200 --> 00:02:25,400
那这些相关的它要占用内存

64
00:02:25,440 --> 00:02:27,880
把代码和数据都拷进去

65
00:02:27,920 --> 00:02:29,320
这些资源的准备过程

66
00:02:29,360 --> 00:02:31,240
就对应到我们这里进程创建

67
00:02:31,280 --> 00:02:33,640
那可能导致创建的事件呢

68
00:02:33,680 --> 00:02:35,640
有这样几种

69
00:02:35,680 --> 00:02:37,760
第一个系统初始化

70
00:02:37,800 --> 00:02:38,800
初始化完成之后

71
00:02:38,840 --> 00:02:41,280
我要创建第一个用户进程

72
00:02:41,320 --> 00:02:42,720
那这是一种情况

73
00:02:42,760 --> 00:02:45,240
然后在用户进程执行的过程当中

74
00:02:45,280 --> 00:02:47,480
我可能会要执行某项功能

75
00:02:47,520 --> 00:02:50,120
用户请求创建一个新的进程

76
00:02:50,160 --> 00:02:51,880
那实际上这个请求过程呢

77
00:02:51,920 --> 00:02:54,120
也会导致一个程序

78
00:02:54,160 --> 00:02:57,440
我会执行创建进程的系统调用

79
00:02:57,480 --> 00:02:59,480
这是我们操作系统对上

80
00:02:59,520 --> 00:03:03,880
提供的创建进程的API

81
00:03:03,920 --> 00:03:06,560
好创建好了这个进程之后呢

82
00:03:06,600 --> 00:03:09,320
我们就会放到内核里的

83
00:03:09,360 --> 00:03:10,320
就绪队列里头

84
00:03:10,360 --> 00:03:11,720
这时候进程控制块呢

85
00:03:11,760 --> 00:03:13,240
就排到这个就绪队列里头

86
00:03:13,280 --> 00:03:15,960
好那等待CPU调度

87
00:03:16,000 --> 00:03:18,480
那如果说这个处理机

88
00:03:18,520 --> 00:03:19,800
没有其它进程运行

89
00:03:19,840 --> 00:03:22,320
那我就会调度一个

90
00:03:22,360 --> 00:03:23,600
新的进程来运行

91
00:03:23,640 --> 00:03:24,640
这时候调度呢就会

92
00:03:24,680 --> 00:03:27,000
导致我这个进程进入运行状态

93
00:03:27,040 --> 00:03:30,200
那我如何来选择一个

94
00:03:30,240 --> 00:03:31,520
就绪进程来运行

95
00:03:31,560 --> 00:03:33,720
如果说你只有一个那我就选择它

96
00:03:33,760 --> 00:03:35,280
如果有多个我怎么选择

97
00:03:35,320 --> 00:03:37,120
那实际上这种选择的依据呢

98
00:03:37,160 --> 00:03:38,760
就是我们后面会讲到的

99
00:03:38,800 --> 00:03:41,360
处理机的调度算法

100
00:03:41,400 --> 00:03:43,720
那不同的调度算法系统会体现出

101
00:03:43,760 --> 00:03:48,840
不同样的进程执行的特征

102
00:03:48,880 --> 00:03:50,880
好在执行的过程当中呢

103
00:03:50,920 --> 00:03:52,320
有可能进程执行的

104
00:03:52,360 --> 00:03:53,840
某一项条件不成立

105
00:03:53,880 --> 00:03:55,200
需要等待的某个数据

106
00:03:55,240 --> 00:03:57,280
或者说外部资源不足够

107
00:03:57,320 --> 00:03:58,000
那这时候呢

108
00:03:58,040 --> 00:04:00,960
我进程会进入等待状态

109
00:04:01,000 --> 00:04:03,040
那这种等待状态呢

110
00:04:03,080 --> 00:04:04,240
可能的原因是说

111
00:04:04,280 --> 00:04:06,520
我等待的系统的服务

112
00:04:06,560 --> 00:04:08,280
并没有马上完成

113
00:04:08,320 --> 00:04:10,000
或者说我启动的某个操作

114
00:04:10,040 --> 00:04:11,720
比如说我读写磁盘

115
00:04:11,760 --> 00:04:12,840
那这个读的过程呢

116
00:04:12,880 --> 00:04:15,280
它并不能在很短的时间里给出来

117
00:04:15,320 --> 00:04:16,920
因为我指令执行的速度

118
00:04:16,960 --> 00:04:20,280
是远高于我磁盘读写的速度了

119
00:04:20,320 --> 00:04:21,680
好再有一个就是

120
00:04:21,720 --> 00:04:23,960
我等待需要的数据没有到达

121
00:04:24,000 --> 00:04:25,120
那这些都会导致

122
00:04:25,160 --> 00:04:27,520
我进程进到等待状态

123
00:04:27,560 --> 00:04:29,720
一旦这些等待事件出现之后

124
00:04:29,760 --> 00:04:30,680
它就会回到这儿

125
00:04:30,720 --> 00:04:33,720
那么在这中间呢还会再有一种情况

126
00:04:33,760 --> 00:04:37,600
在这里呢等待事件的进入一定是我

127
00:04:37,640 --> 00:04:39,200
正在运行这个进程

128
00:04:39,240 --> 00:04:41,600
本身内部的原因所导致的

129
00:04:41,640 --> 00:04:42,960
它不是由于外部原因

130
00:04:43,000 --> 00:04:47,920
所导致它进入等待状态的

131
00:04:47,960 --> 00:04:49,280
好在执行的过程当中呢

132
00:04:49,320 --> 00:04:50,760
还有一种可能的变化

133
00:04:50,800 --> 00:04:55,320
就是我正在运行的进程被抢占

134
00:04:55,360 --> 00:04:57,720
那这种情况呢会出现在

135
00:04:57,760 --> 00:05:01,840
我有高优先级的进程变成就绪

136
00:05:01,880 --> 00:05:03,640
它需要马上投入运行

137
00:05:03,680 --> 00:05:05,840
那会把我正在运行的这个进程呢

138
00:05:05,880 --> 00:05:07,840
变成就绪然后让它运行

139
00:05:07,880 --> 00:05:09,480
第二种情况呢是说

140
00:05:09,520 --> 00:05:12,160
我们在操作系统里头它的调度算法

141
00:05:12,200 --> 00:05:13,640
为每个进程分配了

142
00:05:13,680 --> 00:05:15,840
它可以执行的最长时间

143
00:05:15,880 --> 00:05:18,160
如果你分配的这个时间片用完了

144
00:05:18,200 --> 00:05:18,840
那这时候呢

145
00:05:18,880 --> 00:05:19,600
系统

146
00:05:19,640 --> 00:05:22,720
操作系统内核会强制把这个进程呢

147
00:05:22,760 --> 00:05:25,760
抢先让下一个进程投入运行

148
00:05:25,800 --> 00:05:29,480
那这是呢时间片在这里起到的作用

149
00:05:29,520 --> 00:05:33,160
好那这个地方呢是说

150
00:05:33,200 --> 00:05:35,360
我在什么情况会回到就绪状态

151
00:05:35,400 --> 00:05:37,200
那就是说我进程被唤醒

152
00:05:37,240 --> 00:05:39,400
那唤醒的可能条件呢是

153
00:05:39,440 --> 00:05:41,160
我们刚才进入等待的

154
00:05:41,200 --> 00:05:42,960
那几个条件的反过来

155
00:05:43,000 --> 00:05:44,680
我等待的资源满足了

156
00:05:44,720 --> 00:05:46,560
我等待的事件出现了

157
00:05:46,600 --> 00:05:47,760
那都会出现这种情况

158
00:05:47,800 --> 00:05:53,440
而和这个等待进入相反

159
00:05:53,480 --> 00:05:55,040
唤醒的条件呢

160
00:05:55,080 --> 00:05:57,920
一定是被其别的进程或者

161
00:05:57,960 --> 00:05:59,920
操作系统唤醒

162
00:05:59,960 --> 00:06:03,080
它不会是由于自身的原因直接回去

163
00:06:03,120 --> 00:06:06,440
那这是呢在这里唤醒的时候的情况

164
00:06:06,480 --> 00:06:08,320
那在执行的过程当中

165
00:06:08,360 --> 00:06:09,960
还有一种情况呢是说

166
00:06:10,000 --> 00:06:11,600
我在执行到整个进程

167
00:06:11,640 --> 00:06:13,640
执行结束那我要退出

168
00:06:13,680 --> 00:06:15,160
这是要干什么呢

169
00:06:15,200 --> 00:06:17,640
要把进程执行所占用的

170
00:06:17,680 --> 00:06:19,200
所有资源还给操作系统

171
00:06:19,240 --> 00:06:20,800
以便于它能把它分配给

172
00:06:20,840 --> 00:06:22,080
新的进程使用

173
00:06:22,120 --> 00:06:23,440
如果没有这个过程的话

174
00:06:23,480 --> 00:06:26,040
那分配出的资源就会丢掉了

175
00:06:26,080 --> 00:06:27,560
那在这个过程当中呢

176
00:06:27,600 --> 00:06:30,040
结束呢有这样几种情况

177
00:06:30,080 --> 00:06:32,480
这是我们希望的正常退出

178
00:06:32,520 --> 00:06:34,560
那在正常退出之外呢

179
00:06:34,600 --> 00:06:36,360
还有一些意外的原因

180
00:06:36,400 --> 00:06:37,760
你比如说出现错误

181
00:06:37,800 --> 00:06:39,400
错误呢分成一般的错误

182
00:06:39,440 --> 00:06:40,440
我可以做收尾的

183
00:06:40,480 --> 00:06:42,200
那就是错误退出

184
00:06:42,240 --> 00:06:44,320
有一些错误是没有任何理由

185
00:06:44,360 --> 00:06:45,760
它直接就跑不动了

186
00:06:45,800 --> 00:06:47,160
那这就是致命性错误

187
00:06:47,200 --> 00:06:48,920
那这时候呢你可能这个收尾工作

188
00:06:48,960 --> 00:06:51,280
就做的不是很完善

189
00:06:51,320 --> 00:06:52,280
还有一种情况就是

190
00:06:52,320 --> 00:06:53,680
你在执行过程当中

191
00:06:53,720 --> 00:06:55,960
其他的进程认为你有问题

192
00:06:56,000 --> 00:06:58,000
那可能这种认为也不一定是正确的

193
00:06:58,040 --> 00:07:00,720
好它强制把这进程杀掉

194
00:07:00,760 --> 00:07:02,320
那这是几种我们

195
00:07:02,360 --> 00:07:06,960
从运行到退出的情况

196
00:07:07,000 --> 00:07:08,360
那有了这些说明之后呢

197
00:07:08,400 --> 00:07:12,880
我们关于进程的状态的变化情况呢

198
00:07:12,920 --> 00:07:15,000
就有一个基本的了解

199
00:07:15,040 --> 00:07:17,520
那下面呢我们通过一个小例子

200
00:07:17,560 --> 00:07:20,920
来说明进程状态的变化情况

201
00:07:20,960 --> 00:07:22,360
那在这里头呢我们假定

202
00:07:22,400 --> 00:07:23,480
我写了一个小程序

203
00:07:23,520 --> 00:07:25,080
这个小程序呢进来之后

204
00:07:25,120 --> 00:07:26,760
执行的主要操作就是

205
00:07:26,800 --> 00:07:31,360
延时两秒然后结束

206
00:07:31,400 --> 00:07:32,680
那在这个小程序呢

207
00:07:32,720 --> 00:07:33,880
它会什么样状态

208
00:07:33,920 --> 00:07:35,920
首先我启动这个小程序的时候

209
00:07:35,960 --> 00:07:37,600
它会有创建

210
00:07:37,640 --> 00:07:39,520
创建呢去分配

211
00:07:39,560 --> 00:07:41,960
这个进程执行所需要的资源

212
00:07:42,000 --> 00:07:43,280
你比如说内存

213
00:07:43,320 --> 00:07:46,160
好相关的数据结构初始化

214
00:07:46,200 --> 00:07:49,720
完成之后那这就进入就绪状态

215
00:07:49,760 --> 00:07:51,400
进入就绪状态呢是说

216
00:07:51,440 --> 00:07:53,320
我把这个进程所创建的

217
00:07:53,360 --> 00:07:54,560
包括进程控制块

218
00:07:54,600 --> 00:07:56,520
挂到就绪队列里头去

219
00:07:56,560 --> 00:07:59,520
好然后在就绪队列里头等待

220
00:07:59,560 --> 00:08:03,160
占用CPU的进程结束退出

221
00:08:03,200 --> 00:08:04,840
或者说被抢先

222
00:08:04,880 --> 00:08:06,000
好然后这时候呢

223
00:08:06,040 --> 00:08:08,560
在CPU的调度下它就可以

224
00:08:08,600 --> 00:08:12,800
从这儿进到占用CPU来开始执行

225
00:08:12,840 --> 00:08:14,680
在执行的过程当中会执行到

226
00:08:14,720 --> 00:08:16,840
你的sleep这个系统调用

227
00:08:16,880 --> 00:08:19,480
这个调用呢它设置好定时器

228
00:08:19,520 --> 00:08:20,960
那这时候呢它就没事干了

229
00:08:21,000 --> 00:08:22,200
因为我们延时两秒

230
00:08:22,240 --> 00:08:24,320
中间这两秒它是做不了任何事情的

231
00:08:24,360 --> 00:08:27,280
好在这两秒钟的时候呢

232
00:08:27,320 --> 00:08:31,520
那它就会进到等待状态

233
00:08:31,560 --> 00:08:34,720
那等待状态结束呢

234
00:08:34,760 --> 00:08:37,680
是说我这边的在内核里

235
00:08:37,720 --> 00:08:40,320
它的sleep操作会设定时器

236
00:08:40,360 --> 00:08:42,760
定时器在两秒钟到了之后呢

237
00:08:42,800 --> 00:08:45,520
它会给系统一个中断

238
00:08:45,560 --> 00:08:48,000
好这个中断呢会导致系统说

239
00:08:48,040 --> 00:08:49,320
这个中断是原因是什么

240
00:08:49,360 --> 00:08:50,480
最后找到这个进程

241
00:08:50,520 --> 00:08:52,240
好通知它

242
00:08:52,280 --> 00:08:55,080
它可以进到就绪状态

243
00:08:55,120 --> 00:08:57,800
好那这时候操作系统内核代码

244
00:08:57,840 --> 00:09:00,320
会把这个处于等待状态的进程呢

245
00:09:00,360 --> 00:09:01,920
放到就绪队列里头去

246
00:09:01,960 --> 00:09:04,760
并且把它的等待事件设置为出现

247
00:09:04,800 --> 00:09:07,680
好然后等待CPU调度

248
00:09:07,720 --> 00:09:10,720
就处于就绪状态

249
00:09:10,760 --> 00:09:14,280
好等到它可以占用CPU来运行的时候

250
00:09:14,320 --> 00:09:16,720
那又进到运行状态

251
00:09:16,760 --> 00:09:19,440
那到这儿呢我们这个基本的操作

252
00:09:19,480 --> 00:09:20,720
就执行的差不多了

253
00:09:20,760 --> 00:09:24,400
接下来是说它要退出

254
00:09:24,440 --> 00:09:27,680
然后把它所占用资源全部还回去

255
00:09:27,720 --> 00:09:30,760
那我这个进程的整个生命周期呢

256
00:09:30,800 --> 00:09:32,440
就全部完成了

257
00:09:32,480 --> 00:09:35,320
那我们所有的程序在执行过程当中呢

258
00:09:35,360 --> 00:09:37,440
我们操作系统需要对这个过程

259
00:09:37,480 --> 00:09:39,360
进行全面准确的把握

260
00:09:39,400 --> 00:09:41,080
只有这样的话我才可以知道

261
00:09:41,120 --> 00:09:44,520
我这个进程执行的情况

262
00:09:44,560 --> 00:09:45,960
那么在这个里头呢

263
00:09:46,000 --> 00:09:47,800
我们还会涉及到一个问题是说

264
00:09:47,840 --> 00:09:49,720
我一个进程进入等待

265
00:09:49,760 --> 00:09:51,880
或者说被抢先或者说结束

266
00:09:51,920 --> 00:09:54,800
我都需要找另一个进程来继续运行

267
00:09:54,840 --> 00:09:56,440
那这时候就有一个进程的切换

268
00:09:56,480 --> 00:09:59,040
那这是我们在内存当中

269
00:09:59,080 --> 00:10:02,680
当前正在交替运行的N个进程

270
00:10:02,720 --> 00:10:06,320
那这个切换的过程是怎么进行的呢

271
00:10:06,360 --> 00:10:09,280
我们在这里头进程一进程二

272
00:10:09,320 --> 00:10:10,600
我们假定有两个进程

273
00:10:10,640 --> 00:10:16,320
好首先呢假定跟我刚才例子一样

274
00:10:16,360 --> 00:10:19,800
它进到这里头执行sleep

275
00:10:19,840 --> 00:10:22,360
这时候呢会导致进入内核

276
00:10:22,400 --> 00:10:25,120
这仍然算是这个进程执行的时间

277
00:10:25,160 --> 00:10:26,080
好然后呢

278
00:10:26,120 --> 00:10:29,640
内核里头会调用函数设置定时器

279
00:10:29,680 --> 00:10:31,720
那这是这边设备

280
00:10:31,760 --> 00:10:33,040
这个设备呢可以和

281
00:10:33,080 --> 00:10:35,560
我们CPU呢同时运行

282
00:10:35,600 --> 00:10:36,800
这是并行的好

283
00:10:36,840 --> 00:10:38,880
设置好了定时器之后呢

284
00:10:38,920 --> 00:10:40,880
那我这个程序就走不下去了

285
00:10:40,920 --> 00:10:44,000
那它就会执行调度

286
00:10:44,040 --> 00:10:45,200
这个调度呢会把

287
00:10:45,240 --> 00:10:47,280
当前的进程的

288
00:10:47,320 --> 00:10:49,000
占用的寄存器的状态呢

289
00:10:49,040 --> 00:10:51,320
都保存到进程控制块里头

290
00:10:51,360 --> 00:10:55,120
然后它这时候切换到第二个进程

291
00:10:55,160 --> 00:10:56,880
这是从就绪队列里找出来的

292
00:10:56,920 --> 00:10:59,920
然后让第二个进程呢开始运行

293
00:10:59,960 --> 00:11:01,680
那在这个运行的过程当中

294
00:11:01,720 --> 00:11:04,160
它可能会是说

295
00:11:04,200 --> 00:11:07,360
你的这个定时器的时间到了

296
00:11:07,400 --> 00:11:10,280
这个时候定时器呢会产生一个中断

297
00:11:10,320 --> 00:11:12,600
这个中断呢会在这里做响应

298
00:11:12,640 --> 00:11:15,560
这个响应的操作是

299
00:11:15,600 --> 00:11:18,160
让这个进程暂停下来

300
00:11:18,200 --> 00:11:23,240
并且保护进程二的现场

301
00:11:23,280 --> 00:11:27,360
恢复进程一的现场

302
00:11:27,400 --> 00:11:31,280
恢复完毕之后让进程一继续执行

303
00:11:31,320 --> 00:11:33,760
那么等到这个进程执行结束呢

304
00:11:33,800 --> 00:11:35,240
它就再回到操作系统

305
00:11:35,280 --> 00:11:36,680
这相当于我们最后那个

306
00:11:36,720 --> 00:11:38,640
结束那个进程

307
00:11:38,680 --> 00:11:40,160
好那实际上我们在

308
00:11:40,200 --> 00:11:41,440
这个整个操作系统

309
00:11:41,480 --> 00:11:44,160
在掌控内部正在运行

310
00:11:44,200 --> 00:11:45,520
所有进程运行过程呢

311
00:11:45,560 --> 00:11:47,040
就是从一个切到另一个

312
00:11:47,080 --> 00:11:48,440
再从另一个再切回来

313
00:11:48,480 --> 00:11:51,720
周而复始的这样来切换

314
00:11:51,760 --> 00:11:54,280
那这是进程切换的情况

315
00:11:54,320 --> 00:11:54,560


316
00:11:54,600 --> 00:11:54,600


