0
00:00:00,000 --> 00:00:07,000


1
00:00:07,120 --> 00:00:11,040
接下来我们讨论内核线程

2
00:00:11,120 --> 00:00:12,680
在刚才的讨论里头呢

3
00:00:12,720 --> 00:00:14,680
用户来实现自己的线程

4
00:00:14,720 --> 00:00:16,520
机制会有好处

5
00:00:16,560 --> 00:00:17,920
但是也有它的不足

6
00:00:17,960 --> 00:00:20,120
那把这件事情挪到内核里头来呢

7
00:00:20,160 --> 00:00:21,640
它会更适合一些

8
00:00:21,680 --> 00:00:23,800
好那这就是内核线程

9
00:00:23,840 --> 00:00:26,000
内核线程是由内核通过

10
00:00:26,040 --> 00:00:29,760
系统调用方式来实现的线程机制

11
00:00:29,800 --> 00:00:31,440
那在这里头呢也就相当于我支持

12
00:00:31,480 --> 00:00:33,640
通过一组系统调用来支持线程的

13
00:00:33,680 --> 00:00:37,240
创建中止和切换

14
00:00:37,280 --> 00:00:40,280
那这是呢这个图呢是很好的

15
00:00:40,320 --> 00:00:43,360
说明了内核线程它的基本原理

16
00:00:43,400 --> 00:00:44,440
也就是说原来我们

17
00:00:44,480 --> 00:00:45,480
在用户线程里头呢

18
00:00:45,520 --> 00:00:48,080
你的线程控制块是在用户态的

19
00:00:48,120 --> 00:00:50,520
由用户应用程序自己来维护

20
00:00:50,560 --> 00:00:51,720
现在把这东西都

21
00:00:51,760 --> 00:00:53,160
挪到内核态里头来了

22
00:00:53,200 --> 00:00:54,080
内核呢

23
00:00:54,120 --> 00:00:56,360
进程控制块里头有指针指向它

24
00:00:56,400 --> 00:00:59,400
自己的相应的线程的线程控制块

25
00:00:59,440 --> 00:01:02,800
好那这样它的创建删除和切换呢

26
00:01:02,840 --> 00:01:05,160
都是在这里头来进行

27
00:01:05,200 --> 00:01:08,400
因为你进程的控制和线程的控制

28
00:01:08,440 --> 00:01:10,080
这实际上很多东西是一样的

29
00:01:10,120 --> 00:01:11,160
那好我把它搁到一起之后

30
00:01:11,200 --> 00:01:13,880
进程的切换就没有了

31
00:01:13,920 --> 00:01:16,240
而所有的切换呢都变成是线程的

32
00:01:16,280 --> 00:01:17,240
那这样的话它把

33
00:01:17,280 --> 00:01:19,160
整个这个问题就统一起来

34
00:01:19,200 --> 00:01:21,560
从而使得严格意义上来讲

35
00:01:21,600 --> 00:01:23,480
进程是资源分配的单位

36
00:01:23,520 --> 00:01:26,840
线程是处理机调度的单位

37
00:01:26,880 --> 00:01:28,120
好那这样的话

38
00:01:28,160 --> 00:01:30,480
用内核线程来实现多线程机制

39
00:01:30,520 --> 00:01:32,600
它的有一些什么样的特征呢

40
00:01:32,640 --> 00:01:35,840
第一个由内核来维护PCB和TCB

41
00:01:35,880 --> 00:01:37,360
好那这样的话

42
00:01:37,400 --> 00:01:39,000
调度的方式会更好一些

43
00:01:39,040 --> 00:01:40,200
好那这时候我们看

44
00:01:40,240 --> 00:01:41,720
它执行系统调用的时候

45
00:01:41,760 --> 00:01:46,160
那也不会堵塞其它线程的正常运行

46
00:01:46,200 --> 00:01:48,320
好那这时候呢相对来讲

47
00:01:48,360 --> 00:01:50,960
线程的创建中止和切换

48
00:01:51,000 --> 00:01:51,960
开销会大一些

49
00:01:52,000 --> 00:01:55,200
因为原来通过函数库方式来实行

50
00:01:55,240 --> 00:01:58,000
同一个进程内部的线程切换

51
00:01:58,040 --> 00:02:01,840
它的速度会快于用内核实现的

52
00:02:01,880 --> 00:02:05,600
同一个进程内的线程切换

53
00:02:05,640 --> 00:02:08,720
那当然它也会有自己的好处是说

54
00:02:08,760 --> 00:02:12,160
我调度的单位就可以变成是线程了

55
00:02:12,200 --> 00:02:14,640
好那这时候呢多线程的进程

56
00:02:14,680 --> 00:02:17,560
它可以获得更多的CPU的时间

57
00:02:17,600 --> 00:02:18,520
当然这个呢

58
00:02:18,560 --> 00:02:21,000
是由你调度算法可以来指定了

59
00:02:21,040 --> 00:02:23,200
好有了内核线程之后

60
00:02:23,240 --> 00:02:25,480
那说SOLARIS一种尝试想

61
00:02:25,520 --> 00:02:27,640
实现更好的轻权进程

62
00:02:27,680 --> 00:02:30,120
在内核支持的用户线程

63
00:02:30,160 --> 00:02:31,520
也就相当于我们刚才讲

64
00:02:31,560 --> 00:02:34,680
用户态线程它的线程机制

65
00:02:34,720 --> 00:02:37,680
它可以更好的做针对应用的调度

66
00:02:37,720 --> 00:02:38,840
好那么这样的话

67
00:02:38,880 --> 00:02:40,560
如果把内核和用户态

68
00:02:40,600 --> 00:02:41,880
这两个线程各自优点

69
00:02:41,920 --> 00:02:43,800
结合起来就是这种方式

70
00:02:43,840 --> 00:02:46,760
一个进程里头有多个轻权进程

71
00:02:46,800 --> 00:02:49,720
每一个轻权进程对应一个内核线程

72
00:02:49,760 --> 00:02:51,600
好再往上的轻权进程内部呢

73
00:02:51,640 --> 00:02:54,960
你可以对应多个用户线程

74
00:02:55,000 --> 00:02:56,920
那这个图呢很好说明了

75
00:02:56,960 --> 00:02:58,640
轻权进程的工作机制

76
00:02:58,680 --> 00:03:01,440
说这是我底下的CPU

77
00:03:01,480 --> 00:03:02,600
然后我在这儿呢

78
00:03:02,640 --> 00:03:04,640
这是我的内核线程

79
00:03:04,680 --> 00:03:06,280
我在这里头呢有这种

80
00:03:06,320 --> 00:03:10,440
这种是永久绑定的线程

81
00:03:10,480 --> 00:03:12,880
那相当于我们是在内核支持线程

82
00:03:12,920 --> 00:03:14,680
因为在用户态跟它相对应的

83
00:03:14,720 --> 00:03:16,760
就只有一个线程

84
00:03:16,800 --> 00:03:18,560
好而在这里头呢

85
00:03:18,600 --> 00:03:20,000
未绑定的轻权进程呢

86
00:03:20,040 --> 00:03:23,640
在这儿呢我有两个轻权进程

87
00:03:23,680 --> 00:03:26,160
上面绑定了三个用户态线程

88
00:03:26,200 --> 00:03:27,840
这样的话它们之间切换呢

89
00:03:27,880 --> 00:03:29,160
可以由你用户态来

90
00:03:29,200 --> 00:03:31,000
给出一些相应的策略

91
00:03:31,040 --> 00:03:32,680
来使得我这个更好

92
00:03:32,720 --> 00:03:34,920
能够提高应用的效率

93
00:03:34,960 --> 00:03:36,320
当然这种做法呢

94
00:03:36,360 --> 00:03:37,960
在最后的实际系统里的

95
00:03:38,000 --> 00:03:40,240
情况呢有些不理想

96
00:03:40,280 --> 00:03:41,840
在SOLARIS早的时候

97
00:03:41,880 --> 00:03:43,760
给出了用户线程

98
00:03:43,800 --> 00:03:45,440
后来给出了内核线程

99
00:03:45,480 --> 00:03:47,400
再把这两个结合到一起

100
00:03:47,440 --> 00:03:50,080
到最后发现说这种机制过于复杂

101
00:03:50,120 --> 00:03:51,880
它所说的优点呢

102
00:03:51,920 --> 00:03:53,560
并没有切实的体现出来

103
00:03:53,600 --> 00:03:54,920
最后变成了

104
00:03:54,960 --> 00:03:57,960
单一的内核线程的支持

105
00:03:58,000 --> 00:04:00,920
好这是我们关于线程机制的

106
00:04:00,960 --> 00:04:03,360
实现机制的讨论

107
00:04:03,400 --> 00:04:04,160
好到这个地方呢

108
00:04:04,200 --> 00:04:05,120
我们就说清楚了

109
00:04:05,160 --> 00:04:07,360
进程和线程的概念

110
00:04:07,400 --> 00:04:09,480
和它的基本实现方法

111
00:04:09,520 --> 00:04:11,080
基于我们前面对

112
00:04:11,120 --> 00:04:12,560
用户线程内核线程

113
00:04:12,600 --> 00:04:14,640
和轻权进程的讨论

114
00:04:14,680 --> 00:04:16,800
那用户线程和内核线程之间呢

115
00:04:16,840 --> 00:04:20,120
存在这样几种相互对应的关系

116
00:04:20,160 --> 00:04:22,280
第一种我们完全

117
00:04:22,320 --> 00:04:24,200
用内核线程来实现

118
00:04:24,240 --> 00:04:25,720
那对于用户态来说呢

119
00:04:25,760 --> 00:04:28,600
它看到的就是内核线程

120
00:04:28,640 --> 00:04:29,440
好那这时候呢

121
00:04:29,480 --> 00:04:30,880
我们实际上可以理解为

122
00:04:30,920 --> 00:04:32,600
用户线程和内核线程

123
00:04:32,640 --> 00:04:34,760
是一一对应的关系

124
00:04:34,800 --> 00:04:36,440
好另一种做法呢是说

125
00:04:36,480 --> 00:04:37,840
我们对内核如果说

126
00:04:37,880 --> 00:04:39,200
只是在一个进程里

127
00:04:39,240 --> 00:04:40,760
只有一个线程的话

128
00:04:40,800 --> 00:04:44,080
那就是我们传统意义上多进程系统

129
00:04:44,120 --> 00:04:45,120
那在这儿呢用户态

130
00:04:45,160 --> 00:04:48,040
你可以实现自己的用户态线程

131
00:04:48,080 --> 00:04:49,120
那这种对应关系呢

132
00:04:49,160 --> 00:04:52,200
可以理解为多对一的情况

133
00:04:52,240 --> 00:04:54,840
而对于SOLARIS的实现办法

134
00:04:54,880 --> 00:04:56,720
轻权进程我们可以理解为

135
00:04:56,760 --> 00:04:58,280
这两者之间的对应关系呢

136
00:04:58,320 --> 00:05:00,320
是可以多对多的

137
00:05:00,360 --> 00:05:01,840
并且这种对应关系呢可以

138
00:05:01,880 --> 00:05:05,320
动态在执行过程中来进行变化

139
00:05:05,360 --> 00:05:07,280
好实际上对于这几种关系呢

140
00:05:07,320 --> 00:05:09,240
对于我们在实际操作系统

141
00:05:09,280 --> 00:05:12,080
当中的使用呢都是有过出现的

142
00:05:12,120 --> 00:05:13,560
那目前呢看下来

143
00:05:13,600 --> 00:05:15,400
最后的结论性的做法呢

144
00:05:15,440 --> 00:05:18,520
是这种做法是比较好的

145
00:05:18,560 --> 00:05:19,680
好到这个地方呢

146
00:05:19,720 --> 00:05:21,240
我们就说清楚了

147
00:05:21,280 --> 00:05:24,200
用户线程内核线程轻权进程

148
00:05:24,240 --> 00:05:25,960
它是如何来实现的

149
00:05:26,000 --> 00:05:28,360
它的基本原理是什么样子

150
00:05:28,400 --> 00:05:30,040
也就是说我们在这里头呢

151
00:05:30,080 --> 00:05:32,120
在一个进程内部它的并发性

152
00:05:32,160 --> 00:05:33,440
我如何可以提高

153
00:05:33,480 --> 00:05:35,400
提高的时候这各种各样的实验办法

154
00:05:35,440 --> 00:05:38,240
它有什么样的优点和缺点

155
00:05:38,320 --> 00:05:40,120
好那到现在为止呢

156
00:05:40,200 --> 00:05:42,480
我们今天讲到的进程线程的

157
00:05:42,520 --> 00:05:44,400
概念呢就介绍完了

158
00:05:44,480 --> 00:05:46,240
好今天的课就上到这里 下课

159
00:05:46,280 --> 00:05:46,760


160
00:05:46,800 --> 00:05:46,840
    

