0
00:00:00,000 --> 00:00:07,000


1
00:00:07,080 --> 00:00:08,320
我们前面讲了这个

2
00:00:08,400 --> 00:00:10,920
页异常要干的事情

3
00:00:10,960 --> 00:00:13,480
我们再看看 我们重点考虑说

4
00:00:13,520 --> 00:00:16,000
我们要实现页替换算法了

5
00:00:16,040 --> 00:00:17,600
因为在do_pgfault里面

6
00:00:17,640 --> 00:00:19,760
还是把这个整个机制给实现完毕

7
00:00:19,800 --> 00:00:22,400
但是你要完成这个页替换算法

8
00:00:22,440 --> 00:00:24,640
那你还需要考虑一些问题

9
00:00:24,680 --> 00:00:26,120
对于我们原理课讲的时候

10
00:00:26,160 --> 00:00:27,480
比较简单一点是说

11
00:00:27,520 --> 00:00:31,520
我们根据某种策略来选择某一个页

12
00:00:31,560 --> 00:00:33,880
把它换出去 到这儿ok了

13
00:00:33,920 --> 00:00:35,440
那落到我们具体的

14
00:00:35,480 --> 00:00:36,400
操作系统里面呢

15
00:00:36,440 --> 00:00:38,200
你会去考虑以下一些问题

16
00:00:38,240 --> 00:00:40,240
第一个问题应该换出哪个页

17
00:00:40,280 --> 00:00:41,480
那么这个应该换出

18
00:00:41,520 --> 00:00:42,360
这是一个策略问题 那实际上

19
00:00:42,400 --> 00:00:44,640
是和我们页替换算法是紧密相连的

20
00:00:44,680 --> 00:00:46,920
但是在做这一步的时候

21
00:00:46,960 --> 00:00:49,240
你还需要考虑很多问题

22
00:00:49,280 --> 00:00:51,520
比如说你怎么来建立虚拟页

23
00:00:51,560 --> 00:00:53,040
和磁盘扇区的对应关系

24
00:00:53,080 --> 00:00:53,920
我前面说到了 

25
00:00:53,960 --> 00:00:55,360
知道一个页出错了

26
00:00:55,400 --> 00:00:57,640
那么怎么知道它在硬盘什么地方

27
00:00:57,680 --> 00:00:59,840
你要把这个对应关系给建立起来

28
00:00:59,880 --> 00:01:01,200
你还需要什么呢

29
00:01:01,240 --> 00:01:03,960
还需要知道何时进行换入换出

30
00:01:04,000 --> 00:01:06,120
是主动地要把一些页换出去

31
00:01:06,160 --> 00:01:07,120
还是说是被动地

32
00:01:07,160 --> 00:01:09,280
产生了内存不够之后

33
00:01:09,320 --> 00:01:12,240
才开始换入换出的这个操作

34
00:01:12,280 --> 00:01:14,800
这是换入换出操作的一个实际问题

35
00:01:14,840 --> 00:01:16,760
以及你要设计什么样的数据结构

36
00:01:16,800 --> 00:01:19,280
来支持页替换算法 

37
00:01:19,320 --> 00:01:20,440
这一点很重要的

38
00:01:20,480 --> 00:01:23,080
就是我们希望大家在做实验的时候

39
00:01:23,120 --> 00:01:24,640
就可以设计不同的页替换算法

40
00:01:24,680 --> 00:01:26,200
但是呢对我们上层OS

41
00:01:26,240 --> 00:01:28,440
其它部分的实现呢没有影响

42
00:01:28,480 --> 00:01:29,160
这里面就用到了 

43
00:01:29,200 --> 00:01:30,640
我们在lab0里面讲到的

44
00:01:30,680 --> 00:01:33,880
要设计一套函数指针的一个链表

45
00:01:33,920 --> 00:01:35,320
只要把这些函数实现完之后

46
00:01:35,360 --> 00:01:36,360
它接口没变

47
00:01:36,400 --> 00:01:37,960
虽然它的实现可以有千变万化的

48
00:01:38,000 --> 00:01:39,800
一些不同的算法实现

49
00:01:39,840 --> 00:01:40,960
但是它接口不变

50
00:01:41,000 --> 00:01:44,040
从而可以灵活地通过ucore

51
00:01:44,080 --> 00:01:45,520
来实现不同的页替换算法

52
00:01:45,560 --> 00:01:48,960
所以要设计一个比较通用的

53
00:01:49,000 --> 00:01:51,600
抽象度比较高的一个数据结构

54
00:01:51,640 --> 00:01:54,280
来支持我们不同类型的页替换算法

55
00:01:54,320 --> 00:01:55,360
这一块已经做好了

56
00:01:55,400 --> 00:01:57,000
大家可以在这基础之上

57
00:01:57,040 --> 00:01:58,400
来完成我们说的

58
00:01:58,440 --> 00:02:01,360
我们的实验需要FIFO这个页替换算法

59
00:02:01,400 --> 00:02:03,960
最后怎么来进行页面的换入换出

60
00:02:04,000 --> 00:02:05,880
其实就是说你要去完成这个读写

61
00:02:05,920 --> 00:02:09,480
对disk读写 这是说你要能够实现

62
00:02:09,520 --> 00:02:11,080
让这个页替换算法

63
00:02:11,120 --> 00:02:13,440
能够在这个ucore里面正常工作

64
00:02:13,480 --> 00:02:16,600
需要考虑的一系列问题

65
00:02:16,640 --> 00:02:18,440
我们可以逐一去解决

66
00:02:18,480 --> 00:02:19,200
第一个问题就是

67
00:02:19,240 --> 00:02:21,920
你要考虑你那个页替换的算法

68
00:02:21,960 --> 00:02:24,640
这个页替换算法它的一个框架

69
00:02:24,680 --> 00:02:26,640
实现在swap.c里面

70
00:02:26,680 --> 00:02:28,960
你看swap.c和swap.h

71
00:02:29,000 --> 00:02:30,880
那么这里面定义了一个数据结构

72
00:02:30,920 --> 00:02:32,080
一个函数指针的列表

73
00:02:32,120 --> 00:02:33,200
这里面是相当于

74
00:02:33,240 --> 00:02:35,600
把页替换框架给实现了

75
00:02:35,640 --> 00:02:38,120
那内核其它部分呢

76
00:02:38,160 --> 00:02:40,280
只需要用框架里面的函数就OK了

77
00:02:40,320 --> 00:02:42,360
那具体的页替换的算法的

78
00:02:42,400 --> 00:02:43,560
具体的实现呢

79
00:02:43,600 --> 00:02:44,840
可以放在另外一个地方

80
00:02:44,880 --> 00:02:46,200
比如说对我们这个实验来说

81
00:02:46,240 --> 00:02:46,960
可以写一个文件叫

82
00:02:47,000 --> 00:02:50,960
swap_fifo.c和swap_fifo.h

83
00:02:51,000 --> 00:02:52,720
在这里面填写你的算法

84
00:02:52,760 --> 00:02:55,120
这些算法的名字是和我们swap.c里面

85
00:02:55,160 --> 00:02:58,480
swap_manager定义的函数指针

86
00:02:58,520 --> 00:03:00,080
是一致就OK了

87
00:03:00,120 --> 00:03:03,520
这是说你要在哪实现这些问题

88
00:03:03,560 --> 00:03:04,760
然后假设实现好之后呢

89
00:03:04,800 --> 00:03:07,520
我们会有一套检测机制check_swap

90
00:03:07,560 --> 00:03:09,440
来看你这个实现是否对

91
00:03:09,480 --> 00:03:10,520
就是说你那个语义

92
00:03:10,560 --> 00:03:12,960
FIFO那个语义就是我们页替换算法

93
00:03:13,000 --> 00:03:15,560
那个语义能否正确的完成

94
00:03:15,600 --> 00:03:16,600
我们这儿有一个check

95
00:03:16,640 --> 00:03:18,480
好 另一方面呢

96
00:03:18,520 --> 00:03:21,920
我们也提到你怎么去建立虚拟页

97
00:03:21,960 --> 00:03:24,920
和磁盘扇区的对应关系

98
00:03:24,960 --> 00:03:27,080
我怎么知道一个页和一个disk

99
00:03:27,120 --> 00:03:28,320
到底什么样的关系

100
00:03:28,360 --> 00:03:32,240
这个关系怎么建立 大家想一想

101
00:03:32,280 --> 00:03:33,840
放在哪建立比较合适

102
00:03:33,880 --> 00:03:36,440
其实我们这里呢用到了什么呢

103
00:03:36,480 --> 00:03:37,600
用到了swap_entry_t

104
00:03:37,640 --> 00:03:40,840
来代表这么一个对应关系的一个建立

105
00:03:40,880 --> 00:03:44,640
比如说这里面它有一个24个bit

106
00:03:44,680 --> 00:03:50,640
这个offset来代表磁盘扇区的一个编号

107
00:03:50,680 --> 00:03:53,720
那磁盘扇区的编号可以用这个来表示

108
00:03:53,760 --> 00:03:56,400
那虚拟页的编号在哪表示呢

109
00:03:56,440 --> 00:03:59,160
其实很简单 它和我们的页表是一样的

110
00:03:59,200 --> 00:04:02,120
靠那个页表里面的index 来表示虚拟页号

111
00:04:02,160 --> 00:04:04,240
那既然用页表里面的index

112
00:04:04,280 --> 00:04:06,280
来表示虚拟页号 那也意味着我们可以

113
00:04:06,320 --> 00:04:08,760
把这个磁盘扇区这个offset

114
00:04:08,800 --> 00:04:11,040
其实可以写到页表项里面去

115
00:04:11,080 --> 00:04:12,480
那页表项其实多了一个功能

116
00:04:12,520 --> 00:04:13,960
我们以前说页表项完成了什么呢

117
00:04:14,000 --> 00:04:16,800
完成的是虚拟页和物理页帧的

118
00:04:16,840 --> 00:04:17,880
一个对应关系

119
00:04:17,920 --> 00:04:20,160
是放在我们这个页表项里面的

120
00:04:20,200 --> 00:04:23,120
那一旦说我们把这个页表项

121
00:04:23,160 --> 00:04:24,240
换了一个功能

122
00:04:24,280 --> 00:04:27,640
它是虚拟页和我们磁盘扇区的

123
00:04:27,680 --> 00:04:31,040
一个对应关系也可以放这里面

124
00:04:31,080 --> 00:04:33,360
那怎么能够保证一个页表项

125
00:04:33,400 --> 00:04:35,240
同时具有两个功能呢

126
00:04:35,280 --> 00:04:36,600
其实同时是不可能的

127
00:04:36,640 --> 00:04:39,440
只能是在不同情况下它有不同的含义

128
00:04:39,480 --> 00:04:40,600
什么情况呢

129
00:04:40,640 --> 00:04:42,920
如果它那个present位这就需要知道

130
00:04:42,960 --> 00:04:45,520
我们页表项里面有一系列的bit

131
00:04:45,560 --> 00:04:46,760
这个bit有特定的含义

132
00:04:46,800 --> 00:04:48,640
比如它有个P位叫present位

133
00:04:48,680 --> 00:04:50,120
这个位如果是0

134
00:04:50,160 --> 00:04:51,720
代表这个映射关系没有

135
00:04:51,760 --> 00:04:54,520
也意味着不存在一个虚拟页

136
00:04:54,560 --> 00:04:56,240
和一个物理页帧的对应关系

137
00:04:56,280 --> 00:04:57,880
因为它的present位是0

138
00:04:57,920 --> 00:04:59,200
既然在这种情况下

139
00:04:59,240 --> 00:05:02,040
我们不需要去用这个页表项来表示

140
00:05:02,080 --> 00:05:03,800
表示这个虚拟页

141
00:05:03,840 --> 00:05:05,520
和物理页帧的对应关系

142
00:05:05,560 --> 00:05:07,960
那我们可以用这个表项来表示什么呢

143
00:05:08,000 --> 00:05:11,000
虚拟页和我们的硬盘扇区的对应关系

144
00:05:11,040 --> 00:05:13,600
其实这是 正好是根据这个bit的

145
00:05:13,640 --> 00:05:16,800
0和1来区分它到底表示什么含义的

146
00:05:16,840 --> 00:05:18,240
那同时我们节省了空间

147
00:05:18,280 --> 00:05:22,160
这种方式就可以有效地来完成

148
00:05:22,200 --> 00:05:26,520
虚拟页和磁盘扇区对应关系的一个建立

149
00:05:26,560 --> 00:05:29,520
那我们知道swap_entry_t它的一个结构之后

150
00:05:29,560 --> 00:05:31,240
我们可以进一步了解到

151
00:05:31,280 --> 00:05:34,360
这个每一个swap_entry_t是表明了

152
00:05:34,400 --> 00:05:37,560
一个虚拟页和一个所谓的这个

153
00:05:37,600 --> 00:05:41,280
我们的磁盘的扇区的一个映射关系

154
00:05:41,320 --> 00:05:43,960
那这地方是放在哪呢 是放在PTE里面的

155
00:05:44,000 --> 00:05:46,720
那我们要用好这个宏 swap_offset之后

156
00:05:46,760 --> 00:05:48,960
就可以有效地从一个PTE里面

157
00:05:49,000 --> 00:05:51,600
PTE是什么呢 Page Table Entry

158
00:05:51,640 --> 00:05:52,720
就是页表项

159
00:05:52,760 --> 00:05:54,160
从页表项里面把对应的那个

160
00:05:54,200 --> 00:05:55,400
swap_entry_t取出来

161
00:05:55,440 --> 00:05:57,880
从而可以知道我们这个硬盘扇区

162
00:05:57,920 --> 00:05:59,680
的位置在什么地方

163
00:05:59,720 --> 00:06:01,240
它的一个索引值就知道了

164
00:06:01,280 --> 00:06:02,480
从而可以正确完成

165
00:06:02,520 --> 00:06:06,840
对这个硬盘数据的读或者写操作

166
00:06:06,880 --> 00:06:09,120
那我们其实可以进一步扩展开来

167
00:06:09,160 --> 00:06:10,760
我们页替换算法其实还有很多种

168
00:06:10,800 --> 00:06:12,360
我们讲原理课的时候除了FIFO之外

169
00:06:12,400 --> 00:06:15,680
还讲了clock算法enhanced clock算法等等

170
00:06:15,720 --> 00:06:17,680
那其实基于我们刚才讲的这个呢

171
00:06:17,720 --> 00:06:19,240
也可以在此基础上

172
00:06:19,280 --> 00:06:21,960
来实现clock和enhanced clock这个算法

173
00:06:22,000 --> 00:06:23,120
大家可以去尝试一下

174
00:06:23,160 --> 00:06:25,000
作为我们的challenge练习

175
00:06:25,040 --> 00:06:26,200
可以去尝试一下

176
00:06:26,240 --> 00:06:27,760
需要注意的是你要用这种算法呢

177
00:06:27,800 --> 00:06:30,920
你可能还需要考虑很重要的

178
00:06:30,960 --> 00:06:32,840
一些时间相关的一些因素

179
00:06:32,880 --> 00:06:34,760
怎么能够在ucore里面进行记录

180
00:06:34,800 --> 00:06:37,120
这一点需要大家去在课后

181
00:06:37,160 --> 00:06:39,680
再去仔细想一想

182
00:06:39,720 --> 00:06:42,880
好 假定我们设计好这个页替换算法

183
00:06:42,920 --> 00:06:44,000
那其实页替换算法

184
00:06:44,040 --> 00:06:45,080
大家想一想页替换算法

185
00:06:45,120 --> 00:06:47,200
只是考虑了什么 只是考虑了

186
00:06:47,240 --> 00:06:49,800
我要把哪一页换出去是吧

187
00:06:49,840 --> 00:06:52,800
那么这是页替换算法要考虑的问题

188
00:06:52,840 --> 00:06:54,600
什么时候触发这个事情呢

189
00:06:54,640 --> 00:06:57,240
我们要考虑换出 触发的事情

190
00:06:57,280 --> 00:07:00,280
那其实大家想一想 我们的ucore

191
00:07:00,320 --> 00:07:02,240
在执行什么操作的时候会出现这种

192
00:07:02,280 --> 00:07:04,120
会触发页替换算法

193
00:07:04,160 --> 00:07:06,120
去执行把某一页换出去呢

194
00:07:06,160 --> 00:07:08,240
其实就和我们前面讲到的

195
00:07:08,280 --> 00:07:09,560
动态分配内存相关

196
00:07:09,600 --> 00:07:12,720
如果要去分配一个虚拟页 这时候呢

197
00:07:12,760 --> 00:07:17,640
我们的页替换算法发现说页不够了

198
00:07:17,680 --> 00:07:19,640
那我们就需要把某一页换出去

199
00:07:19,680 --> 00:07:21,160
这时候会触发页替换算法

200
00:07:21,200 --> 00:07:21,960
所以说这是一种

201
00:07:22,000 --> 00:07:23,720
被动的页替换算法策略

202
00:07:23,760 --> 00:07:25,280
它属于产生某一个

203
00:07:25,320 --> 00:07:27,240
内存分配一个请求之后

204
00:07:27,280 --> 00:07:29,360
发现内存不够了

205
00:07:29,400 --> 00:07:31,560
我们才去被动地去完成这个

206
00:07:31,600 --> 00:07:34,120
把某一个不采用的页给换出去

207
00:07:34,160 --> 00:07:36,000
这么一个操作 这是换出

208
00:07:36,040 --> 00:07:36,880
但是页替换算法

209
00:07:36,920 --> 00:07:39,080
还没有解决的问题是换入 是吧

210
00:07:39,120 --> 00:07:42,120
那换入在哪出现呢

211
00:07:42,160 --> 00:07:44,160
换入其实应该是在我们刚才说的

212
00:07:44,200 --> 00:07:46,280
page fault的时候会出现

213
00:07:46,320 --> 00:07:48,520
就是当我访问某一个页

214
00:07:48,560 --> 00:07:49,840
这个页是合法的页

215
00:07:49,880 --> 00:07:52,160
但是它又不在内存中的时候

216
00:07:52,200 --> 00:07:55,080
这个时候就会触发换入操作

217
00:07:55,120 --> 00:07:58,200
这一块呢是跟我们换入操作相关

218
00:07:58,240 --> 00:08:01,400
那么我们的换入换出结合在一起

219
00:08:01,440 --> 00:08:05,440
才形成一个完整的虚存管理系统

220
00:08:05,480 --> 00:08:07,360
那我们知道这个页替换算法

221
00:08:07,400 --> 00:08:09,520
其实需要用到一些

222
00:08:09,560 --> 00:08:11,040
我们ucore里面的一些支持

223
00:08:11,080 --> 00:08:13,520
包含数据结构 有两个重要结构

224
00:08:13,560 --> 00:08:14,880
大家需要注意在做的时候

225
00:08:14,920 --> 00:08:17,160
第一结构是什么 page

226
00:08:17,200 --> 00:08:19,480
这个结构其实在我们lab2里面

227
00:08:19,520 --> 00:08:21,040
管理物理内存页的时候

228
00:08:21,080 --> 00:08:24,200
其实已经用到了 在这里面一开始

229
00:08:24,240 --> 00:08:25,920
就用来管理物理内存页的

230
00:08:25,960 --> 00:08:27,640
我们放在lab3里面

231
00:08:27,680 --> 00:08:28,880
其实它还有很重要的作用

232
00:08:28,920 --> 00:08:31,720
就是把这个空闲页给管理起来

233
00:08:31,760 --> 00:08:32,440
从而可以知道

234
00:08:32,480 --> 00:08:34,640
当前剩下多少空闲物理页

235
00:08:34,680 --> 00:08:36,760
是否当前空闲页已经没有了 还是有

236
00:08:36,800 --> 00:08:41,320
那么专门有一个这个page_link你需要注意

237
00:08:41,360 --> 00:08:43,920
它这里面会用来链接这个空闲页

238
00:08:43,960 --> 00:08:45,200
如果说我们需要换入的时候

239
00:08:45,240 --> 00:08:48,520
从这里面去找出来一个页去换入

240
00:08:48,560 --> 00:08:50,080
如果说空闲页没了

241
00:08:50,120 --> 00:08:53,200
那我们就要把某一个页给换出去

242
00:08:53,240 --> 00:08:55,920
那把某一个页换出去

243
00:08:55,960 --> 00:08:58,840
其实是它这个页替换算法的一个实现

244
00:08:58,880 --> 00:09:01,360
我们这里面是放在

245
00:09:01,400 --> 00:09:05,200
swap fifo里面来实现的

246
00:09:05,240 --> 00:09:06,200
这里面刚才已经提到了

247
00:09:06,240 --> 00:09:09,160
这里面为了更好的理解这里面各个函数

248
00:09:09,200 --> 00:09:11,520
到底要完成什么样的功能

249
00:09:11,560 --> 00:09:13,640
建议大家读一读这里面的注释

250
00:09:13,680 --> 00:09:15,680
以及对这个结构

251
00:09:15,720 --> 00:09:19,880
特别是说到的swap_manager这几个结构

252
00:09:19,920 --> 00:09:22,480
这个结构里每一个函数指针

253
00:09:22,520 --> 00:09:25,640
到底要干什么事情 有更清楚的理解

254
00:09:25,680 --> 00:09:27,760
我们这里面说要把某一页换出去

255
00:09:27,800 --> 00:09:29,480
最终是通过这儿来完成一个

256
00:09:29,520 --> 00:09:31,960
策略的选择 到底要换哪个页

257
00:09:32,000 --> 00:09:33,520
对于FIFO来说

258
00:09:33,560 --> 00:09:36,080
它就是最早进入那个页就要被换出去

259
00:09:36,120 --> 00:09:37,760
OK 什么是最早 就是靠我们

260
00:09:37,800 --> 00:09:39,720
刚才我们说page里面那个list

261
00:09:39,760 --> 00:09:42,600
来找到最早这个页

262
00:09:42,640 --> 00:09:45,600
最早放进去那个list里面的那个node

263
00:09:45,640 --> 00:09:47,360
那一项那就是我们要换出去的

264
00:09:47,400 --> 00:09:50,200
所以说这个呢我们这个函数的实现

265
00:09:50,240 --> 00:09:54,080
swap_out_victim这一块就是要找到那个页

266
00:09:54,120 --> 00:09:56,000
就要从哪找呢就刚才我说的page

267
00:09:56,040 --> 00:09:59,640
形成一个list里面找出来

268
00:09:59,680 --> 00:10:02,760
当大家如果完成了这个实验之后呢

269
00:10:02,800 --> 00:10:04,240
如果是一个正确的实现可以看到

270
00:10:04,280 --> 00:10:05,840
这么一个类似这样的一个输出

271
00:10:05,880 --> 00:10:08,000
我把这个输出给大家简单解释一下

272
00:10:08,040 --> 00:10:09,840
刚才说有一个vma的一个check

273
00:10:09,880 --> 00:10:10,960
这里面就是如果

274
00:10:11,000 --> 00:10:13,080
vma和mm结构设置好之后呢

275
00:10:13,120 --> 00:10:16,040
这个check是可以成功的

276
00:10:16,080 --> 00:10:17,560
如果你这个do_pgfault

277
00:10:17,600 --> 00:10:18,840
能基本完成工作的话

278
00:10:18,880 --> 00:10:23,440
那么当有一次缺页异常产生之后呢

279
00:10:23,480 --> 00:10:25,640
那我们这个do_pgfault会分配一个页

280
00:10:25,680 --> 00:10:28,760
从而可以使得do_pgfault

281
00:10:28,800 --> 00:10:29,960
这个功能能够完成

282
00:10:30,000 --> 00:10:32,360
把合法的虚拟地址和一个物理地址

283
00:10:32,400 --> 00:10:33,840
建立对应的映射关系

284
00:10:33,880 --> 00:10:37,280
从而可以让这一块check_pgfault能够成功

285
00:10:37,320 --> 00:10:39,520
然后再接下来会完成什么

286
00:10:39,560 --> 00:10:42,520
就是说的关于页替换算法这一块

287
00:10:42,560 --> 00:10:44,320
那么它会建立好一个FIFO的

288
00:10:44,360 --> 00:10:46,400
一个页替换算法

289
00:10:46,440 --> 00:10:49,000
这里面是需要大家去实现相应的一个

290
00:10:49,040 --> 00:10:52,120
我们说swap_fifo.c和swap_fifo.h里面

291
00:10:52,160 --> 00:10:53,360
完成相应的工作

292
00:10:53,400 --> 00:10:55,480
然后会建立一个环境 建立好环境之后

293
00:10:55,520 --> 00:10:57,640
它会进行一系列的测试

294
00:10:57,680 --> 00:10:59,840
这些输出是在do_pgfault里面实现的

295
00:10:59,880 --> 00:11:01,000
就是说你可以知道

296
00:11:01,040 --> 00:11:04,360
当产生一个异常之后 到底是什么原因

297
00:11:04,400 --> 00:11:05,600
这是什么原因

298
00:11:05,640 --> 00:11:08,640
在什么地址出现这种页访问异常

299
00:11:08,680 --> 00:11:10,600
那从而可以知道出了这个问题

300
00:11:10,640 --> 00:11:12,680
你要去做相应的一些什么样的操作

301
00:11:12,720 --> 00:11:16,640
如果说是你实现正确的FIFO

302
00:11:16,680 --> 00:11:18,560
这个check的话 那么你这个顺序

303
00:11:18,600 --> 00:11:21,480
我们说我们把刚才说的具体数字呢

304
00:11:21,520 --> 00:11:24,280
用一种我们说字母来表示ABCDE

305
00:11:24,320 --> 00:11:25,240
这么一个顺序

306
00:11:25,280 --> 00:11:29,880
跟我们这个做原理课里面提到的序列

307
00:11:29,920 --> 00:11:31,360
页的序列是一样的

308
00:11:31,400 --> 00:11:33,600
这个序列如果产生之后应该是

309
00:11:33,640 --> 00:11:37,720
有一个在哪一时刻产生缺页

310
00:11:37,760 --> 00:11:39,840
以及缺页的次数是确定的

311
00:11:39,880 --> 00:11:42,120
接下来是做一系列的探测

312
00:11:42,160 --> 00:11:43,640
看是否是这么一回事

313
00:11:43,680 --> 00:11:46,440
从而如果这些所有探测都过了之后

314
00:11:46,480 --> 00:11:50,080
那我们说你这个check_swap是成功的

315
00:11:50,120 --> 00:11:53,120
这就是对结果的一个简单的描述

316
00:11:53,160 --> 00:11:56,120
大家可以去仔细看一下这几个函数

317
00:11:56,160 --> 00:12:00,440
check_swap  check_pgfault  check_vmm

318
00:12:00,480 --> 00:12:03,000
这几个函数具体的测了什么东西

319
00:12:03,040 --> 00:12:04,200
从而可以指导你们

320
00:12:04,240 --> 00:12:07,000
来完成各自的实现的细节

321
00:12:07,040 --> 00:12:08,960
好 那我们把lab3这一块呢

322
00:12:09,000 --> 00:12:11,120
给大家做了一个简要的介绍

323
00:12:11,160 --> 00:12:13,720
希望大家能够结合视频

324
00:12:13,760 --> 00:12:15,520
结合我们的实验指导书

325
00:12:15,560 --> 00:12:17,720
来完成lab3的实验

326
00:12:17,760 --> 00:12:19,920
祝大家实验顺利 好 谢谢

327
00:12:19,960 --> 00:12:20,000


