0
00:00:00,000   -->   00:00:07,200
 

1
00:00:07,240   -->   00:00:10,560
下面我们来讨论负载控制

2
00:00:10,600   -->   00:00:14,040
那在我们前面掌握的局部置换算法

3
00:00:14,080   -->   00:00:16,080
和全局置换算法呢

4
00:00:16,120   -->   00:00:17,480
都涉及到一个问题

5
00:00:17,520   -->   00:00:20,800
说我这一个系统里到底有多少个

6
00:00:20,840   -->   00:00:23,120
并发执行的进程在一起执行

7
00:00:23,160   -->   00:00:25,600
对于系统来说它的效率是最高的

8
00:00:25,640   -->   00:00:27,520
那这实际上呢就是我们这里说到的

9
00:00:27,560   -->   00:00:30,320
抖动和负载控制

10
00:00:30,360   -->   00:00:32,680
那首先第一个什么是抖动

11
00:00:32,720   -->   00:00:35,800
抖动是指说我系统里头的

12
00:00:35,840   -->   00:00:37,400
进程数目太多

13
00:00:37,440   -->   00:00:40,360
那每个进程的分配到的页面呢

14
00:00:40,400   -->   00:00:42,760
就减少了 减少到一定程度

15
00:00:42,800   -->   00:00:44,680
它不能包括它的工作集

16
00:00:44,720   -->   00:00:46,680
那这时候呢它就会花大量的时间

17
00:00:46,720   -->   00:00:49,400
去进行缺页处理

18
00:00:49,440   -->   00:00:52,680
那这个缺页处理增大到一定程度

19
00:00:52,720   -->   00:00:54,960
在我这个CPU的执行时间里头呢

20
00:00:55,000   -->   00:00:56,320
就占到比较大的比例了

21
00:00:56,360   -->   00:00:57,880
好 那这时候最后的结果就是

22
00:00:57,920   -->   00:01:01,200
你的进程的运行速度变慢

23
00:01:01,240   -->   00:01:04,480
那对于这种情况呢我们怎么来处理呢

24
00:01:04,520   -->   00:01:05,560
在处理之前我们需要

25
00:01:05,600   -->   00:01:08,160
首先分析清楚它是什么原因

26
00:01:08,200   -->   00:01:09,680
那实际上在这个现象里头

27
00:01:09,720   -->   00:01:11,120
已经说的很清楚了

28
00:01:11,160   -->   00:01:14,080
就是驻留在内存里的数目太多

29
00:01:14,120   -->   00:01:19,600
那太少这个系统的并发性不好

30
00:01:19,640   -->   00:01:22,880
太多那你的效率降低

31
00:01:22,920   -->   00:01:25,240
那我们需要在这里找到一个折中点

32
00:01:25,280   -->   00:01:27,440
那这个折中点呢就是在于

33
00:01:27,480   -->   00:01:30,640
我需要去考虑我到底是多少合适

34
00:01:30,680   -->   00:01:32,280
同时还有一个问题就是

35
00:01:32,320   -->   00:01:35,520
每个进程的页面是多少合适

36
00:01:35,560   -->   00:01:37,640
那各个进程之间也有差异

37
00:01:37,680   -->   00:01:39,640
所以这件事情综合起来控制呢

38
00:01:39,680   -->   00:01:40,960
是比较复杂的

39
00:01:41,000   -->   00:01:42,600
对于我们操作系统来说呢

40
00:01:42,640   -->   00:01:45,680
我们希望达到的目标是在并发

41
00:01:45,720   -->   00:01:49,320
和缺页率之间呢达到一个平衡

42
00:01:49,360   -->   00:01:53,000
那说起来的话这个平衡比较清楚

43
00:01:53,040   -->   00:01:55,520
但实际上做起来呢 它是很难的

44
00:01:55,560   -->   00:01:58,960
那我们需要选择到底有多少个进程

45
00:01:59,000   -->   00:02:01,080
以及在每个进程

46
00:02:01,120   -->   00:02:03,640
又给它多少物理页面

47
00:02:03,680   -->   00:02:04,560
那在这儿呢

48
00:02:04,600   -->   00:02:06,000
这个问题的深入讨论

49
00:02:06,040   -->   00:02:07,680
我们时间很有限

50
00:02:07,720   -->   00:02:10,680
我们只能做一个初步的描述

51
00:02:10,720   -->   00:02:12,320
那所谓的初步描述就是

52
00:02:12,360   -->   00:02:14,560
控制这个并发进程数

53
00:02:14,600   -->   00:02:17,040
每个进程的页面多少呢

54
00:02:17,080   -->   00:02:21,920
就靠置换算法来确定

55
00:02:21,960   -->   00:02:23,360
那我们在这里呢

56
00:02:23,400   -->   00:02:28,520
首先第一个我控制每个工作集的大小

57
00:02:28,560   -->   00:02:31,040
好 我希望整个内存的总量

58
00:02:31,080   -->   00:02:33,560
是当前运行的各个进程的

59
00:02:33,600   -->   00:02:36,040
工作集的总和

60
00:02:36,080   -->   00:02:38,800
这时候呢 可以和我们前面说的

61
00:02:38,840   -->   00:02:41,400
这个并发性和CPU利用效率之间的

62
00:02:41,440   -->   00:02:43,240
这条曲线来说明

63
00:02:43,280   -->   00:02:46,120
到什么时候这两个是相等的呢

64
00:02:46,160   -->   00:02:48,560
到这个位置

65
00:02:48,600   -->   00:02:50,000
也就是说增加到一定程度

66
00:02:50,040   -->   00:02:51,720
你再增加的时候

67
00:02:51,760   -->   00:02:54,680
效率提高就会开始到达顶点了

68
00:02:54,720   -->   00:02:57,360
但是这个地方呢我们比较难考察

69
00:02:57,400   -->   00:02:58,760
那我们怎么来考察呢

70
00:02:58,800   -->   00:03:01,800
实际上我们利用第二条 我缺页之后

71
00:03:01,840   -->   00:03:05,800
有一个缺页出现的平均间隔

72
00:03:05,840   -->   00:03:09,600
然后还有一个呢是缺页处理的时间

73
00:03:09,640   -->   00:03:12,720
这两个构成一个比例

74
00:03:12,760   -->   00:03:17,480
如果说你这个间隔大于处理时间

75
00:03:17,520   -->   00:03:21,040
那这时候我的处理是来得及完成的

76
00:03:21,080   -->   00:03:23,360
就在这个点之前

77
00:03:23,400   -->   00:03:24,760
如果说我这个间隔

78
00:03:24,800   -->   00:03:26,640
小于你的处理时间

79
00:03:26,680   -->   00:03:29,040
那你基本上就满负荷的去做处理

80
00:03:29,080   -->   00:03:32,080
还忙不过来了 对于这种情况

81
00:03:32,120   -->   00:03:33,880
就已经到了这条线的底下了

82
00:03:33,920   -->   00:03:36,200
好 我们希望在这里头呢

83
00:03:36,240   -->   00:03:39,360
它是在这条线的前面

84
00:03:39,400   -->   00:03:40,480
如果做到这一点

85
00:03:40,520   -->   00:03:42,400
那这样的话我们选择这个区域

86
00:03:42,440   -->   00:03:45,080
就是负载均衡的一个平衡点

87
00:03:45,120   -->   00:03:46,920
那我们能找到的平衡点

88
00:03:46,960   -->   00:03:48,800
是在中间这段区域里头

89
00:03:48,840   -->   00:03:51,440
好 到这个地方呢我们说清楚了

90
00:03:51,480   -->   00:03:54,000
置换算法分成局部置换算法

91
00:03:54,040   -->   00:03:57,200
我们如何能够从最优的

92
00:03:57,240   -->   00:04:00,920
局部置换算法去对它做简化 做近似

93
00:04:00,960   -->   00:04:03,520
然后再讨论到全局置换算法

94
00:04:03,560   -->   00:04:06,320
全局置换算法里头也是由工作集

95
00:04:06,360   -->   00:04:08,360
到缺页率算法

96
00:04:08,400   -->   00:04:11,040
也是对它的一种近似和简化

97
00:04:11,080   -->   00:04:12,880
最终我们达到的目标是

98
00:04:12,920   -->   00:04:16,080
让整个系统处于均衡的繁忙状态

99
00:04:16,120   -->   00:04:20,040
也就是达到负载控制里头的终极目标

100
00:04:20,080   -->   00:04:22,520
好 今天的课就上到这里 下课

101
00:04:22,560   -->   00:04:25,720


102
00:04:25,760   -->   00:04:26,440


103
00:04:26,480   -->   00:04:26,760


104
00:04:26,800   -->   00:04:27,400


105
00:04:27,440   -->   00:04:27,480


