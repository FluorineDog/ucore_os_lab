0
00:00:00,000  -->  00:00:07,120
 

1
00:00:07,160  -->  00:00:08,920
我们接下来介绍

2
00:00:08,960  -->  00:00:12,960
局部置换算法它的一些特征

3
00:00:13,000  -->  00:00:14,360
那么在这里头呢

4
00:00:14,400  -->  00:00:16,920
我们前边已经介绍了

5
00:00:16,960  -->  00:00:19,200
五种局部置换算法

6
00:00:19,240  -->  00:00:21,200
这五种局部置换算法呢

7
00:00:21,240  -->  00:00:22,760
各有各的优缺点

8
00:00:22,800  -->  00:00:25,280
那么它们之间都有一些什么样的特征

9
00:00:25,320  -->  00:00:27,480
到底它们之间是一个什么样的关系呢

10
00:00:27,520  -->  00:00:30,160
我们在这用一部分时间做讨论

11
00:00:30,200  -->  00:00:30,480
  

12
00:00:30,520  -->  00:00:32,600
第一个是Belady现象

13
00:00:32,640  -->  00:00:34,560
说的是随着分配给进程的

14
00:00:34,600  -->  00:00:36,080
物理页面的增加

15
00:00:36,120  -->  00:00:38,480
它的缺页率会少吗

16
00:00:38,520  -->  00:00:39,240
  

17
00:00:39,280  -->  00:00:40,800
好 后边这个呢

18
00:00:40,840  -->  00:00:43,640
实际上是对几种算法之间它们的比较

19
00:00:43,680  -->  00:00:44,640
每一种算法呢

20
00:00:44,680  -->  00:00:47,960
它都会在一定的情况下

21
00:00:48,000  -->  00:00:51,200
和另一种算法体现出某种相似性

22
00:00:51,240  -->  00:00:52,800
  

23
00:00:52,840  -->  00:00:54,240
Belady现象

24
00:00:54,280  -->  00:00:57,320
这里说的是说我们给每一个进程

25
00:00:57,360  -->  00:01:00,560
分配一定数目的物理页面

26
00:01:00,600  -->  00:01:03,480
那如果说它缺页次数比较多

27
00:01:03,520  -->  00:01:07,200
那这时候我会需要增加给它的页面数

28
00:01:07,240  -->  00:01:08,600
那增加完了之后

29
00:01:08,640  -->  00:01:10,680
这时候我们按照通常的理解

30
00:01:10,720  -->  00:01:12,560
它的缺页应该降低

31
00:01:12,600  -->  00:01:14,600
但实际上如果你的算法不好

32
00:01:14,640  -->  00:01:16,480
比如说像我们这里的FIFO

33
00:01:16,520  -->  00:01:19,720
在某些情况下 你增加页面之后

34
00:01:19,760  -->  00:01:22,560
它的缺页次数反而会增加

35
00:01:22,600  -->  00:01:24,760
这种现象就叫Belady

36
00:01:24,800  -->  00:01:27,320
那产生这种现象的原因是什么呢

37
00:01:27,360  -->  00:01:29,080
原因是这样的

38
00:01:29,120  -->  00:01:31,680
我们置换算法 你置换的话

39
00:01:31,720  -->  00:01:33,320
是标记它的某种特征

40
00:01:33,360  -->  00:01:36,640
然后依据这种特征对它进行置换

41
00:01:36,680  -->  00:01:39,000
那我们标记的这种特征

42
00:01:39,040  -->  00:01:42,560
和进程的内存访问的这种特征

43
00:01:42,600  -->  00:01:44,160
它是不一致的

44
00:01:44,200  -->  00:01:45,520
那也就是说每个进程

45
00:01:45,560  -->  00:01:48,040
是不是会有自己的访问特征呢

46
00:01:48,080  -->  00:01:50,280
你比如说我有一个排序程序

47
00:01:50,320  -->  00:01:52,840
那它的访问特征和另外一个

48
00:01:52,880  -->  00:01:57,560
我一个word的编辑程序 那这两种呢

49
00:01:57,600  -->  00:01:58,600
它的内存访问特征

50
00:01:58,640  -->  00:02:00,320
肯定是完全不一样的

51
00:02:00,360  -->  00:02:01,920
好 正是由于这种原因

52
00:02:01,960  -->  00:02:02,200
  

53
00:02:02,240  -->  00:02:04,920
我们置换算法对它的预测呢

54
00:02:04,960  -->  00:02:07,720
和进程实际情况会不一致

55
00:02:07,760  -->  00:02:09,800
好 那这种预测不合理

56
00:02:09,840  -->  00:02:11,520
那就有可能出现这种情况

57
00:02:11,560  -->  00:02:12,400
那这时候是说

58
00:02:12,440  -->  00:02:14,920
是我所有的算法都这样吗

59
00:02:14,960  -->  00:02:18,640
这是我们需要考虑的 那我们在这呢

60
00:02:18,680  -->  00:02:21,280
还是先从FIFO说起

61
00:02:21,320  -->  00:02:24,160
我们刚才说FIFO是有Belady现象的

62
00:02:24,200  -->  00:02:26,480
我可以找到一个实例

63
00:02:26,520  -->  00:02:28,080
说你用FIFO算法

64
00:02:28,120  -->  00:02:30,160
那分配给它页数少的时候

65
00:02:30,200  -->  00:02:32,520
它会出现一个缺页次数

66
00:02:32,560  -->  00:02:33,680
分配增加之后

67
00:02:33,720  -->  00:02:35,480
缺页次数反而增加的这种情况

68
00:02:35,520  -->  00:02:37,880
那我们具体来看一下这个实例

69
00:02:37,920  -->  00:02:40,040
那在这里头呢 这个地方是个FIFO

70
00:02:40,080  -->  00:02:40,400
  

71
00:02:40,440  -->  00:02:43,080
然后这是访问的序列

72
00:02:43,120  -->  00:02:45,280
然后我们在这呢 访问缺页状态

73
00:02:45,320  -->  00:02:47,280
在这跟我们前边的约定

74
00:02:47,320  -->  00:02:48,720
稍微有点不一样

75
00:02:48,760  -->  00:02:49,960
比如说我们在这里

76
00:02:50,000  -->  00:02:52,480
第一次访问我就认为它是缺页

77
00:02:52,520  -->  00:02:53,600
为啥会这样呢

78
00:02:53,640  -->  00:02:55,000
原因在于我们在前边

79
00:02:55,040  -->  00:02:57,320
统计局部置换算法的时候

80
00:02:57,360  -->  00:03:00,080
刚开始我的那一段我是不算的

81
00:03:00,120  -->  00:03:00,640
但是在这呢

82
00:03:00,680  -->  00:03:03,240
因为我分配给它三个物理页面

83
00:03:03,280  -->  00:03:04,440
下一次我分配给它四个

84
00:03:04,480  -->  00:03:05,320
如果这段不算的话

85
00:03:05,360  -->  00:03:07,640
这两个的比较性会不一样

86
00:03:07,680  -->  00:03:10,440
好 所以我们在这起头的这几个都算

87
00:03:10,480  -->  00:03:11,240
  

88
00:03:11,280  -->  00:03:14,760
好 那这个是前三次我刚起头的时候

89
00:03:14,800  -->  00:03:16,560
那这个呢 怎么着都是一样的

90
00:03:16,600  -->  00:03:17,560
什么算法都是这样

91
00:03:17,600  -->  00:03:19,920
好 第四个 那这时候呢 加进来

92
00:03:19,960  -->  00:03:21,960
你的前三个是不在这的

93
00:03:22,000  -->  00:03:24,280
它会产生缺页 再往下一个

94
00:03:24,320  -->  00:03:27,320
这一个也不在 它还会是缺页

95
00:03:27,360  -->  00:03:29,880
然后还会是缺页

96
00:03:29,920  -->  00:03:32,080
然后到这5这也还会是缺页

97
00:03:32,120  -->  00:03:33,760
好 那到1这个地方呢

98
00:03:33,800  -->  00:03:35,120
没问题了 这个1在里头

99
00:03:35,160  -->  00:03:36,080
  

100
00:03:36,120  -->  00:03:36,920
好 那这个时候呢

101
00:03:36,960  -->  00:03:39,640
它没有命中 然后2命中

102
00:03:39,680  -->  00:03:45,160
然后3缺页 4缺页 5缺页

103
00:03:45,200  -->  00:03:47,600
那这时候呢 总共有多少次呢

104
00:03:47,640  -->  00:03:50,040
总共是在这 缺页是9次

105
00:03:50,080  -->  00:03:52,000
我只有三次命中的

106
00:03:52,040  -->  00:03:53,720
那我们在这呢 这是个示例

107
00:03:53,760  -->  00:03:56,680
好 那我们再这呢 我们再看

108
00:03:56,720  -->  00:03:57,920
我分配给它4页的时候

109
00:03:57,960  -->  00:03:59,400
还是同样一个序列

110
00:03:59,440  -->  00:04:01,720
它的缺页次数会增加吗

111
00:04:01,760  -->  00:04:02,760
  

112
00:04:02,800  -->  00:04:05,240
好 由于我们刚才说你分出的三次

113
00:04:05,280  -->  00:04:09,280
那前边这四次是肯定一样的

114
00:04:09,320  -->  00:04:11,960
  

115
00:04:12,000  -->  00:04:14,120
好 那在这里头说

116
00:04:14,160  -->  00:04:15,840
你分配4页肯定比刚才好

117
00:04:15,880  -->  00:04:17,880
那从第一个来讲 这肯定是好

118
00:04:17,920  -->  00:04:19,560
因为刚才那个1拿出去了

119
00:04:19,600  -->  00:04:20,320
你就有缺页了

120
00:04:20,360  -->  00:04:22,800
好 这1没拿出去是不是好了呢

121
00:04:22,840  -->  00:04:26,800
1没拿出去 这确实是命中了

122
00:04:26,840  -->  00:04:32,120
但是这两次都是成功的

123
00:04:32,160  -->  00:04:34,480
好 接下来的日子就不好过了

124
00:04:34,520  -->  00:04:39,400
接下来之后5缺页 你把它拿出去

125
00:04:39,440  -->  00:04:42,640
好 然后在这呢 再来1

126
00:04:42,680  -->  00:04:44,680
你又把它拿出去

127
00:04:44,720  -->  00:04:52,600
然后2 又是缺页 3 4 5

128
00:04:52,640  -->  00:04:55,240
你会发现 在这个顺序当中

129
00:04:55,280  -->  00:04:57,160
我这访问的总共就五个

130
00:04:57,200  -->  00:05:00,840
你到了4页之后 还是有缺页

131
00:05:00,880  -->  00:05:02,200
到什么情况下不会缺页呢

132
00:05:02,240  -->  00:05:04,400
你把这五个全放在这 就肯定不会了

133
00:05:04,440  -->  00:05:07,720
那现在就是说对于4页的这种情况

134
00:05:07,760  -->  00:05:10,200
那到这实际上你可以基本上可以看到

135
00:05:10,240  -->  00:05:13,320
你刚才把哪一个拿出去之后

136
00:05:13,360  -->  00:05:14,880
我就要访问哪一个

137
00:05:14,920  -->  00:05:20,120
1 2 3 4 5 正好对着的

138
00:05:20,160  -->  00:05:21,680
那你说在任何一种情况下

139
00:05:21,720  -->  00:05:23,480
是不是你给出一个序列来之后

140
00:05:23,520  -->  00:05:25,240
我就可以针对着你拿出的情况

141
00:05:25,280  -->  00:05:26,840
构造出这个序列来呢

142
00:05:26,880  -->  00:05:27,840
  

143
00:05:27,880  -->  00:05:29,840
这是我们在这里头

144
00:05:29,880  -->  00:05:30,720
那你说这么来的话

145
00:05:30,760  -->  00:05:31,680
我可以构造出来的话

146
00:05:31,720  -->  00:05:32,640
我是不是任何一个算法

147
00:05:32,680  -->  00:05:34,200
都能做到这样呢

148
00:05:34,240  -->  00:05:36,000
这是我们在这里需要讨论的

149
00:05:36,040  -->  00:05:37,360
好 从这呢 给出一个实例

150
00:05:37,400  -->  00:05:40,720
就是这个序列分3页和分4页

151
00:05:40,760  -->  00:05:43,920
它的情况是缺页增加的

152
00:05:43,960  -->  00:05:46,240
所以它是存在Belady现象的

153
00:05:46,280  -->  00:05:47,160
那如果说你在这里呢

154
00:05:47,200  -->  00:05:50,480
你证明它有 那我举出一个例子来就行了

155
00:05:50,520  -->  00:05:52,880
但是如果你想证明它没有

156
00:05:52,920  -->  00:05:54,400
你把所有的全枚举一遍吗

157
00:05:54,440  -->  00:05:56,000
这是不可能的 好 那在这呢

158
00:05:56,040  -->  00:05:59,240
我们说LRU它是没有Belady现象的

159
00:05:59,280  -->  00:06:01,000
那在这呢 也给出了一个实例

160
00:06:01,040  -->  00:06:06,680
说我这是分配三页 缺页十次

161
00:06:06,720  -->  00:06:09,400
然后我在这呢 再给它分配四页

162
00:06:09,440  -->  00:06:10,640
那数一遍之后呢

163
00:06:10,680  -->  00:06:12,760
它缺页八次 那这个没有

164
00:06:12,800  -->  00:06:14,160
那我仅靠这一个例子

165
00:06:14,200  -->  00:06:16,800
我是没有办法说明这一条的

166
00:06:16,840  -->  00:06:18,960
那有证明吗

167
00:06:19,000  -->  00:06:20,520
好 实际上在这里呢

168
00:06:20,560  -->  00:06:22,920
我们是可以有证明的

169
00:06:22,960  -->  00:06:24,840
说只要是你类似于

170
00:06:24,880  -->  00:06:27,120
我们前面那个栈的这种做法

171
00:06:27,160  -->  00:06:28,960
那从底下往上抽的话

172
00:06:29,000  -->  00:06:30,200
那这些算法呢

173
00:06:30,240  -->  00:06:33,080
它肯定都是没有Belady现象的

174
00:06:33,120  -->  00:06:35,720
这是我们说的 那再问一句

175
00:06:35,760  -->  00:06:38,160
我们的时钟和改进的时钟

176
00:06:38,200  -->  00:06:42,160
这两种折中之后有Belady现象吗

177
00:06:42,200  -->  00:06:44,360
LRU没有Belady现象

178
00:06:44,400  -->  00:06:48,440
和关于时钟和改进的时钟算法的

179
00:06:48,480  -->  00:06:49,280
Belady现象

180
00:06:49,320  -->  00:06:50,720
到底是个什么结论

181
00:06:50,760  -->  00:06:53,440
留给大家课后去思考

182
00:06:53,480  -->  00:06:55,440
这个在相关的参考书里

183
00:06:55,480  -->  00:06:57,000
可以找到它的证明

184
00:06:57,040  -->  00:06:59,320
  

185
00:06:59,360  -->  00:07:04,440
那接下来我们说LRU  FIFO和时钟

186
00:07:04,480  -->  00:07:07,640
这三种算法它们之间的比较

187
00:07:07,680  -->  00:07:09,040
那实际上我们在前边已经说过了

188
00:07:09,080  -->  00:07:10,920
这两个是两个极端

189
00:07:10,960  -->  00:07:14,760
除了那个最优算法LRU是最好的实现

190
00:07:14,800  -->  00:07:18,760
然后FIFO是我们在这里给出来比较差的

191
00:07:18,800  -->  00:07:21,520
那这时候呢 它们有什么相关性呢

192
00:07:21,560  -->  00:07:24,680
实际上任何一个置换算法

193
00:07:24,720  -->  00:07:26,320
那它在做的时候呢

194
00:07:26,360  -->  00:07:28,200
都会有一个排序

195
00:07:28,240  -->  00:07:30,560
这个排序是什么样的

196
00:07:30,600  -->  00:07:32,160
这对于你有至关重要的影响

197
00:07:32,200  -->  00:07:33,720
这两者的区别在于

198
00:07:33,760  -->  00:07:38,680
LRU是因为是以最近一次访问的时间

199
00:07:38,720  -->  00:07:41,720
前边的访问的时间来做排序

200
00:07:41,760  -->  00:07:46,320
而FIFO是以加载的时候

201
00:07:46,360  -->  00:07:49,800
装入的时间为顺序来排序

202
00:07:49,840  -->  00:07:52,760
这是它排序的 它们俩之间的区别

203
00:07:52,800  -->  00:07:54,840
那仅从这个时间点上来说呢

204
00:07:54,880  -->  00:07:55,760
好像这个事比较好弄

205
00:07:55,800  -->  00:08:00,120
第二个是它的这个在执行的过程当中

206
00:08:00,160  -->  00:08:02,000
它是否要动态的调整

207
00:08:02,040  -->  00:08:04,320
那这时候FIFO的这个顺序进来的时候

208
00:08:04,360  -->  00:08:06,320
这个因素在后边就再也不会变了

209
00:08:06,360  -->  00:08:09,920
所以它没有调整 所以它的开销就小

210
00:08:09,960  -->  00:08:13,840
而LRU每一次访问

211
00:08:13,880  -->  00:08:16,320
我都要去维护我那个栈的顺序

212
00:08:16,360  -->  00:08:19,320
所以它的开销是很大的

213
00:08:19,360  -->  00:08:20,640
那这样一来的话

214
00:08:20,680  -->  00:08:23,680
就相当于我们说这两种算法是开销大

215
00:08:23,720  -->  00:08:26,600
它的性能好 这个开销少 它有问题

216
00:08:26,640  -->  00:08:29,560
然后说这两种算法它在一定情况下

217
00:08:29,600  -->  00:08:31,600
是可以相互转换的

218
00:08:31,640  -->  00:08:34,760
LRU它可以退化成FIFO

219
00:08:34,800  -->  00:08:36,440
在什么情况下呢 是这样的

220
00:08:36,480  -->  00:08:39,920
如果说你访问的页面是第一次

221
00:08:39,960  -->  00:08:42,880
也就只访问一次 然后就不再访问了

222
00:08:42,920  -->  00:08:45,000
对于这种情况这两个算法

223
00:08:45,040  -->  00:08:46,800
你在里用LRU是没有意义的

224
00:08:46,840  -->  00:08:48,600
原因在于它只用一次

225
00:08:48,640  -->  00:08:50,000
你用第一次的时候

226
00:08:50,040  -->  00:08:52,560
没有任何的历史你可以借鉴

227
00:08:52,600  -->  00:08:54,120
所以它俩是一样的

228
00:08:54,160  -->  00:08:55,800
而这时候它的顺序

229
00:08:55,840  -->  00:08:57,960
也是跟你加载的顺序是一样的

230
00:08:58,000  -->  00:09:00,480
所以这两个排序是一样的

231
00:09:00,520  -->  00:09:04,440
好 在这 这是一个实际的例子

232
00:09:04,480  -->  00:09:06,200
那你说这个例子是你构造出来的

233
00:09:06,240  -->  00:09:07,000
有几个页面

234
00:09:07,040  -->  00:09:08,920
我就顺序的访问比它多一个

235
00:09:08,960  -->  00:09:10,600
这样的话对于FIFO

236
00:09:10,640  -->  00:09:12,480
你就肯定是不行的了

237
00:09:12,520  -->  00:09:14,560
那在我们实际用到的程序里

238
00:09:14,600  -->  00:09:16,320
有啥样的是这种情况的

239
00:09:16,360  -->  00:09:17,880
这种情况也是存在的

240
00:09:17,920  -->  00:09:21,120
比如说我们在看视频

241
00:09:21,160  -->  00:09:23,920
视频信息的输出的时候

242
00:09:23,960  -->  00:09:27,680
你在读入相关的信息 那这个信息呢

243
00:09:27,720  -->  00:09:29,120
通常情况下我们播视频的时候

244
00:09:29,160  -->  00:09:31,000
它是从头到尾播一遍

245
00:09:31,040  -->  00:09:34,040
你很少有翻来覆去在那听的这种情况

246
00:09:34,080  -->  00:09:34,880
  

247
00:09:34,920  -->  00:09:36,640
好 正是由于这种原因

248
00:09:36,680  -->  00:09:39,040
所以我们这种只放一遍的

249
00:09:39,080  -->  00:09:40,640
这种情况也是有的

250
00:09:40,680  -->  00:09:41,960
如果说在你的系统当中

251
00:09:42,000  -->  00:09:43,280
这种情况很常见

252
00:09:43,320  -->  00:09:45,800
你就有必要针对这个

253
00:09:45,840  -->  00:09:48,120
别把这个缓存的事做的很复杂

254
00:09:48,160  -->  00:09:49,760
  

255
00:09:49,800  -->  00:09:54,240
这是LRU和FIFO之间的一些关系

256
00:09:54,280  -->  00:09:57,800
那这时候说LRU的性能好

257
00:09:57,840  -->  00:10:00,160
但是开销大 FIFO的开销小

258
00:10:00,200  -->  00:10:03,720
但是会有Belady 然后说Clock 

259
00:10:03,760  -->  00:10:06,480
时钟算法实际上是它们俩之间的折中

260
00:10:06,520  -->  00:10:09,560
怎么做折中呢 我们看一下

261
00:10:09,600  -->  00:10:11,960
在这里访问页面的时候

262
00:10:12,000  -->  00:10:14,760
我们前面说一个需要调整顺序

263
00:10:14,800  -->  00:10:16,520
一个不调整顺序

264
00:10:16,560  -->  00:10:18,160
那调整顺序的开销大

265
00:10:18,200  -->  00:10:19,880
那不调整顺序这个呢

266
00:10:19,920  -->  00:10:21,200
我就啥事也没做

267
00:10:21,240  -->  00:10:22,840
那这个做法呢不好

268
00:10:22,880  -->  00:10:24,000
我们在这里取一个折中

269
00:10:24,040  -->  00:10:27,200
就是访问的时候 我会做标记

270
00:10:27,240  -->  00:10:28,760
比如说哪些页面访问过

271
00:10:28,800  -->  00:10:32,680
那这是比FIFO做的复杂的事

272
00:10:32,720  -->  00:10:35,360
那由于这件事情有硬件参与

273
00:10:35,400  -->  00:10:36,760
改页表里的页表项

274
00:10:36,800  -->  00:10:39,360
这件事情相对来说比较方便

275
00:10:39,400  -->  00:10:41,840
好 然后我不去调整它的顺序

276
00:10:41,880  -->  00:10:42,560
那这样的话

277
00:10:42,600  -->  00:10:45,560
我调整顺序的开销就没了

278
00:10:45,600  -->  00:10:47,600
然后说在这里头呢

279
00:10:47,640  -->  00:10:50,120
那我要想得到LRU的一些特征

280
00:10:50,160  -->  00:10:53,440
我怎么办呢 我缺页的时候

281
00:10:53,480  -->  00:10:57,720
那缺页的时候我们的时钟算法会去扫描

282
00:10:57,760  -->  00:10:59,680
实际上这个扫描你可以理解为

283
00:10:59,720  -->  00:11:02,200
它这里对这个顺序做了一定的调整

284
00:11:02,240  -->  00:11:03,040
实际上它怎么调整呢

285
00:11:03,080  -->  00:11:04,800
就是你扫描的过程当中

286
00:11:04,840  -->  00:11:07,040
有一些点它是直接蹦过的

287
00:11:07,080  -->  00:11:08,560
访问过的它是直接蹦过去了

288
00:11:08,600  -->  00:11:11,120
好 这种直接蹦过你可以理解为

289
00:11:11,160  -->  00:11:14,880
是把它的顺序是做了某种形式的调整

290
00:11:14,920  -->  00:11:16,480
好 那这样一来的话

291
00:11:16,520  -->  00:11:20,640
说时钟算法它和LRU是什么样的呢

292
00:11:20,680  -->  00:11:22,960
对于刚才说的没有访问过的页面

293
00:11:23,000  -->  00:11:26,800
这Clock算法 你LRU也已经退化成FIFO了

294
00:11:26,840  -->  00:11:29,760
你Clock也和它是一样的所以你可以说

295
00:11:29,800  -->  00:11:32,680
Clock和LRU是性能一样的好

296
00:11:32,720  -->  00:11:34,400
实际上它和FIFO

297
00:11:34,440  -->  00:11:36,160
它们三个是一样的

298
00:11:36,200  -->  00:11:38,760
因为我没有任何可以借用的信息了

299
00:11:38,800  -->  00:11:39,960
好 那在什么情况下

300
00:11:40,000  -->  00:11:44,000
它比FIFO做的好呢

301
00:11:44,040  -->  00:11:46,800
对于被访问过的页面

302
00:11:46,840  -->  00:11:49,680
Clock就比LRU要做的差

303
00:11:49,720  -->  00:11:51,240
但是比FIFO做的好

304
00:11:51,280  -->  00:11:54,800
因为在这里Clock它只记录了

305
00:11:54,840  -->  00:11:57,480
我是否访问过 访问过的我留下

306
00:11:57,520  -->  00:12:00,560
而对于LRU不但是访问过的

307
00:12:00,600  -->  00:12:01,480
我要做记录

308
00:12:01,520  -->  00:12:04,440
并且访问的顺序我还要做记录

309
00:12:04,480  -->  00:12:05,360
所以这样的话

310
00:12:05,400  -->  00:12:10,240
它的记录的信息比Clock要多

311
00:12:10,280  -->  00:12:12,960
这是我们对这三种算法

312
00:12:13,000  -->  00:12:15,080
它们之间的一个比较

313
00:12:15,120  -->  00:12:16,560
到这个地方为止

314
00:12:16,600  -->  00:12:19,800
我们就把局部置换算法呢

315
00:12:19,840  -->  00:12:22,880
全部讲完了 在这里头说

316
00:12:22,920  -->  00:12:24,960
这些主要的区别是在于

317
00:12:25,000  -->  00:12:27,680
我在这个固定页面的情况下

318
00:12:27,720  -->  00:12:30,520
我怎么来调整我要置换的

319
00:12:30,560  -->  00:12:33,320
这个页面到底是谁 我对它做排序

320
00:12:33,360  -->  00:12:34,880
我以什么样的指标来排序

321
00:12:34,920  -->  00:12:36,240
这种排序的情况下

322
00:12:36,280  -->  00:12:37,680
它们的开销是什么样的

323
00:12:37,720  -->  00:12:40,120
好 在开销我不可以接受的情况下

324
00:12:40,160  -->  00:12:43,160
我如何对它去做折中和简化

325
00:12:43,200  -->  00:12:47,400


326
00:12:47,440  -->  00:12:49,200


327
00:12:49,240  -->  00:12:50,040


328
00:12:50,080  -->  00:12:50,120


