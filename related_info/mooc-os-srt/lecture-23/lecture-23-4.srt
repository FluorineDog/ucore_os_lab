0
00:00:00,000 --> 00:00:07,160


1
00:00:07,200 --> 00:00:11,200
下面我们来讨论磁盘调度

2
00:00:11,240 --> 00:00:13,760
前面我们说了I/O的特点

3
00:00:13,800 --> 00:00:17,240
I/O的结构和I/O的数据传输

4
00:00:17,280 --> 00:00:18,680
下面我们举一类

5
00:00:18,720 --> 00:00:21,640
具体的设备的优化问题

6
00:00:21,680 --> 00:00:24,280
这就是我们这里的磁盘调度

7
00:00:24,320 --> 00:00:26,560
在具体讨论磁盘调度之前

8
00:00:26,600 --> 00:00:27,960
我们有必要讨论一下

9
00:00:28,000 --> 00:00:32,360
磁盘的工作机理和它的性能参数

10
00:00:32,400 --> 00:00:36,600
这是一个磁盘的基本结构

11
00:00:36,640 --> 00:00:42,160
它由若干个盘片和一个磁头组组成

12
00:00:42,200 --> 00:00:43,400
磁头组上呢

13
00:00:43,440 --> 00:00:45,720
每一个磁头上有一个读写头

14
00:00:45,760 --> 00:00:48,160
分别对应着盘片的正反面

15
00:00:48,200 --> 00:00:50,920
我们可以在这里读写相应的数据

16
00:00:50,960 --> 00:00:52,360
中间这些盘片

17
00:00:52,400 --> 00:00:56,360
是围绕着磁盘轴进行旋转的

18
00:00:56,400 --> 00:00:58,160
在这个旋转的过程当中

19
00:00:58,200 --> 00:00:59,720
我们要读写的数据

20
00:00:59,760 --> 00:01:02,200
是分布在各个盘片上的

21
00:01:02,240 --> 00:01:05,920
这里磁道 柱面和扇区

22
00:01:05,960 --> 00:01:07,640
这是我们要找的

23
00:01:07,680 --> 00:01:11,680
每一块数据所在的位置

24
00:01:11,720 --> 00:01:13,600
你在这里要读写磁盘上的数据

25
00:01:13,640 --> 00:01:15,200
首先必须移动磁头

26
00:01:15,240 --> 00:01:17,880
到达指定的位置然后读写

27
00:01:17,920 --> 00:01:20,400
那我们看到在这里花时间最长的

28
00:01:20,440 --> 00:01:22,440
是这个磁头的移动

29
00:01:22,480 --> 00:01:25,240
这就是我们这里的寻道时间

30
00:01:25,280 --> 00:01:28,760
定位到指定的磁道所需要花的时间

31
00:01:28,800 --> 00:01:32,680
然后再有一个是旋转延时

32
00:01:32,720 --> 00:01:33,880
也就是说中间这个盘片

33
00:01:33,920 --> 00:01:36,720
它是一直在匀速旋转的

34
00:01:36,760 --> 00:01:38,360
这个旋转不会因为

35
00:01:38,400 --> 00:01:41,280
我想读的位置不同而有所改变

36
00:01:41,320 --> 00:01:44,880
所以我们在这里要想找到指定的扇区

37
00:01:44,920 --> 00:01:46,760
必须是等待它旋转

38
00:01:46,800 --> 00:01:48,440
那这样一来我们基本上是说

39
00:01:48,480 --> 00:01:50,480
在这里从当前位置

40
00:01:50,520 --> 00:01:52,520
旋转到你想要的那个位置

41
00:01:52,560 --> 00:01:57,760
这中间时间是我们这里的旋转延时

42
00:01:57,800 --> 00:01:59,080
有了这个之后

43
00:01:59,120 --> 00:02:01,120
那我们基本可以说

44
00:02:01,160 --> 00:02:04,040
这个旋转延时基本上是转半圈的情况

45
00:02:04,080 --> 00:02:06,040
也就是说我在任何一个位置开始

46
00:02:06,080 --> 00:02:08,040
读到我想要的那个位置

47
00:02:08,080 --> 00:02:10,560
那通常情况下中间平均的延时

48
00:02:10,600 --> 00:02:13,520
是要转半圈的时间

49
00:02:13,560 --> 00:02:15,320
这是磁盘的结构

50
00:02:15,360 --> 00:02:17,600
和它相应的几个影响参数

51
00:02:17,640 --> 00:02:19,560
下面我们来具体分析一下

52
00:02:19,600 --> 00:02:24,200
磁盘I/O它的时间都花在什么地方

53
00:02:24,240 --> 00:02:27,240
首先第一个是我要读写某个设备

54
00:02:27,280 --> 00:02:29,520
我要等的这个设备是可以访问的

55
00:02:29,560 --> 00:02:32,480
等待设备可用这是一段时间

56
00:02:32,520 --> 00:02:33,920
然后第二个是等待

57
00:02:33,960 --> 00:02:36,720
我这个设备要想跟它进行交流的话

58
00:02:36,760 --> 00:02:39,800
DMA通道或者是I/O通道它必须可用

59
00:02:39,840 --> 00:02:40,920
这是一个时间

60
00:02:40,960 --> 00:02:42,840
这两个时间基本上

61
00:02:42,880 --> 00:02:46,080
跟你实际的设备操作关系不大

62
00:02:46,120 --> 00:02:47,520
然后是寻道时间

63
00:02:47,560 --> 00:02:50,840
这相当于磁头移到指定的磁道

64
00:02:50,880 --> 00:02:53,200
然后是旋转延时

65
00:02:53,240 --> 00:02:55,000
最后我到了指定地方之后

66
00:02:55,040 --> 00:02:56,640
我还有一个数据读出的时间

67
00:02:56,680 --> 00:02:58,640
后面这三个时间

68
00:02:58,680 --> 00:03:00,280
都会有机械动作

69
00:03:00,320 --> 00:03:01,640
所以我们在这里

70
00:03:01,680 --> 00:03:04,160
计算这个传输时间的时候

71
00:03:04,200 --> 00:03:08,360
基本上是把这三个时间加在一起

72
00:03:08,400 --> 00:03:09,120
这三个时间

73
00:03:09,160 --> 00:03:12,400
加上前面这个通道的等待时间

74
00:03:12,440 --> 00:03:14,320
这是我设备忙的状态

75
00:03:14,360 --> 00:03:20,120
这是我们给出来的传输时间的公式

76
00:03:20,160 --> 00:03:22,680
这是我最后算出来的访问时间

77
00:03:22,720 --> 00:03:25,160
它由三个部分组成

78
00:03:25,200 --> 00:03:27,280
实际上这是我们已经简化过的

79
00:03:27,320 --> 00:03:30,920
一个是寻道时间就是中间这一段

80
00:03:30,960 --> 00:03:33,360
然后是旋转延时

81
00:03:33,400 --> 00:03:34,440
第一个寻道时间

82
00:03:34,480 --> 00:03:36,960
跟你磁头移动的距离是相关的

83
00:03:37,000 --> 00:03:38,600
那它花的时间是最大的

84
00:03:38,640 --> 00:03:40,000
第二个旋转延时

85
00:03:40,040 --> 00:03:44,080
基本上是说我们转的速度它的倒数

86
00:03:44,120 --> 00:03:45,960
就是你转一圈的时间

87
00:03:46,000 --> 00:03:46,680
那我们在这儿

88
00:03:46,720 --> 00:03:49,480
基本上是平均时间是转一圈的一半

89
00:03:49,520 --> 00:03:51,240
就是2r分之一

90
00:03:51,280 --> 00:03:54,280
然后再有一个数据读取的时间

91
00:03:54,320 --> 00:03:57,360
这是传输时间 这里头这个时间

92
00:03:57,400 --> 00:03:58,760
它这几个参数是什么意思呢

93
00:03:58,800 --> 00:04:00,280
就是要读多少个字节

94
00:04:00,320 --> 00:04:04,200
你这一圈磁道上有多少个比特

95
00:04:04,240 --> 00:04:06,360
然后你的转速是啥样的

96
00:04:06,400 --> 00:04:08,720
这三个数rN分之B

97
00:04:08,760 --> 00:04:12,200
就是你这里头传输的延时

98
00:04:12,240 --> 00:04:14,120
从这个分析我们可以知道

99
00:04:14,160 --> 00:04:16,720
我们主要需要优化的是TS

100
00:04:16,760 --> 00:04:18,800
这个寻道时间

101
00:04:18,840 --> 00:04:20,560
为了寻道时间的优化

102
00:04:20,600 --> 00:04:23,480
这就是我们这里磁盘调度所要干的事

103
00:04:23,520 --> 00:04:27,560
那它通过优化磁盘访问的顺序

104
00:04:27,600 --> 00:04:30,840
来达到提高磁盘访问性能的目标

105
00:04:30,880 --> 00:04:33,720
访问顺序如何来影响这个寻道时间呢

106
00:04:33,760 --> 00:04:35,160
实际上我们有这样几条依据

107
00:04:35,200 --> 00:04:38,280
第一个寻道是磁盘上最耗费的时间

108
00:04:38,320 --> 00:04:40,000
所以我们有必要对它进行优化

109
00:04:40,040 --> 00:04:42,440
如果这时间很短 那优化的空间不大

110
00:04:42,480 --> 00:04:43,880
那我们就没有必要在这里

111
00:04:43,920 --> 00:04:46,560
来做这个优化

112
00:04:46,600 --> 00:04:50,240
然后再有一个我必须在同一个磁盘上

113
00:04:50,280 --> 00:04:53,080
同时会有多个I/O请求

114
00:04:53,120 --> 00:04:55,000
如果一个磁盘上只有一个

115
00:04:55,040 --> 00:04:56,280
那你不管怎么优化

116
00:04:56,320 --> 00:04:58,200
你都要到指定位置的

117
00:04:58,240 --> 00:05:00,600
同时有多个我可以调整这个顺序

118
00:05:00,640 --> 00:05:04,720
就好比说图书馆的管理员要去书库取书

119
00:05:04,760 --> 00:05:06,560
它同时有多本书要取的时候

120
00:05:06,600 --> 00:05:08,680
它可以看看这几本分布的位置

121
00:05:08,720 --> 00:05:10,080
我优化出一条线路来

122
00:05:10,120 --> 00:05:11,440
如果说你只有一本的话

123
00:05:11,480 --> 00:05:13,800
那相当于我就直接去 直接回

124
00:05:13,840 --> 00:05:16,320
没有什么好优化的

125
00:05:16,360 --> 00:05:21,520
再有一个是随机进行磁盘的I/O请求

126
00:05:21,560 --> 00:05:23,560
那这时候它的性能是很差的

127
00:05:23,600 --> 00:05:24,400
基于这样几条

128
00:05:24,440 --> 00:05:26,800
我们可以通过优化这个顺序

129
00:05:26,840 --> 00:05:29,960
来优化磁盘的访问性能

130
00:05:30,000 --> 00:05:31,600
具体说起来呢

131
00:05:31,640 --> 00:05:33,880
我们在这里给出这样几种优化算法

132
00:05:33,920 --> 00:05:36,680
第一种是FIFO先进先出

133
00:05:36,720 --> 00:05:39,480
它就是按照请求的顺序

134
00:05:39,520 --> 00:05:41,720
来顺序的进行处理

135
00:05:41,760 --> 00:05:43,840
这个算法它是公平的

136
00:05:43,880 --> 00:05:46,440
但是它在很多情况下

137
00:05:46,480 --> 00:05:47,760
它的性能是不好的

138
00:05:47,800 --> 00:05:50,280
接近于你的随机访问

139
00:05:50,320 --> 00:05:51,160


140
00:05:51,200 --> 00:05:53,360
那我们用一个例子来说

141
00:05:53,400 --> 00:05:54,800
它是在怎么访问

142
00:05:54,840 --> 00:05:57,680
在这个例子给了一个访问的序列

143
00:05:57,720 --> 00:06:00,560
并且约定了我磁头当前的位置

144
00:06:00,600 --> 00:06:02,720
来按照FIFO的做法

145
00:06:02,760 --> 00:06:05,840
看看它总共磁头移动的距离是多少

146
00:06:05,880 --> 00:06:07,560
我们要优化的目标

147
00:06:07,600 --> 00:06:09,240
就是这个移动的距离

148
00:06:09,280 --> 00:06:11,240
当前位置是53

149
00:06:11,280 --> 00:06:12,960
我第一个是98

150
00:06:13,000 --> 00:06:15,240
第一个要移动53到98

151
00:06:15,280 --> 00:06:17,720
这时候移动了45个单位的距离

152
00:06:17,760 --> 00:06:21,280
这样的话一个一个移动下去

153
00:06:21,320 --> 00:06:23,000


154
00:06:23,040 --> 00:06:24,560
到最后

155
00:06:24,600 --> 00:06:27,760


156
00:06:27,800 --> 00:06:31,680
到这个地方我到67

157
00:06:31,720 --> 00:06:33,560
我总共加在一起

158
00:06:33,600 --> 00:06:36,720
它总和是640个单位

159
00:06:36,760 --> 00:06:39,240
那我们看到这来回左移右移

160
00:06:39,280 --> 00:06:40,920
实际上走了很多的冤枉路

161
00:06:40,960 --> 00:06:43,920
这种做法呢它的性能是很差的

162
00:06:43,960 --> 00:06:46,280
我们首先想到的第一个优化是什么

163
00:06:46,320 --> 00:06:47,480
我就近

164
00:06:47,520 --> 00:06:48,720
离的这后面这一段里

165
00:06:48,760 --> 00:06:50,440
哪一个最近我按哪一个

166
00:06:50,480 --> 00:06:52,880
这就是我们下一种做法

167
00:06:52,920 --> 00:06:55,880
最短服务时间优先

168
00:06:55,920 --> 00:06:56,800
在这里头呢

169
00:06:56,840 --> 00:06:59,240
它依据磁头当前的位置

170
00:06:59,280 --> 00:07:01,920
来找移动最少的那个I/O请求

171
00:07:01,960 --> 00:07:04,000
所在的位置

172
00:07:04,040 --> 00:07:07,040
这时候总是找最短寻道时间的

173
00:07:07,080 --> 00:07:09,440
当前寻道最短的那个

174
00:07:09,480 --> 00:07:11,920
那我们还是以刚才这个例子来说

175
00:07:11,960 --> 00:07:13,680
在这个序列里头

176
00:07:13,720 --> 00:07:15,120
我们仍然是这个序列

177
00:07:15,160 --> 00:07:16,560
仍然是这个当前位置

178
00:07:16,600 --> 00:07:19,480
我们看按最短寻道时间优先

179
00:07:19,520 --> 00:07:21,960
它的结果是啥样的

180
00:07:22,000 --> 00:07:23,240
我们在这儿53

181
00:07:23,280 --> 00:07:27,560
离它最近的是哪个 是65

182
00:07:27,600 --> 00:07:30,040
然后67 最后两个

183
00:07:30,080 --> 00:07:33,640
然后67之后再往哪

184
00:07:33,680 --> 00:07:36,080
37是离它最近的

185
00:07:36,120 --> 00:07:40,520
然后这样一直走下去到最后

186
00:07:40,560 --> 00:07:44,520
最后到哪 到这个地方 183

187
00:07:44,560 --> 00:07:46,160
是它最后一个

188
00:07:46,200 --> 00:07:50,520
这时候236和我们刚才的640

189
00:07:50,560 --> 00:07:53,960
差不多差了接近3倍

190
00:07:54,000 --> 00:07:57,400
那这时候我们看到这种做法

191
00:07:57,440 --> 00:08:00,520
比刚才那个又有了很大的优化

192
00:08:00,560 --> 00:08:02,400
原因在于刚才那个根本就没有考虑到

193
00:08:02,440 --> 00:08:04,480
它的位置分布情况

194
00:08:04,520 --> 00:08:07,160
这个做法是不是还可以优化呢

195
00:08:07,200 --> 00:08:11,720
那我们再有第三种做法 扫描算法

196
00:08:11,760 --> 00:08:15,360
它的做法是在一个方向上进行移动

197
00:08:15,400 --> 00:08:18,800
一直到所有的访问全部完成

198
00:08:18,840 --> 00:08:24,000
然后直到到达磁头的最后一个磁道

199
00:08:24,040 --> 00:08:25,160
这种做法呢

200
00:08:25,200 --> 00:08:28,040
它主要是因为我们在磁盘上

201
00:08:28,080 --> 00:08:30,520
磁头是两个方向来回移动

202
00:08:30,560 --> 00:08:33,520
哪些地方会是优待呢

203
00:08:33,560 --> 00:08:35,040
中间那一部分会是优待

204
00:08:35,080 --> 00:08:36,720
所以我沿一个方向走到头

205
00:08:36,760 --> 00:08:39,160
然后再到另一个方向

206
00:08:39,200 --> 00:08:40,800
这样一来的话

207
00:08:40,840 --> 00:08:43,560
我换方向之后 再从那头扫回来

208
00:08:43,600 --> 00:08:45,640
这种做法有点类似于

209
00:08:45,680 --> 00:08:48,160
我们电梯里的控制算法 

210
00:08:48,200 --> 00:08:48,840
电梯的话

211
00:08:48,880 --> 00:08:51,280
它是从最顶上到最底下

212
00:08:51,320 --> 00:08:53,680
然后再从最底下到最顶上

213
00:08:53,720 --> 00:08:56,200
这是我们这里的扫描算法

214
00:08:56,240 --> 00:08:58,800
我们用扫描算法再来试一下

215
00:08:58,840 --> 00:09:00,120
刚才那个序列

216
00:09:00,160 --> 00:09:02,880
同样的序列 同样的起点

217
00:09:02,920 --> 00:09:06,200
但这时候起头有一个方向的假定

218
00:09:06,240 --> 00:09:07,000
我们在这儿

219
00:09:07,040 --> 00:09:09,600
假定是往编号低的方向走

220
00:09:09,640 --> 00:09:12,200
这时候我沿路扫到头

221
00:09:12,240 --> 00:09:14,400
一直有多少个我就扫到那儿

222
00:09:14,440 --> 00:09:17,000
这样一来的话基本上我转一圈

223
00:09:17,040 --> 00:09:19,000
是从第一个到最后一个

224
00:09:19,040 --> 00:09:20,920
200个单位这样的距离

225
00:09:20,960 --> 00:09:24,000


226
00:09:24,040 --> 00:09:25,520
也就是说极端的情况

227
00:09:25,560 --> 00:09:28,880
如果说你是从最头上开始

228
00:09:28,920 --> 00:09:30,280
不管你中间有多少个请求

229
00:09:30,320 --> 00:09:32,960
它移动的距离就应该是不超过200

230
00:09:33,000 --> 00:09:35,400
从这个角度来说这个算法呢

231
00:09:35,440 --> 00:09:36,920
它的性能也是不错的

232
00:09:36,960 --> 00:09:37,920
在我们这儿看到

233
00:09:37,960 --> 00:09:39,840
它算出来和我们刚才那个

234
00:09:39,880 --> 00:09:42,080
最短寻道时间优先的算法

235
00:09:42,120 --> 00:09:44,800
的结果是一样的

236
00:09:44,840 --> 00:09:46,880
这种做法它的特点是

237
00:09:46,920 --> 00:09:50,360
我沿着一个方向走 顺序扫过去

238
00:09:50,400 --> 00:09:52,000
这个地方我的判断会比较简单

239
00:09:52,040 --> 00:09:52,880
不像刚才那个

240
00:09:52,920 --> 00:09:55,400
我需要去找到底哪一个是最近的

241
00:09:55,440 --> 00:09:56,360
每一次找的时候呢

242
00:09:56,400 --> 00:09:58,920
都要来挨个去算一遍

243
00:09:58,960 --> 00:10:02,280
我在这儿沿着一个方向就可以了

244
00:10:02,320 --> 00:10:04,720
与此同时这种做法有一个问题

245
00:10:04,760 --> 00:10:08,320
就是在于中间这些磁道

246
00:10:08,360 --> 00:10:11,880
我会有更好的访问性能

247
00:10:11,920 --> 00:10:14,400
而两头我到的时间会比较少

248
00:10:14,440 --> 00:10:16,880
所以在这儿又有一种变化

249
00:10:16,920 --> 00:10:19,280
叫做循环扫描

250
00:10:19,320 --> 00:10:21,960
它仅在一个方向进行扫描

251
00:10:22,000 --> 00:10:25,200
另一个方向呢是直接走到头

252
00:10:25,240 --> 00:10:26,520
这种做法呢

253
00:10:26,560 --> 00:10:31,640
它主要的目的是为了提高它的公平性

254
00:10:31,680 --> 00:10:33,840
那我们看

255
00:10:33,880 --> 00:10:37,040
刚才说你把从一个方向走到头

256
00:10:37,080 --> 00:10:38,160
最外头那个地方

257
00:10:38,200 --> 00:10:41,080
即使没有你要访问的I/O请求

258
00:10:41,120 --> 00:10:41,960
你也要走到头

259
00:10:42,000 --> 00:10:43,720
这个实际上是不合算的

260
00:10:43,760 --> 00:10:46,400
所以在这儿就有一个C-Look

261
00:10:46,440 --> 00:10:48,960
它和我们刚才说的扫描算法

262
00:10:49,000 --> 00:10:50,720
唯一的区别就在于

263
00:10:50,760 --> 00:10:54,560
它只是走到最后一个请求的位置

264
00:10:54,600 --> 00:10:57,960
它不走到头 然后就折返了

265
00:10:58,000 --> 00:11:00,840
其它的跟循环扫描算法是一样的

266
00:11:00,880 --> 00:11:05,040
这样的话它就可以提高它的公平性

267
00:11:05,080 --> 00:11:08,840
然后在这基础上我们还会再有两种优化

268
00:11:08,880 --> 00:11:13,200
这就是N步扫描和双队列扫描算法

269
00:11:13,240 --> 00:11:14,480
N步扫描算法实际上

270
00:11:14,520 --> 00:11:15,920
想对付的问题是什么呢

271
00:11:15,960 --> 00:11:19,000
是说由于我在扫描算法里头

272
00:11:19,040 --> 00:11:20,960
我是考虑后面这些请求

273
00:11:21,000 --> 00:11:23,000
哪个离我最近

274
00:11:23,040 --> 00:11:25,000
如果说你总是在当前磁头

275
00:11:25,040 --> 00:11:28,320
所在位置的边上有请求

276
00:11:28,360 --> 00:11:30,840
在这个位置的请求就会优先响应

277
00:11:30,880 --> 00:11:32,360
但这种优先响应

278
00:11:32,400 --> 00:11:34,600
就会使另外一些请求

279
00:11:34,640 --> 00:11:36,960
得不到访问的机会

280
00:11:37,000 --> 00:11:41,720
这就是我们这里的磁头粘着现象

281
00:11:41,760 --> 00:11:42,520
这时候呢

282
00:11:42,560 --> 00:11:45,640
我们怎么来解决这个问题呢

283
00:11:45,680 --> 00:11:48,560
你比如说在这里刚才我们说的

284
00:11:48,600 --> 00:11:51,720
进程反复请求某一磁道的I/O操作

285
00:11:51,760 --> 00:11:54,320
它就会长时间的停到这儿

286
00:11:54,360 --> 00:11:56,840
对其它的后续的请求

287
00:11:56,880 --> 00:11:58,720
等待延时就会非常长

288
00:11:58,760 --> 00:12:03,160
为了减少这种某些情况速度很快

289
00:12:03,200 --> 00:12:06,000
在另外一些情况下性能很差这种情况

290
00:12:06,040 --> 00:12:07,840
有了N步扫描

291
00:12:07,880 --> 00:12:09,200
它的做法是什么呢

292
00:12:09,240 --> 00:12:12,120
它的做法是把磁盘请求

293
00:12:12,160 --> 00:12:15,240
分成N个子队列

294
00:12:15,280 --> 00:12:20,480
每次按照先进先出的顺序

295
00:12:20,520 --> 00:12:22,920
来处理所有的子队列

296
00:12:22,960 --> 00:12:26,040
也就说子队列我是按照先来后到的顺序

297
00:12:26,080 --> 00:12:30,080
但是在每一个队列内部我用扫描算法

298
00:12:30,120 --> 00:12:34,640
这就是我们这里的N步扫描算法

299
00:12:34,680 --> 00:12:36,960
那这种算法呢又有一个小变种

300
00:12:37,000 --> 00:12:39,240
就叫双队列扫描算法

301
00:12:39,280 --> 00:12:41,640
它和前面的做法的区别是在于

302
00:12:41,680 --> 00:12:43,400
我只分两个队列

303
00:12:43,440 --> 00:12:44,120
某种角度上讲

304
00:12:44,160 --> 00:12:47,440
你认为是N步扫描算法的一个简化

305
00:12:47,480 --> 00:12:49,920
这种简化完了之后呢

306
00:12:49,960 --> 00:12:51,640
我分成两个队列

307
00:12:51,680 --> 00:12:54,520
交替使用扫描算法处理每一个队列

308
00:12:54,560 --> 00:12:57,000
在处理一个队列的时候呢

309
00:12:57,040 --> 00:13:00,040
当前新到达的请求就放在另外一个

310
00:13:00,080 --> 00:13:02,680
没有进行处理那个队列里头

311
00:13:02,720 --> 00:13:03,640
用这种办法呢

312
00:13:03,680 --> 00:13:08,080
我就让这些请求有一个最长的等待时间

313
00:13:08,120 --> 00:13:09,360
也就是说当前处理的这些

314
00:13:09,400 --> 00:13:12,560
处理完了之后我再会去处理新的请求

315
00:13:12,600 --> 00:13:13,680
从这个角度来讲呢

316
00:13:13,720 --> 00:13:17,400
我的平均等待时间就会减少

317
00:13:17,440 --> 00:13:20,480
这是我们对磁盘调度的一个简要介绍

318
00:13:20,520 --> 00:13:21,760


319
00:13:21,800 --> 00:13:21,840


