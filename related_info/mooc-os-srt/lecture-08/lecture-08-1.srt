0
00:00:00,000 --> 00:00:15,960


1
00:00:16,000 --> 00:00:17,400
各位同学大家好

2
00:00:17,440 --> 00:00:22,280
今天我们来开始讲第八讲虚拟存储

3
00:00:22,320 --> 00:00:25,680
那么跟虚拟存储相关内容呢我们会分成两讲

4
00:00:25,720 --> 00:00:28,160
一讲呢是虚拟存储的概念

5
00:00:28,200 --> 00:00:31,400
另一讲呢是虚拟存储当中的置换算法

6
00:00:31,440 --> 00:00:35,280
今天呢我们先来讲虚拟存储的概念

7
00:00:35,320 --> 00:00:38,800
在前面呢我们讲过了物理内存的管理

8
00:00:38,840 --> 00:00:44,360
在那个地方呢我们有分区 非连续分区

9
00:00:44,400 --> 00:00:48,240
这两种办法呢是讲我们在物理内存当中

10
00:00:48,280 --> 00:00:55,040
如何去找到一块可以给进程使用的内存空间

11
00:00:55,080 --> 00:00:58,240
那么在今天呢我们来开始讲虚拟存储

12
00:00:58,280 --> 00:01:02,640
虚拟存储和前面讲的非连续内存分配呢

13
00:01:02,680 --> 00:01:07,280
是它的一个延续 非连续内存分配

14
00:01:07,320 --> 00:01:09,800
是说我在内存里找存储空间

15
00:01:09,840 --> 00:01:13,800
让它可以不连续 而虚拟存储呢

16
00:01:13,840 --> 00:01:17,480
是在这个非连续存储内存分配的基础上

17
00:01:17,520 --> 00:01:21,600
可以把一部分内容放到外存里的做法

18
00:01:21,640 --> 00:01:24,200
那这种做法呢可以让我们的应用程序

19
00:01:24,240 --> 00:01:26,800
有更大的空间可以来使用

20
00:01:26,840 --> 00:01:28,640
那具体说起来怎么做呢

21
00:01:28,680 --> 00:01:30,240
那在这里头我们就会讲到

22
00:01:30,280 --> 00:01:34,160
我们为啥会要把数据放到外存里头去

23
00:01:34,200 --> 00:01:37,200
因为在外存里访问呢它是会比内存慢的

24
00:01:37,240 --> 00:01:39,400
这样会带来一系列的问题

25
00:01:39,440 --> 00:01:42,400
那说我们在这里呢这样做之后

26
00:01:42,440 --> 00:01:44,560
可以让你内存的空间更大

27
00:01:44,600 --> 00:01:48,240
那如何来做呢我们这里会有到覆盖 交换

28
00:01:48,280 --> 00:01:51,640
这两个做法呢在前面的介绍我们已经提到过

29
00:01:51,680 --> 00:01:53,240
那更主要的一部分呢

30
00:01:53,280 --> 00:01:55,960
是我们这里说到的虚拟存储

31
00:01:56,000 --> 00:01:58,640
虚拟存储呢又涉及这样几个方面

32
00:01:58,680 --> 00:02:01,760
第一个说我可以把数据放到外存里头

33
00:02:01,800 --> 00:02:05,440
那如果说你的访问是完全随机的

34
00:02:05,480 --> 00:02:07,280
那这时候你放到外存里头之后

35
00:02:07,320 --> 00:02:10,080
你的访问它的性能肯定是要下降的

36
00:02:10,120 --> 00:02:12,000
好 那实际上呢我们在这里呢

37
00:02:12,040 --> 00:02:14,760
程序的执行它有一定的特征

38
00:02:14,800 --> 00:02:17,040
这就是我们这里的局部性原理

39
00:02:17,080 --> 00:02:18,520
有了局部性原理之后呢

40
00:02:18,560 --> 00:02:21,080
相当于我们程序在访问的时候

41
00:02:21,120 --> 00:02:26,680
它要么是指令的顺序执行 要么它是跳转

42
00:02:26,720 --> 00:02:29,040
跳转多数时候呢又是一个循环

43
00:02:29,080 --> 00:02:31,960
跳回到你原来访问过的某一个位置

44
00:02:32,000 --> 00:02:35,240
基于这样一些存储访问的特征呢

45
00:02:35,280 --> 00:02:37,440
我们可以说使用虚拟存储呢

46
00:02:37,480 --> 00:02:39,760
它的性能不至于比原来下降很多

47
00:02:39,800 --> 00:02:42,480
但是我可以得到更大的存储空间

48
00:02:42,520 --> 00:02:46,880
好 然后再说我们如何来做这件事情

49
00:02:46,920 --> 00:02:49,840
这就是我们说到的虚拟存储的概念

50
00:02:49,880 --> 00:02:52,600
然后说我们在页式存储之上

51
00:02:52,640 --> 00:02:55,240
加上把一部分的页放到外存

52
00:02:55,280 --> 00:02:58,360
这就是虚拟页式存储

53
00:02:58,400 --> 00:03:00,400
再有一个就是说我们在这里

54
00:03:00,440 --> 00:03:04,200
由于你把这个数据放到外存里

55
00:03:04,240 --> 00:03:06,800
那么你在指令执行的时候有可能你访问的

56
00:03:06,840 --> 00:03:08,400
某一个数据就在外存里

57
00:03:08,440 --> 00:03:10,880
好 那这个时候就有我们的缺页异常

58
00:03:10,920 --> 00:03:13,880
那缺页异常实际上我们前面讲中断的时候呢

59
00:03:13,920 --> 00:03:15,680
也已经涉及到过一些

60
00:03:15,720 --> 00:03:18,320
它是指令执行过程当中出现的问题

61
00:03:18,360 --> 00:03:20,840
好 那对于缺页来讲它的处理是什么样的

62
00:03:20,880 --> 00:03:23,800
这个是我们这次课里头呢要来介绍的内容

63
00:03:23,840 --> 00:03:26,560
那首先呢我们来看虚拟存储

64
00:03:26,600 --> 00:03:28,480
为什么我们要做这件事情

65
00:03:28,520 --> 00:03:32,560
那做任何一件事情它都是需要有需求推动的

66
00:03:32,600 --> 00:03:34,720
那我们说在这里呢

67
00:03:34,760 --> 00:03:39,360
现在对存储的容量的需求呢是越来越大的

68
00:03:39,400 --> 00:03:42,120
那我们看到这是以电脑游戏为例

69
00:03:42,160 --> 00:03:44,440
在早的时候的电脑游戏呢

70
00:03:44,480 --> 00:03:47,200
通常情况下我存在一张软盘是几十K

71
00:03:47,240 --> 00:03:49,560
几百K的这样一个尺度

72
00:03:49,600 --> 00:03:53,680
那这时候呢我们常见的警察抓小偷之类的

73
00:03:53,720 --> 00:03:58,160
然后到接下来呢我们希望这个游戏更好

74
00:03:58,200 --> 00:04:02,320
这种图象质量更高 好 那这种交互性更强

75
00:04:02,360 --> 00:04:07,240
那这时候我们游戏占的空间就变成几兆

76
00:04:07,280 --> 00:04:08,680
好 在这种情况下

77
00:04:08,720 --> 00:04:11,360
那就跟原来比就是10倍的增加了

78
00:04:11,400 --> 00:04:14,520
好 再往后我们要想更大场面的

79
00:04:14,560 --> 00:04:17,000
你比如说这是足球的互动游戏

80
00:04:17,040 --> 00:04:22,040
那在这里头呢这些人物 它的这个角色增加

81
00:04:22,080 --> 00:04:23,960
并且可以有很强的交互性

82
00:04:24,000 --> 00:04:26,640
每一个动作又有3D的动画之类

83
00:04:26,680 --> 00:04:27,440
这搁在一起之后

84
00:04:27,480 --> 00:04:30,880
我们这个游戏变成几十兆 上百兆了

85
00:04:30,920 --> 00:04:33,080
好 这种情况下 这只是一个例子

86
00:04:33,120 --> 00:04:36,800
说明我们应用程序随着时间推进

87
00:04:36,840 --> 00:04:38,920
它对存储的需要量是

88
00:04:38,960 --> 00:04:43,840
远大于存储容量的发展速度的

89
00:04:43,880 --> 00:04:47,640
那在这里头呢我们说有了这种需求之后

90
00:04:47,680 --> 00:04:49,280
我们对于存储来讲

91
00:04:49,320 --> 00:04:51,200
我们就要从技术上来解决问题

92
00:04:51,240 --> 00:04:53,520
那具体技术解决的办法呢

93
00:04:53,560 --> 00:04:57,560
我们有这样几条要求 第一条是容量

94
00:04:57,600 --> 00:05:00,640
那容量我们希望它越来越大

95
00:05:00,680 --> 00:05:03,600
第二个呢是我们希望速度它越来越快

96
00:05:03,640 --> 00:05:06,920
然后第三个呢 我们希望价格是越来越便宜的

97
00:05:06,960 --> 00:05:11,200
但是这几个目标呢实际上是相互制约的

98
00:05:11,240 --> 00:05:14,520
和计算机内部的其它部分呢相比较而言呢

99
00:05:14,560 --> 00:05:17,160
它是占的成本是不能太高的

100
00:05:17,200 --> 00:05:19,400
基本上在这个发展过程当中这一部分

101
00:05:19,440 --> 00:05:21,560
占的在计算机系统里头成本

102
00:05:21,600 --> 00:05:23,760
是大致相对稳定的一个比例

103
00:05:23,800 --> 00:05:25,760
好 那这是理想的情况

104
00:05:25,800 --> 00:05:28,240
这个理想的情况那我们是做不到的

105
00:05:28,280 --> 00:05:29,080
好 那这时候呢我们就会

106
00:05:29,120 --> 00:05:31,520
在现实当中来做这种折中

107
00:05:31,560 --> 00:05:33,400
好 现实当中折中是什么呢

108
00:05:33,440 --> 00:05:37,280
我们就会把存储放成这样一个层次结构

109
00:05:37,320 --> 00:05:40,240
那最快的是我们CPU里面的寄存器

110
00:05:40,280 --> 00:05:45,040
然后最慢的是我们外部设备里的磁盘和磁带

111
00:05:45,080 --> 00:05:48,320
好 中间 居于中间状态呢就是我们的内存

112
00:05:48,360 --> 00:05:54,680
那这几个呢它们的速度最快的是纳秒级别的

113
00:05:54,720 --> 00:06:02,560
最慢的是秒级别的 中间差100万倍 百万数量级

114
00:06:02,600 --> 00:06:07,800
然后它们的容量呢是几K 几兆 几十兆

115
00:06:07,840 --> 00:06:12,480
到最后呢 现在应该是我们到几个T这种尺度

116
00:06:12,520 --> 00:06:14,840
为什么这个比例我不可以都放这上头来呢

117
00:06:14,880 --> 00:06:19,480
原因在于 增加这些快速的部分的容量

118
00:06:19,520 --> 00:06:21,760
那它的价格就上去了

119
00:06:21,800 --> 00:06:26,240
好 那这时候说我们要想增加它的容量

120
00:06:26,280 --> 00:06:28,920
那我就是底下这几个 成本比较低的

121
00:06:28,960 --> 00:06:30,880
那这时候呢成本比较低的这几个呢

122
00:06:30,920 --> 00:06:31,840
速度又降下来了

123
00:06:31,880 --> 00:06:35,480
所以实际上这时候它组成一个层次结构

124
00:06:35,520 --> 00:06:38,680
让整个系统处于一种均衡的繁忙状态

125
00:06:38,720 --> 00:06:42,960
是我们想达到的最终的合理状态

126
00:06:43,000 --> 00:06:44,960
好 有了这些需求之后

127
00:06:45,000 --> 00:06:47,680
和内部存储介质的多种多样之后

128
00:06:47,720 --> 00:06:50,960
那我们在操作系统里对存储空间的管理呢

129
00:06:51,000 --> 00:06:52,720
就变得比较复杂了

130
00:06:52,760 --> 00:06:55,560
那我们希望管理出来操作系统抽象出来的

131
00:06:55,600 --> 00:07:00,120
进程地址空间呢是一个规范的

132
00:07:00,160 --> 00:07:02,520
布局合理的一个地址空间

133
00:07:02,560 --> 00:07:04,800
而在我们实际系统里头呢

134
00:07:04,840 --> 00:07:08,560
那它的存储介质是多种多样的

135
00:07:08,600 --> 00:07:10,960
那如果说直接让用户来应对

136
00:07:11,000 --> 00:07:12,680
这些存储介质的使用的话

137
00:07:12,720 --> 00:07:14,120
那么这时候你写出来程序

138
00:07:14,160 --> 00:07:17,400
它的通用性就会很受限制

139
00:07:17,440 --> 00:07:19,840
然后它编程的难度也会很高

140
00:07:19,880 --> 00:07:23,520
所以在中间呢我们用操作系统来做这种抽象

141
00:07:23,560 --> 00:07:26,120
这种映射关系由操作系统自动来做

142
00:07:26,160 --> 00:07:29,680
用户见到的空间就是上面的抽象的地址空间

143
00:07:29,720 --> 00:07:31,200
如果是这样一种结局的话

144
00:07:31,240 --> 00:07:36,480
那我们现在这个应用程序开发的环境就非常好了

145
00:07:36,520 --> 00:07:38,240
好 为了做到这一条

146
00:07:38,280 --> 00:07:41,800
那这就是我们在计算机操作系统当中的

147
00:07:41,840 --> 00:07:44,600
存储管理所需要 想达到的目标

148
00:07:44,640 --> 00:07:45,840
好 这种需求呢

149
00:07:45,880 --> 00:07:50,320
我们出现的原因是由于内存不够用

150
00:07:50,360 --> 00:07:52,160
而内存不够用呢也是随着

151
00:07:52,200 --> 00:07:56,120
我们在操作系统里头它多道程序

152
00:07:56,160 --> 00:07:58,840
多进程 多线程 这样一些

153
00:07:58,880 --> 00:08:01,880
并发性提高的情况下所导致的问题

154
00:08:01,920 --> 00:08:04,520
那解决办法呢我们有这样几种

155
00:08:04,560 --> 00:08:09,320
一种呢是覆盖 用户自己来导你的程序

156
00:08:09,360 --> 00:08:12,520
比如说我的代码都放到内存里不够了

157
00:08:12,560 --> 00:08:15,800
那我就会说我把它代码分成若干模块

158
00:08:15,840 --> 00:08:17,800
我们明确它们之间调用关系

159
00:08:17,840 --> 00:08:21,400
好 相互之间不存在调用关系的

160
00:08:21,440 --> 00:08:22,720
那好 那这些呢我就可以

161
00:08:22,760 --> 00:08:26,040
把它附庸到一块区域里头来 

162
00:08:26,080 --> 00:08:28,320
但你附庸之后就得要你用户自己

163
00:08:28,360 --> 00:08:31,440
来确定我在什么时候把一个模块加进去

164
00:08:31,480 --> 00:08:33,320
什么时候把另一个模块加进去

165
00:08:33,360 --> 00:08:35,720
这个你的应用开发难度会提高的

166
00:08:35,760 --> 00:08:38,440
第二种是兑换 说我们在这里

167
00:08:38,480 --> 00:08:40,400
用操作系统来干这件事情

168
00:08:40,440 --> 00:08:44,000
但是这时候呢因为我兑换的单位

169
00:08:44,040 --> 00:08:47,160
是一个进程的整个地址空间

170
00:08:47,200 --> 00:08:50,480
那这个时候它的开销是比较大的

171
00:08:50,520 --> 00:08:52,360
但是尽管说开销比较大

172
00:08:52,400 --> 00:08:54,640
在早的时候我不能做到

173
00:08:54,680 --> 00:08:57,080
非连续物理内存分配的时候

174
00:08:57,120 --> 00:08:59,080
这种办法仍然是有效的

175
00:08:59,120 --> 00:09:00,440
好 那这个是一个

176
00:09:00,480 --> 00:09:03,680
而我们今天要说的呢是虚拟存储

177
00:09:03,720 --> 00:09:05,920
那我们和前面的交换这种

178
00:09:05,960 --> 00:09:08,240
自动比较起来又往哪走了一步呢

179
00:09:08,280 --> 00:09:09,560
它仍然是自动的

180
00:09:09,600 --> 00:09:16,120
但是它的空间和容量是会更大 也会更自动

181
00:09:16,160 --> 00:09:19,480
那这是我们想要达到的目标

182
00:09:19,520 --> 00:09:21,120
那有了这个目标之后下面我们就

183
00:09:21,160 --> 00:09:24,520
具体来讨论我们是如何来实现这个目标的

184
00:09:24,560 --> 00:09:30,320


185
00:09:30,360 --> 00:09:30,760


186
00:09:30,800 --> 00:09:30,840


