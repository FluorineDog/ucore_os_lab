0
00:00:00,000 --> 00:00:07,120


1
00:00:07,160 --> 00:00:11,720
接下来我们介绍连续内存分配

2
00:00:11,760 --> 00:00:14,680
我们说 在分配内存空间的时候

3
00:00:14,720 --> 00:00:16,960
我们首先第一个

4
00:00:17,000 --> 00:00:20,200
在没有其它的技术支持的情况下

5
00:00:20,240 --> 00:00:23,840
分配给一个进程的地址空间必须是连续的

6
00:00:23,880 --> 00:00:25,600
为了提高利用效率

7
00:00:25,640 --> 00:00:29,960
那我希望分的位置有适度的选择

8
00:00:30,000 --> 00:00:32,720
这些动态分配算法

9
00:00:32,760 --> 00:00:36,480
实际上就是你在去选择的做法

10
00:00:36,520 --> 00:00:39,360
而选择完之后

11
00:00:39,400 --> 00:00:44,200
你用每一个进程可能用的时间长短不一样

12
00:00:44,240 --> 00:00:45,480
有的进程先结束

13
00:00:45,520 --> 00:00:47,080
有的进程后结束

14
00:00:47,120 --> 00:00:50,280
这个时候 有可能先结束的会留出一些空

15
00:00:50,320 --> 00:00:52,680
后面一个在分配的时候又会再去找

16
00:00:52,720 --> 00:00:54,120
这个过程的执行 

17
00:00:54,160 --> 00:00:56,360
就会在中间留下一些碎片

18
00:00:56,400 --> 00:01:00,480
这些碎片对于我们后续的分配是会有影响的

19
00:01:00,520 --> 00:01:07,200
我们就从如何去找你要用的空闲分区

20
00:01:07,240 --> 00:01:09,960
和如何来处理不能利用的这些

21
00:01:10,000 --> 00:01:13,920
小的空闲分区的两个角度来看

22
00:01:13,960 --> 00:01:16,160
连续内存分配算法

23
00:01:16,200 --> 00:01:20,680
连续内存分配 是指给进程分配一块

24
00:01:20,720 --> 00:01:22,720
不小于指定大小的

25
00:01:22,760 --> 00:01:26,120
物理连续的一块内存区域

26
00:01:26,160 --> 00:01:27,760
这个地方是一个图示

27
00:01:27,800 --> 00:01:31,280
说我进程不断的分配回收

28
00:01:31,320 --> 00:01:34,760
分配了三个 进程二就释放掉了

29
00:01:34,800 --> 00:01:37,640
这个时候是我内存分配时候的状态

30
00:01:37,680 --> 00:01:39,640
每一个进程的地址空间里头

31
00:01:39,680 --> 00:01:41,840
我们可能存放的是代码 数据 

32
00:01:41,880 --> 00:01:43,800
堆栈 这些内容

33
00:01:43,840 --> 00:01:45,000
那在这些中间 

34
00:01:45,040 --> 00:01:48,400
我们就会有一些区域没办法利用了

35
00:01:48,440 --> 00:01:49,800
比如说像这里头 

36
00:01:49,840 --> 00:01:51,800
这有一块 这有一小块

37
00:01:51,840 --> 00:01:53,640
中间如果你要分配四块的话

38
00:01:53,680 --> 00:01:55,400
这小块也没法用了

39
00:01:55,440 --> 00:01:57,560
对于这些没法利用的区域

40
00:01:57,600 --> 00:02:01,400
我们就称之为是碎片

41
00:02:01,440 --> 00:02:04,760
这些碎片它是没办法利用的

42
00:02:04,800 --> 00:02:06,920
这个没办法利用 是相对而言的

43
00:02:06,960 --> 00:02:08,160
如果说你要得小块

44
00:02:08,200 --> 00:02:10,080
其中这块还是可以利用的

45
00:02:10,120 --> 00:02:12,960
但是有一些你是无论如何用不起来的

46
00:02:13,000 --> 00:02:18,080
这些碎片 我们把它分成两种情况

47
00:02:18,120 --> 00:02:20,320
一个是叫外碎片

48
00:02:20,360 --> 00:02:25,520
外碎片是两块之间的这一块

49
00:02:25,560 --> 00:02:28,680
实际上它也是一个小的空闲块

50
00:02:28,720 --> 00:02:30,360
只是由于它过小

51
00:02:30,400 --> 00:02:35,560
而其它进程申请的区域的大小都大于它

52
00:02:35,600 --> 00:02:37,400
而导致这块没法利用

53
00:02:37,440 --> 00:02:42,160
另一种情况是内碎片

54
00:02:42,200 --> 00:02:46,600
内碎片是分配给进程的区域内部的

55
00:02:46,640 --> 00:02:49,520
一些没法利用的区域

56
00:02:49,560 --> 00:02:51,160
什么情况下会出现这种（情况）呢

57
00:02:51,200 --> 00:02:52,440
如果说我分配的时候

58
00:02:52,480 --> 00:02:56,160
并不是说我可以准确地分配你所指定的大小

59
00:02:56,200 --> 00:03:02,560
比如说 你想分配510字节

60
00:03:02,600 --> 00:03:04,640
但是实际上我们在分配的时候

61
00:03:04,680 --> 00:03:07,360
只能是以512字节这种

62
00:03:07,400 --> 00:03:09,400
2的整数幂为单位的大小

63
00:03:09,440 --> 00:03:12,160
那剩下的几个字节你就没办法利用了

64
00:03:12,200 --> 00:03:14,760
像这些我们称之为叫内碎片

65
00:03:14,800 --> 00:03:15,480
对于我这来讲

66
00:03:15,520 --> 00:03:19,440
P1和P3上边剩的这段就是这种情况

67
00:03:19,480 --> 00:03:22,360
那是由于它要取整所导致的

68
00:03:22,400 --> 00:03:24,200
那我们在分配的时候

69
00:03:24,240 --> 00:03:28,240
希望尽可能减少这种碎片的出现

70
00:03:28,280 --> 00:03:30,080
从而使得我在利用的时候

71
00:03:30,120 --> 00:03:31,120
比如说这种情况

72
00:03:31,160 --> 00:03:33,320
我想分配一个六块的

73
00:03:33,360 --> 00:03:35,920
那么这两个在这里头是没办法利用的

74
00:03:35,960 --> 00:03:37,320
如果它两个是在一起的

75
00:03:37,360 --> 00:03:41,720
这个事就是行的

76
00:03:41,760 --> 00:03:45,160
我们来看动态分区分配

77
00:03:45,200 --> 00:03:47,000
动态分区分配实际上是说

78
00:03:47,040 --> 00:03:48,280
我在分配的时候

79
00:03:48,320 --> 00:03:50,640
我可以指定大小

80
00:03:50,680 --> 00:03:53,920
并且这个大小是用户指定的时候可变的

81
00:03:53,960 --> 00:03:55,560
那我们分配出来结果

82
00:03:55,600 --> 00:03:57,360
称之为叫一个分区

83
00:03:57,400 --> 00:04:00,520
也可能叫内存块 也可能叫块

84
00:04:00,560 --> 00:04:04,200
分配出来的地址是连续的

85
00:04:04,240 --> 00:04:07,560
对于这边是一个例子

86
00:04:07,600 --> 00:04:09,120
第一个进程 分配

87
00:04:09,160 --> 00:04:11,040
第二个进程 接着来

88
00:04:11,080 --> 00:04:13,240
刚开始的时候我可以顺序地分配

89
00:04:13,280 --> 00:04:15,840
这事比较容易

90
00:04:15,880 --> 00:04:16,920
在用的过程当中

91
00:04:16,960 --> 00:04:19,200
某些进程就会结束

92
00:04:19,240 --> 00:04:20,800
那结束掉就还回来了

93
00:04:20,840 --> 00:04:21,840
对于这种情况

94
00:04:21,880 --> 00:04:23,920
现在我要想再分配的话

95
00:04:23,960 --> 00:04:27,120
我就必须知道我哪些内存区域

96
00:04:27,160 --> 00:04:29,200
已经分配给了进程

97
00:04:29,240 --> 00:04:31,280
哪些内存区域还是空闲的

98
00:04:31,320 --> 00:04:32,280
实际上在这时候

99
00:04:32,320 --> 00:04:33,520
我们操作系统就要

100
00:04:33,560 --> 00:04:36,760
维护这样两个数据结构

101
00:04:36,800 --> 00:04:39,680
一个是已分配的分区

102
00:04:39,720 --> 00:04:40,960
我们就需要知道

103
00:04:41,000 --> 00:04:42,760
哪些是已经分配出去的

104
00:04:42,800 --> 00:04:44,520
它分配给了谁

105
00:04:44,560 --> 00:04:47,640
第二个是空闲分区

106
00:04:47,680 --> 00:04:52,360
我需要知道空闲分区的位置和大小

107
00:04:52,400 --> 00:04:53,720
对于我不同的找法

108
00:04:53,760 --> 00:04:56,840
这两个数据结构的组织形式

109
00:04:56,880 --> 00:04:58,560
是会有一些变化的

110
00:04:58,600 --> 00:05:00,360
在不同组织形式下

111
00:05:00,400 --> 00:05:04,280
你在找分区或者说把分区释放的时候

112
00:05:04,320 --> 00:05:07,400
放回到分区列表里的时候

113
00:05:07,440 --> 00:05:09,360
它的开销是会不一样的

114
00:05:09,400 --> 00:05:12,000
这是我们在这需要考虑的问题

115
00:05:12,040 --> 00:05:13,920
对于找分区的不同

116
00:05:13,960 --> 00:05:15,920
我们在这就有这样几种

117
00:05:15,960 --> 00:05:18,600
动态分区的分配策略

118
00:05:18,640 --> 00:05:22,400
大家通常想要是说我要分配一块区域

119
00:05:22,440 --> 00:05:23,560
我给你指定大小

120
00:05:23,600 --> 00:05:25,200
这个个时候你去分你去找

121
00:05:25,240 --> 00:05:28,600
你可能会碰到一个我就找一个

122
00:05:28,640 --> 00:05:32,360
这就是我们这里的第一种情况 最先匹配

123
00:05:32,400 --> 00:05:33,800
你找着哪一个

124
00:05:33,840 --> 00:05:35,560
碰到哪一个就是那个

125
00:05:35,600 --> 00:05:40,160
我也可以是说我找最佳的

126
00:05:40,200 --> 00:05:41,240
叫最佳匹配

127
00:05:41,280 --> 00:05:41,920
它是什么意思

128
00:05:41,960 --> 00:05:44,640
我把所有这些空闲的我全看一遍

129
00:05:44,680 --> 00:05:47,960
看看这里头 哪一个是比我大

130
00:05:48,000 --> 00:05:50,520
但是又是大的最少那个

131
00:05:50,560 --> 00:05:54,240
如果说 你是这些空闲分区

132
00:05:54,280 --> 00:05:55,720
你是按地址顺序排的

133
00:05:55,760 --> 00:05:57,960
那你就把整个全部找一遍

134
00:05:58,000 --> 00:05:59,360
如果说我在这里

135
00:05:59,400 --> 00:06:03,160
是按照它的大小排的

136
00:06:03,200 --> 00:06:04,880
那我就是从小往上找

137
00:06:04,920 --> 00:06:07,280
找到第一个就行了

138
00:06:07,320 --> 00:06:11,080
这是你空闲分区排序办法的不同

139
00:06:11,120 --> 00:06:13,800
我找的时候开销是不一样的

140
00:06:13,840 --> 00:06:16,720
还一种是最差匹配

141
00:06:16,760 --> 00:06:17,400
我去找

142
00:06:17,440 --> 00:06:20,640
每次用的时候我用的是最大的

143
00:06:20,680 --> 00:06:23,960
用最大就相当于实际上我是按照由大到小排序

144
00:06:24,000 --> 00:06:26,240
我的第一个肯定就是它了

145
00:06:26,280 --> 00:06:30,920
这是几种基本分区的分配策略

146
00:06:30,960 --> 00:06:33,600
下面我们具体来看

147
00:06:33,640 --> 00:06:37,240
第一种 最先匹配策略

148
00:06:37,280 --> 00:06:39,400
在这里 它的思路很简单

149
00:06:39,440 --> 00:06:41,080
你要分配多少字节 

150
00:06:41,120 --> 00:06:43,560
我就从空闲分区列表里

151
00:06:43,600 --> 00:06:46,840
去找第一个可以找着比它大的

152
00:06:46,880 --> 00:06:49,840
比如说在这里头我是按照地址顺序排的

153
00:06:49,880 --> 00:06:52,360
这个时候我在这我去找

154
00:06:52,400 --> 00:06:54,600
我这个黄颜色是我空闲的

155
00:06:54,640 --> 00:06:55,920
我这给了一个例子

156
00:06:55,960 --> 00:06:58,880
说我想找一个400字节的

157
00:06:58,920 --> 00:07:00,840
我上来看 这个地方是1K

158
00:07:00,880 --> 00:07:03,400
OK 它就是比我想要的大

159
00:07:03,440 --> 00:07:04,240
那就是它了

160
00:07:04,280 --> 00:07:06,240
分配完了之后变成什么呢

161
00:07:06,280 --> 00:07:07,480
分配完了之后

162
00:07:07,520 --> 00:07:10,360
一块被你申请的进程所占用

163
00:07:10,400 --> 00:07:13,160
我把它放到已分配分区的列表去

164
00:07:13,200 --> 00:07:16,960
并且注明它是哪一个进程占用的

165
00:07:17,000 --> 00:07:18,360
然后这个时候还剩一点

166
00:07:18,400 --> 00:07:21,240
剩一点我又把它描述成另外一个

167
00:07:21,280 --> 00:07:22,800
小个的空闲分区

168
00:07:22,840 --> 00:07:26,360
接着把它放到空闲分区列表里头去

169
00:07:26,400 --> 00:07:28,400
在这里头如果按照地址排的话

170
00:07:28,440 --> 00:07:29,760
那我就是在哪

171
00:07:29,800 --> 00:07:31,480
这个思路就是这样的

172
00:07:31,520 --> 00:07:34,040
那我们再看你在这里做的时候

173
00:07:34,080 --> 00:07:35,720
它实现办法是什么

174
00:07:35,760 --> 00:07:40,760
我的空闲分区是按照地址顺序排的

175
00:07:40,800 --> 00:07:42,600
然后分配的时候怎么做

176
00:07:42,640 --> 00:07:44,600
分配的时候从前往后找

177
00:07:44,640 --> 00:07:46,560
找第一个所谓的合适

178
00:07:46,600 --> 00:07:50,720
就是大于我指定的大小就可以了

179
00:07:50,760 --> 00:07:53,880
释放的时候 我在还回来的时候我放回去

180
00:07:53,920 --> 00:07:55,680
按照地址把它插到里面去了

181
00:07:55,720 --> 00:08:00,560
并且看它前后是否有临近的空闲分区

182
00:08:00,600 --> 00:08:02,280
这个时候我把它合并到一起

183
00:08:02,320 --> 00:08:06,680
这个时候找和合并的开销都是比较小的

184
00:08:06,720 --> 00:08:09,080
但是它在这里头

185
00:08:09,120 --> 00:08:11,880
因为我们每一次都是从头找

186
00:08:11,920 --> 00:08:14,040
这样的话你都在前面能找到的时候

187
00:08:14,080 --> 00:08:15,600
它就不会往后找

188
00:08:15,640 --> 00:08:16,560
所以这样一来

189
00:08:16,600 --> 00:08:18,400
它的另外一个好处是

190
00:08:18,440 --> 00:08:20,720
在高地址的区域里头

191
00:08:20,760 --> 00:08:24,680
它会留下一些比较大块的分区

192
00:08:24,720 --> 00:08:26,880
你在后续要申请大块的时候

193
00:08:26,920 --> 00:08:28,080
我是能找着的

194
00:08:28,120 --> 00:08:29,920
如果我大块都切成了小块

195
00:08:29,960 --> 00:08:31,600
那这你就找不着了

196
00:08:31,640 --> 00:08:32,480
这是它的优点

197
00:08:32,520 --> 00:08:35,760
它的缺点是说我会有外碎片

198
00:08:35,800 --> 00:08:36,960
我每一次切的时候

199
00:08:37,000 --> 00:08:38,600
如果大小不合适我都会切成俩

200
00:08:38,640 --> 00:08:42,880
这个时候就会留下一个小的空闲分区

201
00:08:42,920 --> 00:08:46,240
如果这个小个空闲分区多到一定程度

202
00:08:46,280 --> 00:08:49,400
这时候你在后面往下分配大块的时候

203
00:08:49,440 --> 00:08:51,120
它就得从前往后找

204
00:08:51,160 --> 00:08:55,000
也就相当于前面很长一段你找不到

205
00:08:55,040 --> 00:08:57,080
由于你找不到 你就只能往后找

206
00:08:57,120 --> 00:08:58,960
那这个时候往后找的这个过程

207
00:08:59,000 --> 00:09:00,760
开销就会越来越大

208
00:09:00,800 --> 00:09:03,800
也就相当于越往后

209
00:09:03,840 --> 00:09:06,920
你在前面搜索的时间就会越长

210
00:09:06,960 --> 00:09:09,960
这是第一种算法最先匹配

211
00:09:10,000 --> 00:09:12,960
它的好处和缺点

212
00:09:13,000 --> 00:09:15,960
那么第二种方法是最佳匹配

213
00:09:16,000 --> 00:09:18,760
也就是说它找到一个比它大

214
00:09:18,800 --> 00:09:21,800
并且是最小的空闲分区

215
00:09:21,840 --> 00:09:22,920
如果说在这里头

216
00:09:22,960 --> 00:09:25,120
像在这里这个例子

217
00:09:25,160 --> 00:09:28,360
我们要想分配400个字节

218
00:09:28,400 --> 00:09:31,080
那1K 2K 500字节

219
00:09:31,120 --> 00:09:32,920
这三个比较起来

220
00:09:32,960 --> 00:09:36,440
这个是比它大并且是大的最少的

221
00:09:36,480 --> 00:09:38,040
那我们在这来分配

222
00:09:38,080 --> 00:09:40,400
分配完的结果变成什么样子

223
00:09:40,440 --> 00:09:41,560
我前两个不动

224
00:09:41,600 --> 00:09:43,160
第三个把它切成两个

225
00:09:43,200 --> 00:09:46,800
留下一个小的100字节的空闲分区

226
00:09:46,840 --> 00:09:50,400
另外一个作为已分配的

227
00:09:50,440 --> 00:09:51,840
对它做相应的标识

228
00:09:51,880 --> 00:09:53,600
告诉它分配给了哪个进程

229
00:09:53,640 --> 00:09:55,880
那这个事就算搞定了

230
00:09:55,920 --> 00:09:57,800
我们看在这里头

231
00:09:57,840 --> 00:10:00,120
我需要维护的数据结构是什么样子的

232
00:10:00,160 --> 00:10:01,320
首先第一个

233
00:10:01,360 --> 00:10:04,640
空闲分区我怎么来排序

234
00:10:04,680 --> 00:10:08,360
因为我是找比它大最小的一个

235
00:10:08,400 --> 00:10:11,240
我找的时候是从小往大找

236
00:10:11,280 --> 00:10:12,960
所以我的空闲分区

237
00:10:13,000 --> 00:10:15,240
如果是从小往大排序

238
00:10:15,280 --> 00:10:17,960
我开始是比它小的

239
00:10:18,000 --> 00:10:19,080
第一个比它大的

240
00:10:19,120 --> 00:10:21,280
OK这就是我想要找的

241
00:10:21,320 --> 00:10:24,080
如果前面比它小的数目比较少

242
00:10:24,120 --> 00:10:26,080
我很快就能找着

243
00:10:26,120 --> 00:10:29,880
分配的时候 我是从前往后找

244
00:10:29,920 --> 00:10:31,400
释放的时候 

245
00:10:31,440 --> 00:10:34,880
我就看 跟它临近的进行合并

246
00:10:34,920 --> 00:10:36,160
这个时候就有一个问题

247
00:10:36,200 --> 00:10:39,840
临近的话我就是需要去找它地址临近的

248
00:10:39,880 --> 00:10:41,680
并不是大小临近的

249
00:10:41,720 --> 00:10:43,040
正是因为这样一来

250
00:10:43,080 --> 00:10:44,960
按地址排序的 你合并的时候

251
00:10:45,000 --> 00:10:46,960
它的算法就会复杂一些

252
00:10:47,000 --> 00:10:48,680
花的时间就会长一些

253
00:10:48,720 --> 00:10:54,360
这种做法它的好处是我可以把较大的块

254
00:10:54,400 --> 00:10:56,600
如果说我分配块的尺度

255
00:10:56,640 --> 00:10:59,280
都是比较小的时候

256
00:10:59,320 --> 00:11:01,840
这个时候它的效果是比较好的

257
00:11:01,880 --> 00:11:03,000
如果说你分配大的

258
00:11:03,040 --> 00:11:05,480
那这个时候它后边剩的就会少了

259
00:11:05,520 --> 00:11:06,920
这个时候它会有什么好处呢

260
00:11:06,960 --> 00:11:09,520
避免大的分区被拆分

261
00:11:09,560 --> 00:11:12,440
因为你找的是比它大的最小的那个

262
00:11:12,480 --> 00:11:19,040
然后它可以减少外碎片的尺寸

263
00:11:19,080 --> 00:11:20,160
也就是说剩下那块

264
00:11:20,200 --> 00:11:21,680
一定是我能找的这一块里

265
00:11:21,720 --> 00:11:25,080
剩下的最小那块

266
00:11:25,120 --> 00:11:27,280
然后相对来说它比较简单

267
00:11:27,320 --> 00:11:31,120
缺点是说你剩的那块边角料是小了

268
00:11:31,160 --> 00:11:35,400
但剩的越小这块边角料它越没法利用

269
00:11:35,440 --> 00:11:37,320
所以它有外碎片

270
00:11:37,360 --> 00:11:40,920
并且是释放分区的时候它会比较复杂

271
00:11:40,960 --> 00:11:45,520
然后剩下那些小碎片基本上也就没用了

272
00:11:45,560 --> 00:11:47,960
这是最佳匹配

273
00:11:48,000 --> 00:11:52,840
然后还有一种做法我们是最差匹配

274
00:11:52,880 --> 00:11:55,720
它的做法我找最大的

275
00:11:55,760 --> 00:11:57,520
有可能是说我找最大

276
00:11:57,560 --> 00:11:58,520
也不满足我的要求

277
00:11:58,560 --> 00:12:00,000
这是找不到了

278
00:12:00,040 --> 00:12:02,840
那这里头我们找了一个最大的

279
00:12:02,880 --> 00:12:05,040
比如说在这里这个例子

280
00:12:05,080 --> 00:12:07,600
我要分配400字节

281
00:12:07,640 --> 00:12:08,920
那这个时候找哪个呢

282
00:12:08,960 --> 00:12:10,480
最大的这是2K

283
00:12:10,520 --> 00:12:12,680
我把它切成两块

284
00:12:12,720 --> 00:12:15,480
在这里 这块标记已分配

285
00:12:15,520 --> 00:12:18,320
剩下这一块还有1K多比这块还大

286
00:12:18,360 --> 00:12:21,520
它可以被利用的机会就会更多

287
00:12:21,560 --> 00:12:26,280
这是最差匹配它所带来的好处

288
00:12:26,320 --> 00:12:27,840
具体做法是 

289
00:12:27,880 --> 00:12:30,800
这个地方空闲分区排序要怎么排

290
00:12:30,840 --> 00:12:32,040
这个时候由大到小排

291
00:12:32,080 --> 00:12:33,960
我每次找的时候

292
00:12:34,000 --> 00:12:35,320
只要第一个满足要求

293
00:12:35,360 --> 00:12:36,440
那就是我要找的

294
00:12:36,480 --> 00:12:39,320
第一个不满足要求 我就没有了

295
00:12:39,360 --> 00:12:42,600
这时候分配的时候就是找最大的一个

296
00:12:42,640 --> 00:12:45,680
也是找第一个 找的速度是最快的

297
00:12:45,720 --> 00:12:49,680
然后释放的时候 我要去找它临近的

298
00:12:49,720 --> 00:12:53,000
由于我排序不是按地址排的

299
00:12:53,040 --> 00:12:58,280
你找临近就需要去顺序找了

300
00:12:58,320 --> 00:13:01,240
找着临近的 然后把它合在一起

301
00:13:01,280 --> 00:13:04,600
放回到空闲分区列表时候

302
00:13:04,640 --> 00:13:06,960
我还要去找放的位置

303
00:13:07,000 --> 00:13:08,960
因为你原来是按大小排序的

304
00:13:09,000 --> 00:13:12,600
现在你仍然需要按照原来大小的去排

305
00:13:12,640 --> 00:13:15,840
要不然下次找的时候就不对了

306
00:13:15,880 --> 00:13:17,720
这个时候它有什么好处

307
00:13:17,760 --> 00:13:21,040
如果说你的中等尺度的分配比较多

308
00:13:21,080 --> 00:13:22,400
这个时候效果是比较好的

309
00:13:22,440 --> 00:13:26,280
因为我用掉那块不是很大

310
00:13:26,320 --> 00:13:28,960
然后剩的那块多的时候还能利用起来

311
00:13:29,000 --> 00:13:32,320
相当于我剩的小块就比较少了

312
00:13:32,360 --> 00:13:35,080
剩的那块我还可以找到用处

313
00:13:35,120 --> 00:13:36,280
实际上这个时候关键是

314
00:13:36,320 --> 00:13:39,800
剩的那块能给它找什么样的用处

315
00:13:39,840 --> 00:13:43,240
它的缺点是释放的过程比较慢

316
00:13:43,280 --> 00:13:47,600
因为释放之后的合并是要进行搜索的

317
00:13:47,640 --> 00:13:50,280
它排序跟我这个合并没有关系

318
00:13:50,320 --> 00:13:53,600
然后也会有外部碎片

319
00:13:53,640 --> 00:13:58,240
如果说你在这头由于我每次都是最大的

320
00:13:58,280 --> 00:14:00,280
你在后边你想分配大分区的时候

321
00:14:00,320 --> 00:14:03,040
这事就变的比较困难了

322
00:14:03,080 --> 00:14:06,200
这是我们在这里说到连续存储分配

323
00:14:06,240 --> 00:14:08,240
它的几种做法

324
00:14:08,280 --> 00:14:10,800
这几种做法主要出发点

325
00:14:10,840 --> 00:14:13,480
就是我那个空闲分区的列表

326
00:14:13,520 --> 00:14:15,280
它是按什么来排

327
00:14:15,320 --> 00:14:17,040
然后我们需要去考虑的是

328
00:14:17,080 --> 00:14:20,080
在分配的时候它的查找开销

329
00:14:20,120 --> 00:14:23,440
和在释放的时候它合并的开销

330
00:14:23,480 --> 00:14:25,920
和把这个合并完的结果

331
00:14:25,960 --> 00:14:30,280
放回到空闲分区列表里的时候

332
00:14:30,320 --> 00:14:32,240
找合适位置的开销

333
00:14:32,280 --> 00:14:32,280
    

