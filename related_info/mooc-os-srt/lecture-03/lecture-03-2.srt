0
00:00:00,000 --> 00:00:06,440


1
00:00:06,520 --> 00:00:08,840
好 在刚才的描述当中

2
00:00:08,880 --> 00:00:12,440
我们说清楚了计算机在启动的时候

3
00:00:12,480 --> 00:00:14,760
它从什么地方去读第一条指令

4
00:00:14,800 --> 00:00:19,720
从磁盘上的什么地方去读第一块数据

5
00:00:19,760 --> 00:00:23,120
那接下来 我们会把刚才这个过程做进一步的细化

6
00:00:23,160 --> 00:00:26,840
也就是说系统启动的时候的流程

7
00:00:26,880 --> 00:00:29,640
按照我们刚才说的流程

8
00:00:29,680 --> 00:00:32,440
应该说我加电之后去读BIOS

9
00:00:32,480 --> 00:00:35,440
BIOS去读你的加载程序

10
00:00:35,480 --> 00:00:38,440
加载程序去读内核映像

11
00:00:38,480 --> 00:00:41,640
这个过程实际上我们又可以把它细化下去

12
00:00:41,680 --> 00:00:43,960
因为我在加载程序的时候

13
00:00:44,000 --> 00:00:45,040
我BIOS里头起来

14
00:00:45,080 --> 00:00:48,920
我们说直接去读bootloader

15
00:00:48,960 --> 00:00:52,000
但实际上这个过程它并不能直接进行

16
00:00:52,040 --> 00:00:55,440
比如说我们在最早的时候

17
00:00:55,480 --> 00:00:58,840
系统里只有一个分区

18
00:00:58,880 --> 00:01:01,520
上来之后我就直接到分区里找文件系统了

19
00:01:01,560 --> 00:01:03,160
但是对于我们现在来说

20
00:01:03,200 --> 00:01:04,280
所有的计算机

21
00:01:04,320 --> 00:01:07,560
或者大多数的计算机里头都不止一个分区

22
00:01:07,600 --> 00:01:09,040
可能会有几个分区

23
00:01:09,080 --> 00:01:11,480
每个分区上会装不同的系统

24
00:01:11,520 --> 00:01:15,360
那这个时候就在前边加上一个主引导记录

25
00:01:15,400 --> 00:01:16,680
这个主引导记录是说

26
00:01:16,720 --> 00:01:18,120
我要从哪个文件系统里

27
00:01:18,160 --> 00:01:21,560
去读我的这个加载程序

28
00:01:21,600 --> 00:01:23,760
好 有了主引导记录之后

29
00:01:23,800 --> 00:01:27,520
然后我就进到当前哪个分区里头

30
00:01:27,560 --> 00:01:32,440
分区里头又有一个分区的引导扇区

31
00:01:32,480 --> 00:01:34,920
这个活动分区的引导扇区

32
00:01:34,960 --> 00:01:39,320
再来加载我们刚才说到的加载程序

33
00:01:39,360 --> 00:01:42,040
这个过程当中实际上我们就需要知道中间

34
00:01:42,080 --> 00:01:45,240
这几个部分它的格式是什么样子

35
00:01:45,280 --> 00:01:46,720
如果你不知道这个格式的话

36
00:01:46,760 --> 00:01:48,000
那你写出来的程序

37
00:01:48,040 --> 00:01:49,440
最终存到磁盘上

38
00:01:49,480 --> 00:01:51,640
机器是不能够从里头认识的

39
00:01:51,680 --> 00:01:53,800
那我们具体说起来呢

40
00:01:53,840 --> 00:01:54,960
有这样几个过程

41
00:01:55,000 --> 00:01:56,800
首先我们在前面已经说过

42
00:01:56,840 --> 00:01:59,120
CPU加电完成它的初始化

43
00:01:59,160 --> 00:02:01,720
到一个确定的状态去读第一条指令

44
00:02:01,760 --> 00:02:05,080
我们需要知道CPU初始化之后

45
00:02:05,120 --> 00:02:07,640
它的代码段段寄存器

46
00:02:07,680 --> 00:02:11,360
和当前指令指针寄存器这两个的内容

47
00:02:11,400 --> 00:02:15,960
算出来它的第一条指令在内存当中的什么地方

48
00:02:16,000 --> 00:02:18,920
有了这个之后 说我们在这里头呢

49
00:02:18,960 --> 00:02:20,440
这是它计算的依据

50
00:02:20,480 --> 00:02:22,920
因为它是实模式

51
00:02:22,960 --> 00:02:27,480
所以是CS和IP都是16位的

52
00:02:27,520 --> 00:02:32,640
CS左移四位加在一起算出我的位置

53
00:02:32,680 --> 00:02:36,840
这个时候 我放到内存当中的BIOS的位置

54
00:02:36,880 --> 00:02:38,920
只能是在最底下的一兆

55
00:02:38,960 --> 00:02:42,760
原因在于这时候它是20位的地址

56
00:02:42,800 --> 00:02:46,840
有了这个之后我们就直接进到BIOS里执行

57
00:02:46,880 --> 00:02:48,120
BIOS里 我们刚才说

58
00:02:48,160 --> 00:02:52,720
它是从磁盘上去读你的加载程序

59
00:02:52,760 --> 00:02:55,960
那实际上在这里头它还有很多的事情要做

60
00:02:56,000 --> 00:02:58,600
首先第一个是硬件自检

61
00:02:58,640 --> 00:03:02,280
也就是说我们有可能加电起来之后

62
00:03:02,320 --> 00:03:06,000
你的内存出错 那整个后边就没法做

63
00:03:06,040 --> 00:03:07,560
这时候问大家

64
00:03:07,600 --> 00:03:10,520
你见到过你的计算机如果内存出错了

65
00:03:10,560 --> 00:03:12,280
你的显示器肯定是不工作的

66
00:03:12,320 --> 00:03:15,280
那这时候我怎么知道出这个问题了

67
00:03:15,320 --> 00:03:17,200
我们说在计算机系统里头

68
00:03:17,240 --> 00:03:18,600
它的加电自检

69
00:03:18,640 --> 00:03:23,760
它上来之后是看最关键的这几个部分是不是在工作

70
00:03:23,800 --> 00:03:25,200
如果说检测到

71
00:03:25,240 --> 00:03:26,960
这就相当于在自检的时候你需要知道

72
00:03:27,000 --> 00:03:31,200
关键的内存 显卡这几部分是否存在

73
00:03:31,240 --> 00:03:33,840
或者说干脆你的机器里就没有显卡

74
00:03:33,880 --> 00:03:37,080
如果存在的话 它的工作状态是什么样子

75
00:03:37,120 --> 00:03:40,000
把这些设备完成每一个

76
00:03:40,040 --> 00:03:41,880
这些关键性的接口卡里头

77
00:03:41,920 --> 00:03:45,000
它自己也有自己的初始化程序

78
00:03:45,040 --> 00:03:46,680
这些初始化程序完成之后

79
00:03:46,720 --> 00:03:49,040
那我就认为关键的设备是可以的了

80
00:03:49,080 --> 00:03:54,080
然后这时候 我们再来执行系统的初始化

81
00:03:54,120 --> 00:03:56,360
BIOS的初始化 这时候它是干什么呢

82
00:03:56,400 --> 00:03:58,400
我们说我们现在的系统

83
00:03:58,440 --> 00:04:01,440
很多都是可以即插即用的

84
00:04:01,480 --> 00:04:06,000
那如果说我想从一个USB接口的光驱里启动

85
00:04:06,040 --> 00:04:07,640
那你怎么启得来

86
00:04:07,680 --> 00:04:10,040
那这时候呢 在这个BIOS里的自检

87
00:04:10,080 --> 00:04:13,440
现在是能够做到系统的自检

88
00:04:13,480 --> 00:04:18,040
把这些检测并且配置你的这些即插即用的设备

89
00:04:18,080 --> 00:04:19,280
这些工作做完之后

90
00:04:19,320 --> 00:04:22,680
我就知道我现在的系统里到底都连了哪些硬件

91
00:04:22,720 --> 00:04:26,120
好 我们说在BIOS里有一个系统配置表

92
00:04:26,160 --> 00:04:28,200
这个配置表就是我们这里所说的

93
00:04:28,240 --> 00:04:36,080
ESCD 就是扩展系统配置数据

94
00:04:36,120 --> 00:04:38,040
那用这个数据 我就能知道

95
00:04:38,080 --> 00:04:40,440
我当前系统里都有些什么样的设备

96
00:04:40,480 --> 00:04:43,760
每次加电之后有可能你会插上新的卡

97
00:04:43,800 --> 00:04:45,400
或者说拔掉已有的卡

98
00:04:45,440 --> 00:04:46,840
这个数据是会变得

99
00:04:46,880 --> 00:04:48,680
每次加电的时候都必须做

100
00:04:48,720 --> 00:04:51,720
做完之后说我就把控制权

101
00:04:51,760 --> 00:04:56,160
转到我们从外部读进来的数据里头

102
00:04:56,200 --> 00:04:57,560
读进来的代码里 

103
00:04:57,600 --> 00:05:01,120
那这就是按我们在BIOS里指定的顺序

104
00:05:01,160 --> 00:05:06,000
从软盘 硬盘或者光盘或者你指定的其他设备上

105
00:05:06,040 --> 00:05:09,000
读进你的第一块扇区

106
00:05:09,040 --> 00:05:10,560
读进来之后 那这时候

107
00:05:10,600 --> 00:05:13,520
我们说在我们现在说的这个过程里头

108
00:05:13,560 --> 00:05:15,200
有多个分区

109
00:05:15,240 --> 00:05:18,280
好 这时我就有一个主引导记录

110
00:05:18,320 --> 00:05:19,840
在这个主引导记录里头

111
00:05:19,880 --> 00:05:23,640
我们需要知道的内容是它的格式

112
00:05:23,680 --> 00:05:25,600
那说在里头呢

113
00:05:25,640 --> 00:05:27,800
我们说它有512字节

114
00:05:27,840 --> 00:05:31,720
但是在这 你只能说我可以用到的是446

115
00:05:31,760 --> 00:05:33,160
那其他部分是什么

116
00:05:33,200 --> 00:05:35,360
原因在于我在这里头

117
00:05:35,400 --> 00:05:37,520
我还有后边有多个分区的时候

118
00:05:37,560 --> 00:05:40,000
这些分区的状态是什么样的

119
00:05:40,040 --> 00:05:42,840
你也要存到这512字节里头

120
00:05:42,880 --> 00:05:43,600
所以这样的话

121
00:05:43,640 --> 00:05:48,920
你就只有446个字节的内容来执行你的启动代码

122
00:05:48,960 --> 00:05:50,720
在这启动代码里我需要干啥呢

123
00:05:50,760 --> 00:05:54,080
需要知道我这些分区表是不是正确的

124
00:05:54,120 --> 00:05:55,720
如果说你的分区表是错的

125
00:05:55,760 --> 00:05:59,280
那这时候我的程序是没法正常加载的

126
00:05:59,320 --> 00:06:03,080
然后还要加载并跳转到

127
00:06:03,120 --> 00:06:07,960
你的活动分区的引导记录上去

128
00:06:08,000 --> 00:06:10,200
第二个是你的分区表

129
00:06:10,240 --> 00:06:14,160
然后我们对于所有的引导扇区

130
00:06:14,200 --> 00:06:16,200
都有一个结束标志

131
00:06:16,240 --> 00:06:17,880
这个结束标是55AA

132
00:06:17,920 --> 00:06:23,080
有了这个之后 它才认为这是一个合法的主引导记录

133
00:06:23,120 --> 00:06:24,520
那有了这个之后

134
00:06:24,560 --> 00:06:27,680
它就会跳到你活动分区的引导扇区上去

135
00:06:27,720 --> 00:06:29,480
那在这仍然是一样的

136
00:06:29,520 --> 00:06:32,040
它也有一个它需要了解的格式

137
00:06:32,080 --> 00:06:35,000
那在这里头 就开始有文件卷的信息

138
00:06:35,040 --> 00:06:38,880
这个结束标志跟刚才那个主引导记录是一样的

139
00:06:38,920 --> 00:06:40,120
好 在这基础上呢

140
00:06:40,160 --> 00:06:41,840
说它有启动代码

141
00:06:41,880 --> 00:06:44,800
那启动代码就是一条跳转指令

142
00:06:44,840 --> 00:06:48,240
那这个跳转指令跟我们刚才说到的有什么区别呢

143
00:06:48,280 --> 00:06:51,920
那这地方它就跟平台相关了 你的CPU不同 

144
00:06:51,960 --> 00:06:54,440
这个地方这条指令肯定也是不一样的

145
00:06:54,480 --> 00:06:57,000
然后空下的其他地方呢

146
00:06:57,040 --> 00:06:58,960
再是我的启动代码

147
00:06:59,000 --> 00:07:03,080
这个地方的启动代码就需要认识你的格式说

148
00:07:03,120 --> 00:07:07,480
我这个加载程序不是存在在512字节里头的

149
00:07:07,520 --> 00:07:09,160
存在别处 它在哪

150
00:07:09,200 --> 00:07:14,320
那就靠你这里的代码来约定说我放在哪

151
00:07:14,360 --> 00:07:17,280
而这里的代码实际上是我们存在硬盘上的

152
00:07:17,320 --> 00:07:18,680
或者说你的软盘上的

153
00:07:18,720 --> 00:07:21,320
这个时候我是可以改动的

154
00:07:21,360 --> 00:07:22,280
那改动完了之后

155
00:07:22,320 --> 00:07:25,360
我就可以把我的加载程序放在任意的地方

156
00:07:25,400 --> 00:07:28,960
只要我在这标识出来我上哪去认识它就可以

157
00:07:29,000 --> 00:07:34,200
好 接下来我们说加载程序的细化

158
00:07:34,240 --> 00:07:35,320
那在这里头呢

159
00:07:35,360 --> 00:07:41,080
我们说加载程序它首先不是直接去加载你的内核

160
00:07:41,120 --> 00:07:43,040
而是去从文件系统当中

161
00:07:43,080 --> 00:07:46,760
这时候加载程序我是能够认识文件系统的格式的

162
00:07:46,800 --> 00:07:49,600
从里头读一个启动配置文件

163
00:07:49,640 --> 00:07:51,240
这个启动配置文件

164
00:07:51,280 --> 00:07:53,920
在不同的操作系统里它是会不一样的

165
00:07:53,960 --> 00:07:56,800
你比如说Windows和Linux都有自己的格式

166
00:07:56,840 --> 00:07:58,320
这样的话它Windows和Linux

167
00:07:58,360 --> 00:08:02,560
都有自己的加载程序的格式

168
00:08:02,600 --> 00:08:07,240
依据这个选择你启动的这种参数

169
00:08:07,280 --> 00:08:09,080
比如说我是在正常启动

170
00:08:09,120 --> 00:08:11,040
还是说我是在安全模式启动

171
00:08:11,080 --> 00:08:14,440
还是说我是在一个调试状态下启动我的系统

172
00:08:14,480 --> 00:08:17,680
那这些区别都会读出来之后

173
00:08:17,720 --> 00:08:21,520
它导致我在加载内核的时候的一些内核会不一样

174
00:08:21,560 --> 00:08:26,320
或者说我加载的时候的参数会不一样

175
00:08:26,360 --> 00:08:28,480
好 依据配置去加载内核

176
00:08:28,520 --> 00:08:32,320
那么到这 我们把这个过程描述清楚了

177
00:08:32,360 --> 00:08:34,160
说到这是不是会说

178
00:08:34,200 --> 00:08:37,640
是说的足够详细吗

179
00:08:37,680 --> 00:08:39,360
如果说我要来写实际程序

180
00:08:39,400 --> 00:08:41,280
知道这些是不是就足够了

181
00:08:41,320 --> 00:08:42,640
那我可以告诉大家

182
00:08:42,680 --> 00:08:45,280
我这的介绍仍然是很粗的

183
00:08:45,320 --> 00:08:47,560
如果说你要想写实际的程序

184
00:08:47,600 --> 00:08:50,640
那么我们需要知道CPU的手册

185
00:08:50,680 --> 00:08:52,320
它在加电的时候

186
00:08:52,360 --> 00:08:55,320
处于什么样的状态 BIOS里的规范

187
00:08:55,360 --> 00:08:57,840
我在从磁盘上什么地方读的第一条

188
00:08:57,880 --> 00:08:59,360
它的格式是什么样子

189
00:08:59,400 --> 00:09:01,240
那到这呢 你还需要知道

190
00:09:01,280 --> 00:09:02,760
我的内核编译的时候

191
00:09:02,800 --> 00:09:04,600
它的一些相应的信息

192
00:09:04,640 --> 00:09:08,320
那我们说在计算机启动的过程当中

193
00:09:08,360 --> 00:09:11,320
我们有很多需要考虑的因素

194
00:09:11,360 --> 00:09:14,600
这种考虑的因素又有很多细节

195
00:09:14,640 --> 00:09:16,880
和我们实际的硬件环境

196
00:09:16,920 --> 00:09:21,080
或者说周围的情况密切相关

197
00:09:21,120 --> 00:09:24,320
那是不是我们需要在每一种硬件平台上

198
00:09:24,360 --> 00:09:27,840
我都要制定一个自己的启动流程呢

199
00:09:27,880 --> 00:09:29,440
那实际上不是这样的

200
00:09:29,480 --> 00:09:32,200
我们在实际的工业界

201
00:09:32,240 --> 00:09:34,720
它制定的一组相应的标准

202
00:09:34,760 --> 00:09:37,320
BIOS就是我们现在广泛使用的

203
00:09:37,360 --> 00:09:40,440
在PC机上的启动流程标准

204
00:09:40,480 --> 00:09:43,800
那在这里头 它是主板上的一段程序

205
00:09:43,840 --> 00:09:46,360
那它可以完成系统的启动

206
00:09:46,400 --> 00:09:49,040
但是从它最早出现的时候

207
00:09:49,080 --> 00:09:52,400
是70年代后期 

208
00:09:52,440 --> 00:09:56,120
那在这应该是几十年的变化过程当中

209
00:09:56,160 --> 00:09:58,520
它已经有了许多的发展

210
00:09:58,560 --> 00:10:02,120
这呢 我们列出了几种它的变化

211
00:10:02,160 --> 00:10:05,440
刚才说到那个主引导记录这一部分

212
00:10:05,480 --> 00:10:08,840
这一部分实际上相当于是说最早的BIOS

213
00:10:08,880 --> 00:10:12,520
它是从主板上加电自检之后

214
00:10:12,560 --> 00:10:16,320
进到你的磁盘上的唯一的一个分区上

215
00:10:16,360 --> 00:10:20,120
去加载它的引导记录去了

216
00:10:20,160 --> 00:10:23,880
那有了多分区磁盘之后

217
00:10:23,920 --> 00:10:27,120
就相当于我一个系统有多个磁盘 有多个分区

218
00:10:27,160 --> 00:10:29,880
那这时候我就需要选择从哪个分区启动

219
00:10:29,920 --> 00:10:31,600
由于这种需求呢

220
00:10:31,640 --> 00:10:34,120
在上边加了一个主引导记录

221
00:10:34,160 --> 00:10:35,440
这个主引导记录呢

222
00:10:35,480 --> 00:10:40,120
告诉你我从这几个分区里的选择了

223
00:10:40,160 --> 00:10:42,480
其中的活动分区来进行启动

224
00:10:42,520 --> 00:10:44,520
那这也有了我们这里的第一个

225
00:10:44,560 --> 00:10:46,440
然后从这里头我们也可以看到

226
00:10:46,480 --> 00:10:47,640
当时谁在里头呢

227
00:10:47,680 --> 00:10:52,040
主引导记录里头我只能描述最多四个分区

228
00:10:52,080 --> 00:10:53,440
每个占16个字节

229
00:10:53,480 --> 00:10:56,440
我全部有512个字节

230
00:10:56,480 --> 00:10:58,440
你四个分区用到了64

231
00:10:58,480 --> 00:11:00,400
那再多了的话不行了

232
00:11:00,440 --> 00:11:04,720
而我们现在用到计算机很多的分区会大于四个

233
00:11:04,760 --> 00:11:05,680
那这时候怎么办呢

234
00:11:05,720 --> 00:11:08,960
这时候就有了这里说的GPT

235
00:11:09,000 --> 00:11:11,880
全局唯一标识分区表

236
00:11:11,920 --> 00:11:13,720
这个分区表 可以在我的分区表里

237
00:11:13,760 --> 00:11:17,800
描述更多的分区结构

238
00:11:17,840 --> 00:11:20,400
有了这个之后 我就不会受那四个的限制

239
00:11:20,440 --> 00:11:23,160
所以这是BIOS的两个发展

240
00:11:23,200 --> 00:11:28,560
然后PXE实际上是网络启动的一个标准

241
00:11:28,600 --> 00:11:30,280
也就是说我的机器启来了之后

242
00:11:30,320 --> 00:11:33,000
我想通过局域网或者说其他的网络

243
00:11:33,040 --> 00:11:34,760
连到服务器上 去从服务器上

244
00:11:34,800 --> 00:11:38,040
下载我的内核镜像来执行

245
00:11:38,080 --> 00:11:39,080
那这时候怎么办呢

246
00:11:39,120 --> 00:11:42,280
就是这是它的标准

247
00:11:42,320 --> 00:11:43,360
那如果从这个角度来讲

248
00:11:43,400 --> 00:11:44,320
你要从网络启动

249
00:11:44,360 --> 00:11:49,000
好 这时候就你的BIOS里加网络协议栈

250
00:11:49,040 --> 00:11:50,440
那从这个角度来讲的话

251
00:11:50,480 --> 00:11:52,800
这个BIOS的功能也会越做越复杂

252
00:11:52,840 --> 00:11:55,840
甚至于在一些系统里头

253
00:11:55,880 --> 00:11:57,520
那它就是一个小的操作系统

254
00:11:57,560 --> 00:11:59,760
好 那在这个变化的过程当中呢

255
00:11:59,800 --> 00:12:01,200
从我们刚才讲解注意到

256
00:12:01,240 --> 00:12:03,600
BIOS它可以有一些局部的修改

257
00:12:03,640 --> 00:12:05,520
来完善对后续的支持

258
00:12:05,560 --> 00:12:09,080
但这种支持总是会受到前边的制约

259
00:12:09,120 --> 00:12:11,920
比如说在我们的主引导记录里头

260
00:12:11,960 --> 00:12:13,640
为了支持多分区

261
00:12:13,680 --> 00:12:17,800
那我就把中间那地方加成了磁盘上的主引导记录

262
00:12:17,840 --> 00:12:23,040
然后再加上活动分区里头的这个引导记录

263
00:12:23,080 --> 00:12:25,320
多了两层 实际上多这两层呢

264
00:12:25,360 --> 00:12:28,240
它的意义并不是特别的必要

265
00:12:28,280 --> 00:12:30,080
如果说我设计一个全新的话

266
00:12:30,120 --> 00:12:32,240
那这件事情我是不需要这么做的

267
00:12:32,280 --> 00:12:33,840
正是由于这种原因

268
00:12:33,880 --> 00:12:38,520
那我们又定义了一种新的这个启动规范

269
00:12:38,560 --> 00:12:42,720
那就是UEFI 统一可扩展固件接口

270
00:12:42,760 --> 00:12:46,600
这个接口 它想达到的目标是在所有平台上

271
00:12:46,640 --> 00:12:50,440
一致的提供操作系统的启动服务

272
00:12:50,480 --> 00:12:51,720
为了做到这一点呢

273
00:12:51,760 --> 00:12:52,720
实际上它这个标准呢

274
00:12:52,760 --> 00:12:55,880
应该是从90年代就开始出它的第一个版本

275
00:12:55,920 --> 00:12:57,000
一直到现在呢

276
00:12:57,040 --> 00:12:59,400
都在不断的演变的过程当中

277
00:12:59,440 --> 00:13:00,360
在上这课之前呢

278
00:13:00,400 --> 00:13:02,360
我查了一下它的最新状态

279
00:13:02,400 --> 00:13:07,480
它的最后一次修改我能看到的是2015年的1月份

280
00:13:07,520 --> 00:13:09,200
好 在这里它会增加什么呢

281
00:13:09,240 --> 00:13:10,480
那我在这举一个例子

282
00:13:10,520 --> 00:13:13,720
说我们要想从磁盘上启动

283
00:13:13,760 --> 00:13:17,560
我只要能拿到一张新的磁盘塞到你的机器里 

284
00:13:17,600 --> 00:13:21,000
这台机器剩下的事情我就都可以控制

285
00:13:21,040 --> 00:13:22,200
那这样的话 我这个系统

286
00:13:22,240 --> 00:13:24,720
对于一些关键性的服务器

287
00:13:24,760 --> 00:13:27,760
我允许这样做是有麻烦的

288
00:13:27,800 --> 00:13:29,000
好 针对这种麻烦

289
00:13:29,040 --> 00:13:30,440
在这个UEFI规范里头呢

290
00:13:30,480 --> 00:13:32,600
就定一个可信启动流程

291
00:13:32,640 --> 00:13:33,920
在这个流程里头呢

292
00:13:33,960 --> 00:13:35,360
BIOS起来以后

293
00:13:35,400 --> 00:13:38,240
它在读磁盘上的引导记录的时候

294
00:13:38,280 --> 00:13:42,640
那它是会对这个引导记录的可信性进行一个检查

295
00:13:42,680 --> 00:13:44,640
也就是说它会让里头有一个签名

296
00:13:44,680 --> 00:13:49,320
你只有我满足我签名的这些引导记录我才会读进来

297
00:13:49,360 --> 00:13:52,040
才会把控制权交给你

298
00:13:52,080 --> 00:13:54,520
使得我在整个的启动流程当中

299
00:13:54,560 --> 00:13:57,840
可信的这些介质上的这些代码

300
00:13:57,880 --> 00:13:59,400
可以在我的系统当中运行

301
00:13:59,440 --> 00:14:01,680
从而提高了从启动的阶段

302
00:14:01,720 --> 00:14:04,440
减少了这种安全的风险

303
00:14:04,480 --> 00:14:06,600
那我们说 这个修改的过程

304
00:14:06,640 --> 00:14:08,480
还会再继续下去

305
00:14:08,520 --> 00:14:11,840
随着这个周边环境的变化

306
00:14:11,880 --> 00:14:13,840
在这个规范里头加新的内容

307
00:14:13,880 --> 00:14:17,960
慢慢的 也会希望这个规范能够有更广泛的适用范围

308
00:14:18,000 --> 00:14:18,040


