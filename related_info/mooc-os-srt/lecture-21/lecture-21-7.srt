0
00:00:00,000 --> 00:00:07,560


1
00:00:07,600 --> 00:00:08,840
下面来我们来讨论

2
00:00:08,880 --> 00:00:11,200
空闲空间的管理

3
00:00:11,240 --> 00:00:13,280
有了前面的文件分区

4
00:00:13,320 --> 00:00:14,920
空闲空间的管理呢

5
00:00:14,960 --> 00:00:16,960
相对来说就变得更容易了

6
00:00:17,000 --> 00:00:18,320
原因在于 这地方我们

7
00:00:18,360 --> 00:00:20,760
不需要记录它的顺序

8
00:00:20,800 --> 00:00:24,800
只需要记录和跟踪文件卷当中

9
00:00:24,840 --> 00:00:27,880
未分配的数据块的分布情况

10
00:00:27,920 --> 00:00:30,120
当然在这里头呢它也会有

11
00:00:30,160 --> 00:00:34,440
跟前面的文件分配不一样的地方

12
00:00:34,480 --> 00:00:36,400
那就是这个里头内容呢

13
00:00:36,440 --> 00:00:39,160
随着文件的创建和删除

14
00:00:39,200 --> 00:00:41,880
它的状态是随时发生变化的

15
00:00:41,920 --> 00:00:43,120
我们在这里 有些什么样的

16
00:00:43,160 --> 00:00:44,920
办法来说这事呢

17
00:00:44,960 --> 00:00:47,120
我们需要考虑的问题是

18
00:00:47,160 --> 00:00:48,400
我用什么样的数据结构

19
00:00:48,440 --> 00:00:52,120
来表示空闲空间的这个列表 

20
00:00:52,160 --> 00:00:56,000
我们首先看到第一种呢是位图

21
00:00:56,040 --> 00:00:59,040
每一个块占一位

22
00:00:59,080 --> 00:01:00,760
然后所有的块

23
00:01:00,800 --> 00:01:03,520
对应到所有位放到一起

24
00:01:03,560 --> 00:01:08,000
就构成一个空闲数据块的列表

25
00:01:08,040 --> 00:01:09,760
在这个列表里头呢

26
00:01:09,800 --> 00:01:14,240
零表示对应的数据块i

27
00:01:14,280 --> 00:01:15,640
比如说Di等于0

28
00:01:15,680 --> 00:01:18,080
表示数据块i是空闲的

29
00:01:18,120 --> 00:01:19,440
否则呢就表示这一块

30
00:01:19,480 --> 00:01:21,560
已经分配出去了

31
00:01:21,600 --> 00:01:24,120
用这种办法之后呢

32
00:01:24,160 --> 00:01:26,000
我们看到 如果说你的

33
00:01:26,040 --> 00:01:28,400
文件分区很大的话

34
00:01:28,440 --> 00:01:29,640
那么这时候呢

35
00:01:29,680 --> 00:01:32,600
这个向量表占的空间也是很大的

36
00:01:32,640 --> 00:01:34,680
这地方给出一个例子是说

37
00:01:34,720 --> 00:01:38,160
我有一个160GB的磁盘

38
00:01:38,200 --> 00:01:40,920
然后我4KB为一块

39
00:01:40,960 --> 00:01:42,640
那这样的话

40
00:01:42,680 --> 00:01:47,800
2的30次方乘以160

41
00:01:47,840 --> 00:01:52,160
然后我4K 2的12次方为一块

42
00:01:52,200 --> 00:01:55,600
那这样的话我有40兆数据块

43
00:01:55,640 --> 00:01:57,400
如果说我在这里头呢

44
00:01:57,440 --> 00:02:01,280
每一个8位能表示8个数据块

45
00:02:01,320 --> 00:02:04,600
那就是5M字节的位图

46
00:02:04,640 --> 00:02:07,080
所占用的存储空间

47
00:02:07,120 --> 00:02:10,080
这个空间你是需要频繁进行修改的话

48
00:02:10,120 --> 00:02:15,160
那这时候呢它的修改量也是很大的 

49
00:02:15,200 --> 00:02:17,640
与此同时说我们要想去

50
00:02:17,680 --> 00:02:20,280
找到磁盘上一个空闲块

51
00:02:20,320 --> 00:02:22,440
那我需要去查这个表

52
00:02:22,480 --> 00:02:25,160
在查的范围是什么样子呢

53
00:02:25,200 --> 00:02:28,640
假定空闲块的分布呢是均匀的

54
00:02:28,680 --> 00:02:31,880
那这时候我在找所需要花的时间呢

55
00:02:31,920 --> 00:02:34,600
基本上是说磁盘块的总数

56
00:02:34,640 --> 00:02:38,160
和空闲块的数目之间一个比

57
00:02:38,200 --> 00:02:42,960
你占的比例越高它越容易找着

58
00:02:43,000 --> 00:02:49,760
这是位图表示空闲空间的方法

59
00:02:49,800 --> 00:02:51,840
那同时呢也还有其他一些办法

60
00:02:51,880 --> 00:02:54,720
比如说像我们前面说到链表法

61
00:02:54,760 --> 00:02:57,480
我仍然可以用这种方式来表示

62
00:02:57,520 --> 00:02:59,520
每一个空闲块里头呢

63
00:02:59,560 --> 00:03:02,160
有一个指针指向下一块

64
00:03:02,200 --> 00:03:04,080
那这样的话我在这里呢很方便

65
00:03:04,120 --> 00:03:07,360
也能找到我的空闲块组织起来

66
00:03:07,400 --> 00:03:10,080
当然这种办法呢它的开销会比较大

67
00:03:10,120 --> 00:03:11,480
我们也可以把它

68
00:03:11,520 --> 00:03:13,920
跟其他办法组合到一块

69
00:03:13,960 --> 00:03:17,120
那就是这里的链式索引

70
00:03:17,160 --> 00:03:18,440
我最底下一层是用索引

71
00:03:18,480 --> 00:03:20,640
上边用链表

72
00:03:20,680 --> 00:03:22,680
这样的话既可以节省相应的空间

73
00:03:22,720 --> 00:03:25,520
又找起来不是很费事

74
00:03:25,560 --> 00:03:28,400
这是我们用来表示

75
00:03:28,440 --> 00:03:31,080
空闲空间的几种方法

76
00:03:31,120 --> 00:03:32,440
在实际系统里呢

77
00:03:32,480 --> 00:03:36,040
也是这几种方法组合起来使用的 

78
00:03:36,080 --> 00:03:40,160
下面我们来讨论磁盘阵列

79
00:03:40,200 --> 00:03:43,680
冗余磁盘阵列raid实际上是一种

80
00:03:43,720 --> 00:03:47,040
提高文件系统可靠性

81
00:03:47,080 --> 00:03:51,360
和读写性能的一组技术

82
00:03:51,400 --> 00:03:54,760
通常情况下我们在访问磁盘的时候

83
00:03:54,800 --> 00:03:57,960
由于磁盘上有磁头的移动

84
00:03:58,000 --> 00:03:59,320
这是一种机械运动

85
00:03:59,360 --> 00:04:04,880
所以它的性能呢相对来说是比较慢的

86
00:04:04,920 --> 00:04:06,160
通常情况下这里头呢

87
00:04:06,200 --> 00:04:08,560
我们会通过磁盘分区

88
00:04:08,600 --> 00:04:11,240
来限制这个寻道的时间

89
00:04:11,280 --> 00:04:14,480
从而提高它的性能

90
00:04:14,520 --> 00:04:17,440
分区是一组柱面的集合

91
00:04:17,480 --> 00:04:18,520
比如说在这里头

92
00:04:18,560 --> 00:04:20,960
我们把一个磁盘上

93
00:04:21,000 --> 00:04:23,920
分成了A B两个分区

94
00:04:23,960 --> 00:04:25,840
那在每一个分区呢

95
00:04:25,880 --> 00:04:28,960
我们都可以视为逻辑上独立的一个磁盘

96
00:04:29,000 --> 00:04:31,680
但实际上它是没办法完全独立的 

97
00:04:31,720 --> 00:04:32,960
比如说我在这里头

98
00:04:33,000 --> 00:04:35,960
我要是只在A分区上进行文件读写

99
00:04:36,000 --> 00:04:37,920
那么它的性能是会提高的

100
00:04:37,960 --> 00:04:39,640
但如果说你把这一个磁盘

101
00:04:39,680 --> 00:04:41,640
分成了A和B两个分区

102
00:04:41,680 --> 00:04:43,560
但是你的操作系统

103
00:04:43,600 --> 00:04:46,280
同时在两个分区上进行操作

104
00:04:46,320 --> 00:04:49,560
那么这时候呢在A B分区上进行切换

105
00:04:49,600 --> 00:04:52,120
它的性能呢是很差的 

106
00:04:52,160 --> 00:04:54,200
这是一个呢典型的

107
00:04:54,240 --> 00:04:56,400
文件系统分区的做法

108
00:04:56,440 --> 00:04:58,000
我们在这儿呢介绍一个

109
00:04:58,040 --> 00:05:03,080
典型的磁盘文件系统的组织

110
00:05:03,120 --> 00:05:05,240
首先我们说一下文件卷

111
00:05:05,280 --> 00:05:06,840
和磁盘分区的关系

112
00:05:06,880 --> 00:05:10,160
文件卷是指拥有一个完整的

113
00:05:10,200 --> 00:05:12,880
文件系统实例的外存空间

114
00:05:12,920 --> 00:05:14,800
通常情况下它对应到

115
00:05:14,840 --> 00:05:17,040
我们磁盘上一个分区

116
00:05:17,080 --> 00:05:18,720
比如说在这里头

117
00:05:18,760 --> 00:05:22,320
我们把一号磁盘分成A和B两个分区

118
00:05:22,360 --> 00:05:24,600
每一个分区呢有一套自己的

119
00:05:24,640 --> 00:05:27,000
完整的文件系统实例

120
00:05:27,040 --> 00:05:29,640
它有目录 文件

121
00:05:29,680 --> 00:05:32,960
通常前面还有文件卷控制块

122
00:05:33,000 --> 00:05:34,640
还有一种做法呢是说

123
00:05:34,680 --> 00:05:37,600
我们也可以把多个磁盘合在一起

124
00:05:37,640 --> 00:05:40,040
变成一个逻辑的分区

125
00:05:40,080 --> 00:05:41,560
这些呢 它是可以扩大

126
00:05:41,600 --> 00:05:43,960
你的磁盘分区的容量

127
00:05:44,000 --> 00:05:49,840
以便于你能在一个分区里存更多的数据

128
00:05:49,880 --> 00:05:51,040
这些呢 都没有办法

129
00:05:51,080 --> 00:05:56,360
提高我们的读写性能和可靠性

130
00:05:56,400 --> 00:05:58,720
多磁盘管理 实际上就是想

131
00:05:58,760 --> 00:06:01,240
利用多个独立的磁盘

132
00:06:01,280 --> 00:06:05,960
同时使用来提高磁盘的读写性能

133
00:06:06,000 --> 00:06:08,480
也就说通过并行提高它的吞吐量

134
00:06:08,520 --> 00:06:11,000
然后来提高它的可靠性

135
00:06:11,040 --> 00:06:13,480
相当于是说我通过冗余

136
00:06:13,520 --> 00:06:15,400
你比如说数据存多份

137
00:06:15,440 --> 00:06:18,280
来提高它的可靠性和可用性

138
00:06:18,320 --> 00:06:21,400
具体说起来呢冗余磁盘阵列

139
00:06:21,440 --> 00:06:25,080
实际上raid是一组磁盘管理的技术

140
00:06:25,120 --> 00:06:29,720
它通过条带化 映像

141
00:06:29,760 --> 00:06:32,040
和带校验的条带化

142
00:06:32,080 --> 00:06:35,800
来实现对磁盘可靠性性能的提升

143
00:06:35,840 --> 00:06:38,760
这组技术的实现方法呢有两种

144
00:06:38,800 --> 00:06:40,160
一种我们可以做到

145
00:06:40,200 --> 00:06:42,040
操作系统文件系统里头

146
00:06:42,080 --> 00:06:44,240
通过文件系统的卷管理

147
00:06:44,280 --> 00:06:47,040
来实现上面说到这些

148
00:06:47,080 --> 00:06:50,160
冗余磁盘阵列的技术

149
00:06:50,200 --> 00:06:52,440
也可以呢用硬件来实现

150
00:06:52,480 --> 00:06:55,240
用硬件的raid控制器

151
00:06:55,280 --> 00:06:57,160
用这种控制器 实际上在你的操作系统

152
00:06:57,200 --> 00:06:58,800
感觉不到它的存在

153
00:06:58,840 --> 00:07:01,760
就像是用一个分区一样的 

154
00:07:01,800 --> 00:07:06,320
下面我们来看这几种冗余磁盘阵列技术

155
00:07:06,360 --> 00:07:09,680
它所能带来的好处和它的具体做法

156
00:07:09,720 --> 00:07:13,920
第一种呢raid0它是一种磁盘条带化技术

157
00:07:13,960 --> 00:07:18,440
它通过把数据块分成若干个子块

158
00:07:18,480 --> 00:07:21,920
然后把这些子块存在独立的磁盘上

159
00:07:21,960 --> 00:07:23,840
注意这地方一定是要独立

160
00:07:23,880 --> 00:07:24,920
我在一个硬盘上 

161
00:07:24,960 --> 00:07:28,400
把它分成多个逻辑分区是不起作用的

162
00:07:28,440 --> 00:07:32,480
通过这些独立硬盘上的并行数据块访问

163
00:07:32,520 --> 00:07:35,080
来提高磁盘的带宽 

164
00:07:35,120 --> 00:07:37,160
我们看一下具体做法

165
00:07:37,200 --> 00:07:39,960
假定我这儿有三个磁盘

166
00:07:40,000 --> 00:07:41,880
然后在操作系统层面上

167
00:07:41,920 --> 00:07:44,520
看到一个数据块是这样的

168
00:07:44,560 --> 00:07:45,920
那我在存储的时候呢

169
00:07:45,960 --> 00:07:47,080
我把它分成三个子块

170
00:07:47,120 --> 00:07:49,480
这里一行是一块

171
00:07:49,520 --> 00:07:50,760
这是一个示意

172
00:07:50,800 --> 00:07:53,320
然后我把它存到这三个磁盘上

173
00:07:53,360 --> 00:07:56,040
这样的话我如果说是写数据

174
00:07:56,080 --> 00:07:57,920
那么我是三个磁盘同时写

175
00:07:57,960 --> 00:08:01,400
应该它的速度呢会提高接近它的三倍

176
00:08:01,440 --> 00:08:04,560
如果是读呢我可以从三个一块来读

177
00:08:04,600 --> 00:08:06,760
那这时候它速度也会提升三倍

178
00:08:06,800 --> 00:08:10,160
但如果说你读取的数据量小

179
00:08:10,200 --> 00:08:11,600
这时候你读三个

180
00:08:11,640 --> 00:08:13,760
但是我只要第一个里的数据

181
00:08:13,800 --> 00:08:16,480
那这时候它的速度是没有提升的 

182
00:08:16,520 --> 00:08:19,120
这是第一种做法 raid0

183
00:08:19,160 --> 00:08:23,400
通过条带化来提高读写的磁盘带宽

184
00:08:23,440 --> 00:08:25,760
从而呢提高它的性能

185
00:08:25,800 --> 00:08:29,640
第二种做法呢是raid1 磁盘镜像

186
00:08:29,680 --> 00:08:34,200
它通过同时向两个磁盘

187
00:08:34,240 --> 00:08:35,800
写入相同的数据

188
00:08:35,840 --> 00:08:37,880
来提高它的可靠性

189
00:08:37,920 --> 00:08:39,240
当然你读取的时候呢

190
00:08:39,280 --> 00:08:40,880
可以从任何一个来读

191
00:08:40,920 --> 00:08:43,720
如果你读的数据可以同时从两个里读的话

192
00:08:43,760 --> 00:08:46,520
那么它的读性能呢也会提高一倍

193
00:08:46,560 --> 00:08:47,880
那它具体做法是什么呢

194
00:08:47,920 --> 00:08:50,560
那这里呢可以提高它的可靠性

195
00:08:50,600 --> 00:08:52,440
可靠性是成倍增加的

196
00:08:52,480 --> 00:08:55,120
而读性能呢它是线性增加的 

197
00:08:55,160 --> 00:08:56,480
具体怎么做呢

198
00:08:56,520 --> 00:08:59,440
这有两个物理的硬盘

199
00:08:59,480 --> 00:09:01,880
我们把它划成分区

200
00:09:01,920 --> 00:09:03,800
然后把我数据呢

201
00:09:03,840 --> 00:09:05,560
同时存在这两个上头

202
00:09:05,600 --> 00:09:09,360
这时候写的性能呢是跟原来一样的

203
00:09:09,400 --> 00:09:13,040
然后读的性能呢是会提高的

204
00:09:13,080 --> 00:09:15,120
如果你读很多数据的话 

205
00:09:15,160 --> 00:09:17,840
这是磁盘镜像 它的主要特征

206
00:09:17,880 --> 00:09:20,360
是提高可靠性

207
00:09:20,400 --> 00:09:21,760
然后接下来一个呢

208
00:09:21,800 --> 00:09:24,560
是带校验的磁盘条带化

209
00:09:24,600 --> 00:09:26,680
这是我们这里的raid4

210
00:09:26,720 --> 00:09:27,880
它的做法是

211
00:09:27,920 --> 00:09:29,560
把数据块做条带化

212
00:09:29,600 --> 00:09:32,760
并且加了一个校验磁盘

213
00:09:32,800 --> 00:09:33,800
这个校验磁盘呢

214
00:09:33,840 --> 00:09:35,480
专门用来存校验和

215
00:09:35,520 --> 00:09:37,560
这时候你的存储容量

216
00:09:37,600 --> 00:09:39,920
是没有条带化那么高的

217
00:09:39,960 --> 00:09:42,240
但是它的可靠性呢是提高了

218
00:09:42,280 --> 00:09:44,640
也就说N个磁盘的话

219
00:09:44,680 --> 00:09:46,640
它其中有一个错误的时候

220
00:09:46,680 --> 00:09:48,440
它是可以恢复过来的

221
00:09:48,480 --> 00:09:52,920
它允许任意一个故障磁盘出问题的时候

222
00:09:52,960 --> 00:09:55,960
它可以从里头能把数据完整恢复出来

223
00:09:56,000 --> 00:09:57,880
那它具体怎么做呢

224
00:09:57,920 --> 00:10:01,520
假定我这儿有五个磁盘

225
00:10:01,560 --> 00:10:05,760
那我用来存数据采用条带化呢是前面四个

226
00:10:05,800 --> 00:10:11,320
最后一个来存它的校验和

227
00:10:11,360 --> 00:10:12,720
在存校验和的时候呢

228
00:10:12,760 --> 00:10:15,040
我需要依据前面四个数据

229
00:10:15,080 --> 00:10:16,960
来算这个校验和 

230
00:10:17,000 --> 00:10:18,360
这是我存的里头

231
00:10:18,400 --> 00:10:19,680
如果我读数据的时候

232
00:10:19,720 --> 00:10:22,000
我需要把它们全部一块读出来

233
00:10:22,040 --> 00:10:24,440
然后去判断它是否正确

234
00:10:24,480 --> 00:10:25,520
任何一个有错

235
00:10:25,560 --> 00:10:27,880
我可以从这里把它恢复回来

236
00:10:27,920 --> 00:10:30,400
这样的话就提高了它的可靠性

237
00:10:30,440 --> 00:10:33,520
也提高了它的读写性能 

238
00:10:33,560 --> 00:10:35,320
当然这里的可靠性是说

239
00:10:35,360 --> 00:10:38,280
没有我们刚才这个镜像

240
00:10:38,320 --> 00:10:40,160
可靠性提高那么高

241
00:10:40,200 --> 00:10:41,680
那我在这里头N个磁盘里

242
00:10:41,720 --> 00:10:43,840
N分之一可能性它坏掉

243
00:10:43,880 --> 00:10:44,880
那我是能恢复的

244
00:10:44,920 --> 00:10:47,280
如果更多那它就不行了 

245
00:10:47,320 --> 00:10:48,240
再有一个呢

246
00:10:48,280 --> 00:10:52,400
是带分布式校验的磁盘条带化

247
00:10:52,440 --> 00:10:54,640
这种做法呢和raid4相比呢

248
00:10:54,680 --> 00:11:00,480
它就是把校验和的存放位置 做了一个分布

249
00:11:00,520 --> 00:11:03,760
不是把校验和固定的存在校验磁盘上

250
00:11:03,800 --> 00:11:05,120
这样的做法呢

251
00:11:05,160 --> 00:11:08,400
可以把校验磁盘的访问瓶颈呢分摊开

252
00:11:08,440 --> 00:11:10,280
从而提高它的性能 

253
00:11:10,320 --> 00:11:11,840
那我们看具体怎么做

254
00:11:11,880 --> 00:11:16,600
我们把每一个数据块分散到这5个磁盘上

255
00:11:16,640 --> 00:11:19,000
第一个X  它的校验和呢

256
00:11:19,040 --> 00:11:20,920
假定我们说它是在5号磁盘上

257
00:11:20,960 --> 00:11:22,200
最后一个

258
00:11:22,240 --> 00:11:23,720
然后下一个时候的呢

259
00:11:23,760 --> 00:11:25,760
它的校验和就不存在这5上了

260
00:11:25,800 --> 00:11:29,160
而是存在1上 这是第二个 

261
00:11:29,200 --> 00:11:31,160
第三个时候呢

262
00:11:31,200 --> 00:11:33,400
我再放到第2个磁盘

263
00:11:33,440 --> 00:11:36,040
第四个时候呢再放到第3个（磁盘上）

264
00:11:36,080 --> 00:11:37,000
那这样的话

265
00:11:37,040 --> 00:11:39,000
我们在每次读写的时候呢

266
00:11:39,040 --> 00:11:41,800
这个校验和的这种依赖

267
00:11:41,840 --> 00:11:44,080
也就变得分散开去了

268
00:11:44,120 --> 00:11:45,960
从而这样的话就可以减少

269
00:11:46,000 --> 00:11:52,000
它对校验和所在那个磁盘的读写压力

270
00:11:52,040 --> 00:11:55,000
这是我们说到的几种Raid技术

271
00:11:55,040 --> 00:11:59,480
用来提高它的读写性能和它的可靠性 

272
00:11:59,520 --> 00:12:04,640
这些技术呢我们都是基于数据块的

273
00:12:04,680 --> 00:12:07,200
实际上它也可以基于字节

274
00:12:07,240 --> 00:12:09,640
或者基于比特位

275
00:12:09,680 --> 00:12:11,320
这种做法呢 实际上相当于

276
00:12:11,360 --> 00:12:13,520
我们这里raid0 4 5

277
00:12:13,560 --> 00:12:15,600
就我们刚才说都是基于数据块的

278
00:12:15,640 --> 00:12:17,440
raid3呢是基于位的

279
00:12:17,480 --> 00:12:21,760
那这种做法它实际上区别在什么地方呢

280
00:12:21,800 --> 00:12:23,280
假定我有三个磁盘

281
00:12:23,320 --> 00:12:25,680
它做校验怎么办

282
00:12:25,720 --> 00:12:27,360
这是基于每一块里的

283
00:12:27,400 --> 00:12:30,880
每一位组合到一起来使用的

284
00:12:30,920 --> 00:12:32,840
当然现在我们在实际系统里

285
00:12:32,880 --> 00:12:36,200
用最多的还是基于数据块的

286
00:12:36,240 --> 00:12:42,000
这是基于字节和位的磁盘冗余技术 

287
00:12:42,040 --> 00:12:43,880
我们还可以再进一步扩展

288
00:12:43,920 --> 00:12:46,920
raid5可以恢复一个磁盘的错误

289
00:12:46,960 --> 00:12:48,640
那如果有多个呢

290
00:12:48,680 --> 00:12:50,920
实际上我们在这里呢有raid6

291
00:12:50,960 --> 00:12:53,120
它增加了两个冗余块

292
00:12:53,160 --> 00:12:54,760
那这样的话我可以允许呢

293
00:12:54,800 --> 00:12:56,280
有两个磁盘出错的时候

294
00:12:56,320 --> 00:12:58,200
它也是可以恢复的

295
00:12:58,240 --> 00:13:00,440
这样的话就进一步提高它的可靠性

296
00:13:00,480 --> 00:13:02,360
当然这种可靠性到底提了多少

297
00:13:02,400 --> 00:13:04,440
要跟你数据重要性和

298
00:13:04,480 --> 00:13:08,120
你对可靠性的要求的不同而不同 

299
00:13:08,160 --> 00:13:10,720
与此同时我们这些技术呢

300
00:13:10,760 --> 00:13:13,480
也允许把它嵌套到一起来使用

301
00:13:13,520 --> 00:13:17,640
比如说我们raid0是提高它的性能

302
00:13:17,680 --> 00:13:20,520
而raid1可以提高它的可靠性

303
00:13:20,560 --> 00:13:21,760
那这时候我是不是可以

304
00:13:21,800 --> 00:13:23,560
在提高性能的同时

305
00:13:23,600 --> 00:13:25,080
提高它的可靠性呢

306
00:13:25,120 --> 00:13:27,000
那这时候就把这两个组合起来

307
00:13:27,040 --> 00:13:28,920
那是raid0+1

308
00:13:28,960 --> 00:13:32,040
首先是两个磁盘之间做条带化

309
00:13:32,080 --> 00:13:34,320
这时候呢你往里读写的时候

310
00:13:34,360 --> 00:13:36,800
它的性能会提高

311
00:13:36,840 --> 00:13:42,240
然后在这基础上我再做一个磁盘镜像

312
00:13:42,280 --> 00:13:44,400
这一组和这一组之间做镜像

313
00:13:44,440 --> 00:13:45,880
那么这时候可靠性提高了

314
00:13:45,920 --> 00:13:47,320
当然我们在这里头呢

315
00:13:47,360 --> 00:13:50,600
以用这种办法来提高性能和可靠性

316
00:13:50,640 --> 00:13:52,760
它的成本也是大幅度增加的

317
00:13:52,800 --> 00:13:54,200
所以这是这上头呢

318
00:13:54,240 --> 00:13:56,560
再把它搁在一起变成raid1

319
00:13:56,600 --> 00:13:58,800
组合到一起是raid嵌套

320
00:13:58,840 --> 00:14:01,840
这个嵌套也可以反过来

321
00:14:01,880 --> 00:14:05,360
底下是raid1我先做镜像

322
00:14:05,400 --> 00:14:09,800
然后在这里头呢在上面再套一层raid0

323
00:14:09,840 --> 00:14:12,000
我往两个里头呢同时写

324
00:14:12,040 --> 00:14:15,560
这样的话也是可以起到类似的效果

325
00:14:15,600 --> 00:14:17,040
通过这一系列的技术呢

326
00:14:17,080 --> 00:14:20,080
我们可以在文件系统基础上

327
00:14:20,120 --> 00:14:24,040
来不断提高它的性能和可靠性 

328
00:14:24,080 --> 00:14:27,480
这是我们今天说到的文件系统

329
00:14:27,520 --> 00:14:29,240
今天的课就上到这里  下课 

330
00:14:29,280 --> 00:14:29,320
    

