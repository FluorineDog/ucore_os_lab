0
00:00:00,000 --> 00:00:07,480


1
00:00:07,520 --> 00:00:10,880
下面我们来讨论文件分配

2
00:00:10,920 --> 00:00:14,400
文件分配是指我们把哪些块

3
00:00:14,440 --> 00:00:18,720
分配给一个文件来存它的数据

4
00:00:18,760 --> 00:00:21,640
在具体讨论分配方法之前呢

5
00:00:21,680 --> 00:00:25,640
我们有必要来分析一下文件的大小

6
00:00:25,680 --> 00:00:27,960
也就是说我分配的方法

7
00:00:28,000 --> 00:00:32,280
跟文件的大小是有直接关系的

8
00:00:32,320 --> 00:00:33,520
那首先我们来看

9
00:00:33,560 --> 00:00:35,600
文件大小的分布情况

10
00:00:35,640 --> 00:00:38,400
在我们现在想象里头

11
00:00:38,440 --> 00:00:40,120
或者说 在我们现在

12
00:00:40,160 --> 00:00:41,840
实际数据统计里头

13
00:00:41,880 --> 00:00:43,440
可以发现这样一些情况

14
00:00:43,480 --> 00:00:46,760
就是大多数的文件都是很小的

15
00:00:46,800 --> 00:00:49,400
所以在我们的分配方法里头呢

16
00:00:49,440 --> 00:00:52,520
那个数据块的大小不能太大

17
00:00:52,560 --> 00:00:54,760
因为如果说你的大部分数据

18
00:00:54,800 --> 00:00:57,320
放到一块里有很大的剩余的话

19
00:00:57,360 --> 00:00:58,680
那么这时候呢

20
00:00:58,720 --> 00:01:01,080
它的存储效率是比较低的

21
00:01:01,120 --> 00:01:02,400
所以我们在这儿呢

22
00:01:02,440 --> 00:01:06,160
需要对小文件提供很好的支持

23
00:01:06,200 --> 00:01:09,080
当然这个文件小呢实际上也是相对的

24
00:01:09,120 --> 00:01:12,600
比如说在我们用计算机早期

25
00:01:12,640 --> 00:01:14,920
我的数据呢 你比如说像邮件

26
00:01:14,960 --> 00:01:17,760
通常情况下就是几百个字节

27
00:01:17,800 --> 00:01:20,240
几千个字节就已经算是比较少的了

28
00:01:20,280 --> 00:01:21,880
但是现在的邮件呢

29
00:01:21,920 --> 00:01:25,040
实际上我们上头有一图片签名

30
00:01:25,080 --> 00:01:27,360
这一下子就是多少K出去了

31
00:01:27,400 --> 00:01:30,240
所以这个大小呢也是一种相对的

32
00:01:30,280 --> 00:01:32,120
并且随着时间的变化

33
00:01:32,160 --> 00:01:34,760
和应用的变化而不同

34
00:01:34,800 --> 00:01:38,480
与此同时我们还有一些非常大的文件

35
00:01:38,520 --> 00:01:40,400
所以在我们分配办法里头呢

36
00:01:40,440 --> 00:01:43,680
必须考虑到如何能支持这些大的文件

37
00:01:43,720 --> 00:01:47,440
比如说我们来描述

38
00:01:47,480 --> 00:01:51,400
分配给一个文件的数据块有多少个

39
00:01:51,440 --> 00:01:53,400
那这时候呢你有一个标识

40
00:01:53,440 --> 00:01:55,800
这个标识呢比如说用个整数来表示

41
00:01:55,840 --> 00:01:57,040
整数有多少位

42
00:01:57,080 --> 00:01:58,200
就跟你这儿能表示的

43
00:01:58,240 --> 00:02:01,560
最大个的文件的大小是直接相关的

44
00:02:01,600 --> 00:02:03,600
如果说你不足以表示

45
00:02:03,640 --> 00:02:07,040
实际用到的最大文件的大小

46
00:02:07,080 --> 00:02:10,360
那么你这个文件系统就没法来使用了

47
00:02:10,400 --> 00:02:13,640
所以我们需要对大文件有很好的支持

48
00:02:13,680 --> 00:02:16,280
要考虑到这个文件可能会比较大

49
00:02:16,320 --> 00:02:17,280
比如说像我们现在

50
00:02:17,320 --> 00:02:19,200
看到的一张光盘映像

51
00:02:19,240 --> 00:02:21,200
这个映像文件通常是几个G

52
00:02:21,240 --> 00:02:23,280
如果说我是一个虚拟机的镜像

53
00:02:23,320 --> 00:02:24,400
那这个镜像

54
00:02:24,440 --> 00:02:26,600
可能会是几十个G或者更多了

55
00:02:26,640 --> 00:02:30,160
那对于这种情况呢我们也需要做考虑

56
00:02:30,200 --> 00:02:32,560
所以针对这种文件大小的分布呢

57
00:02:32,600 --> 00:02:36,520
我们来看如何来进行文件分配

58
00:02:36,560 --> 00:02:37,880
分配是指说

59
00:02:37,920 --> 00:02:41,400
我把哪些数据块给一个文件

60
00:02:41,440 --> 00:02:43,480
但实际上这种分配的办法呢

61
00:02:43,520 --> 00:02:45,280
它背后的本质实际上是

62
00:02:45,320 --> 00:02:47,800
用什么样的方法来表示

63
00:02:47,840 --> 00:02:50,600
一个文件的数据块的位置和顺序

64
00:02:50,640 --> 00:02:53,240
因为这个位置和顺序的表示方法

65
00:02:53,280 --> 00:02:56,120
直接决定着你如何来分配

66
00:02:56,160 --> 00:02:58,640
那我们看有怎样一些分配方法

67
00:02:58,680 --> 00:03:01,520
这些分配方法呢在这儿

68
00:03:01,560 --> 00:03:03,000
一个是连续分配

69
00:03:03,040 --> 00:03:04,920
我分配一个起点

70
00:03:04,960 --> 00:03:07,440
然后连续的若干个数据块

71
00:03:07,480 --> 00:03:09,000
用来存在这个文件

72
00:03:09,040 --> 00:03:11,760
也可以用链式分配

73
00:03:11,800 --> 00:03:14,040
我告诉你在第一块里记第二块的位置

74
00:03:14,080 --> 00:03:16,800
一直到最后一块

75
00:03:16,840 --> 00:03:19,160
也可以采用索引分配

76
00:03:19,200 --> 00:03:21,560
我分配一块里头专门用来存序号

77
00:03:21,600 --> 00:03:25,200
说我这里都有哪些块存了数据

78
00:03:25,240 --> 00:03:27,200
这些块的顺序是啥样子

79
00:03:27,240 --> 00:03:29,280
这是几种常见的办法

80
00:03:29,320 --> 00:03:31,480
这几种办法呢

81
00:03:31,520 --> 00:03:32,800
我们在选择的时候

82
00:03:32,840 --> 00:03:35,640
考虑的因素呢一个是存储效率

83
00:03:35,680 --> 00:03:37,560
一个是读写性能

84
00:03:37,600 --> 00:03:39,120
存储效率呢是说

85
00:03:39,160 --> 00:03:41,240
我每次分配的最小单位是一块

86
00:03:41,280 --> 00:03:44,680
所以内碎片我们就没办法进行处理了

87
00:03:44,720 --> 00:03:46,840
我们在这里能做的处理就是

88
00:03:46,880 --> 00:03:50,320
你在选择数据块大小的时候做些考虑

89
00:03:50,360 --> 00:03:52,800
假定这个问题我们忽略

90
00:03:52,840 --> 00:03:55,160
我们来看外碎片

91
00:03:55,200 --> 00:03:56,920
也就相当于如果我是连续分配

92
00:03:56,960 --> 00:03:58,600
中间块数不够的时候

93
00:03:58,640 --> 00:04:00,360
你想表示大文件就是不行的

94
00:04:00,400 --> 00:04:01,360
所以在这儿呢

95
00:04:01,400 --> 00:04:05,440
你的选择算法有存储效率的问题

96
00:04:05,480 --> 00:04:07,240
当然我们说后两种算法

97
00:04:07,280 --> 00:04:08,840
它就没有外碎片

98
00:04:08,880 --> 00:04:10,400
所以这个问题就没有了

99
00:04:10,440 --> 00:04:12,880
但是它有后面的问题

100
00:04:12,920 --> 00:04:14,320
读写性能问题

101
00:04:14,360 --> 00:04:16,480
说如果我是顺序分配

102
00:04:16,520 --> 00:04:17,760
那我知道起点

103
00:04:17,800 --> 00:04:19,800
然后我就按照序号往下算

104
00:04:19,840 --> 00:04:20,760
我就能知道

105
00:04:20,800 --> 00:04:22,800
我要访问的任何一个位置在哪

106
00:04:22,840 --> 00:04:27,800
这样的话我的随机读取的速度会很快

107
00:04:27,840 --> 00:04:30,520
但是如果说你是链式分配的话

108
00:04:30,560 --> 00:04:33,560
那么这时候我要想找中间某一块

109
00:04:33,600 --> 00:04:35,800
我必须从头往后去找

110
00:04:35,840 --> 00:04:37,280
去遍历这个链表

111
00:04:37,320 --> 00:04:40,800
那这时候呢它的读写性能就会比较差

112
00:04:40,840 --> 00:04:43,160
这些都是我们在这里讨论

113
00:04:43,200 --> 00:04:47,680
文件分配的时候必须考虑的指标

114
00:04:47,720 --> 00:04:50,320
那我们对三种分配办法呢

115
00:04:50,360 --> 00:04:51,800
做一个简要的描述

116
00:04:51,840 --> 00:04:54,720
首先是连续分配

117
00:04:54,760 --> 00:04:57,440
连续分配呢是在文件头也就是

118
00:04:57,480 --> 00:05:00,680
我们所说的文件控制块里头呢

119
00:05:00,720 --> 00:05:04,240
记录起始第一块的位置和长度

120
00:05:04,280 --> 00:05:05,360
因为我是连续的

121
00:05:05,400 --> 00:05:07,400
所以我知道第一块和长度之后

122
00:05:07,440 --> 00:05:11,040
那么能说清楚每一块这个文件分配的

123
00:05:11,080 --> 00:05:13,520
所有的块都在什么位置

124
00:05:13,560 --> 00:05:15,240
我们用一个图示来表示

125
00:05:15,280 --> 00:05:17,120
这就是你的索引结点

126
00:05:17,160 --> 00:05:18,680
也就说文件控制块

127
00:05:18,720 --> 00:05:20,280
里头有一个指针指向第一块

128
00:05:20,320 --> 00:05:23,200
并且里头记录了它的长度在这儿

129
00:05:23,240 --> 00:05:24,800
就从这儿到这儿

130
00:05:24,840 --> 00:05:28,960
这是我的一个文件所占用的数据块

131
00:05:29,000 --> 00:05:30,840
那在这里头我怎么去找

132
00:05:30,880 --> 00:05:32,960
这个连续的这块区域呢

133
00:05:33,000 --> 00:05:34,680
最先匹配 最佳匹配

134
00:05:34,720 --> 00:05:36,920
我们在前面跟内存分配

135
00:05:36,960 --> 00:05:38,360
也有类似的讨论

136
00:05:38,400 --> 00:05:40,760
那些讨论的特征在这儿

137
00:05:40,800 --> 00:05:42,320
都有一定程度的体现

138
00:05:42,360 --> 00:05:44,520
在这儿我们就不仔细去讨论了

139
00:05:44,560 --> 00:05:46,800
这些做法它的特点有什么样呢

140
00:05:46,840 --> 00:05:49,360
文件的读取性能表现非常好

141
00:05:49,400 --> 00:05:51,120
也可以有很好的顺序

142
00:05:51,160 --> 00:05:52,920
和随机读取的性能

143
00:05:52,960 --> 00:05:54,800
它的麻烦是什么

144
00:05:54,840 --> 00:05:55,880
它的麻烦是碎片

145
00:05:55,920 --> 00:05:58,840
我想分配十块结果现在就剩五块了

146
00:05:58,880 --> 00:06:00,320
那这五块没法用了

147
00:06:00,360 --> 00:06:02,120
如果说我在这里头碎片很多

148
00:06:02,160 --> 00:06:02,920
实际上这时候

149
00:06:02,960 --> 00:06:04,920
它的存储效率会比较差的

150
00:06:04,960 --> 00:06:06,240
再有一个问题

151
00:06:06,280 --> 00:06:07,120
这是我们在前面

152
00:06:07,160 --> 00:06:09,040
内存分配里不太遇到的

153
00:06:09,080 --> 00:06:10,960
或者说不是很重要的问题

154
00:06:11,000 --> 00:06:14,160
就是文件长度的变化

155
00:06:14,200 --> 00:06:16,600
我减少长度这事还好说

156
00:06:16,640 --> 00:06:19,280
增加长度如果说分配的正好是这一块

157
00:06:19,320 --> 00:06:20,440
你给它增加

158
00:06:20,480 --> 00:06:23,800
那后面块已经被其它文件占用了

159
00:06:23,840 --> 00:06:25,360
那这时候怎么办

160
00:06:25,400 --> 00:06:29,080
因为我们是持久数据保存

161
00:06:29,120 --> 00:06:30,320
那这个保存完之后

162
00:06:30,360 --> 00:06:32,960
这数据长度会增加这是极有可能的

163
00:06:33,000 --> 00:06:36,680
对于这个问题呢我们不能忽视

164
00:06:36,720 --> 00:06:38,080
那怎么办 在这里说到

165
00:06:38,120 --> 00:06:40,640
我可以后面预留几块

166
00:06:40,680 --> 00:06:43,480
还是说我分配的时候再把它整个搬

167
00:06:43,520 --> 00:06:44,720
所以从这个角度来讲呢

168
00:06:44,760 --> 00:06:48,800
这个长度发生变化 特别是增加

169
00:06:48,840 --> 00:06:52,320
对于它来说是一个比较棘手的事

170
00:06:52,360 --> 00:06:53,800
这是第一种做法

171
00:06:53,840 --> 00:06:56,360
接下来我们讨论第二种做法 链式分配

172
00:06:56,400 --> 00:06:58,240
链式分配呢是指说

173
00:06:58,280 --> 00:07:01,480
我用一个数据块的链表来表示

174
00:07:01,520 --> 00:07:05,480
在文件头里头有指向第一块的指针

175
00:07:05,520 --> 00:07:08,240
然后第一块有指向第二块的指针

176
00:07:08,280 --> 00:07:10,160
这时候呢顺序走下去

177
00:07:10,200 --> 00:07:11,600
同时呢在头里头呢

178
00:07:11,640 --> 00:07:14,080
再加上一个指向最后一块的指针

179
00:07:14,120 --> 00:07:17,320
这样一来我们就可以表示清楚

180
00:07:17,360 --> 00:07:20,080
一个文件所占用的数据块

181
00:07:20,120 --> 00:07:23,320
第一块是在哪 都占用哪些块

182
00:07:23,360 --> 00:07:25,760
它的这些块的顺序是什么样子

183
00:07:25,800 --> 00:07:28,160
这种做法它有什么样的特征呢

184
00:07:28,200 --> 00:07:30,920
优点是这时候说我在这里头

185
00:07:30,960 --> 00:07:33,560
增加删除占用的数据块

186
00:07:33,600 --> 00:07:35,400
这都会比较方便

187
00:07:35,440 --> 00:07:36,880
由于任何一个数据块我都可以

188
00:07:36,920 --> 00:07:39,200
插到这里头来所以它没有外碎片

189
00:07:39,240 --> 00:07:41,720
但是它有什么问题

190
00:07:41,760 --> 00:07:45,200
它没有办法很方便地实现随机访问

191
00:07:45,240 --> 00:07:47,920
我想找第一块最后一块

192
00:07:47,960 --> 00:07:50,960
那这是你是直接从文件控制块里头

193
00:07:51,000 --> 00:07:52,480
就可以找到的

194
00:07:52,520 --> 00:07:54,640
但是我想找中间这一块怎么办

195
00:07:54,680 --> 00:07:57,760
我只能找到第一块然后顺序往后找

196
00:07:57,800 --> 00:08:00,000
我才能找到后面这一块

197
00:08:00,040 --> 00:08:03,280
由于我是单向的链表

198
00:08:03,320 --> 00:08:06,000
我想找倒数第二块

199
00:08:06,040 --> 00:08:09,880
我只能从正着数的第一块一直找过去

200
00:08:09,920 --> 00:08:11,000
从这个角度来讲呢

201
00:08:11,040 --> 00:08:14,600
它的访问特征呢是比较差的

202
00:08:14,640 --> 00:08:17,680
再有一条呢是它的可靠性

203
00:08:17,720 --> 00:08:19,720
我们在这里存到磁盘上

204
00:08:19,760 --> 00:08:21,080
数据放一段时间之后

205
00:08:21,120 --> 00:08:22,840
或者说多次读写之后

206
00:08:22,880 --> 00:08:25,000
里头数据可能会出错的

207
00:08:25,040 --> 00:08:26,200
如果说我在这里头

208
00:08:26,240 --> 00:08:29,680
指向下一块这个指针出了错

209
00:08:29,720 --> 00:08:34,640
那么从这个指针往后的数据你就丢了

210
00:08:34,680 --> 00:08:36,040
所以从这个角度来讲呢

211
00:08:36,080 --> 00:08:38,840
它的可靠性是比较差的

212
00:08:38,880 --> 00:08:42,640
这是第二种做法 链式分配

213
00:08:42,680 --> 00:08:45,680
第三种做法呢是索引分配

214
00:08:45,720 --> 00:08:47,400
也就说为每一个文件

215
00:08:47,440 --> 00:08:49,360
创建一个索引数据块

216
00:08:49,400 --> 00:08:53,440
里头来存都有哪些数据块我存了数据

217
00:08:53,480 --> 00:08:58,320
这时候这是这个索引数据块里的内容

218
00:08:58,360 --> 00:09:01,960
是指向所有数据块的指针的列表

219
00:09:02,000 --> 00:09:04,840
然后在你文件头里头

220
00:09:04,880 --> 00:09:08,120
有一个指向索引数据块的指针

221
00:09:08,160 --> 00:09:08,920
那么这样的话

222
00:09:08,960 --> 00:09:12,240
从文件头就知道这个索引块在哪

223
00:09:12,280 --> 00:09:13,600
然后在索引块里呢

224
00:09:13,640 --> 00:09:16,200
我能知道每一块的位置

225
00:09:16,240 --> 00:09:17,840
和它们之间的顺序

226
00:09:17,880 --> 00:09:20,120
从这个角度来说

227
00:09:20,160 --> 00:09:21,800
这种做法好像不错

228
00:09:21,840 --> 00:09:23,120
这是它的图示

229
00:09:23,160 --> 00:09:26,720
我在文件头里指向索引块

230
00:09:26,760 --> 00:09:27,760
索引块里呢

231
00:09:27,800 --> 00:09:31,200
有每一块的序号和它们的顺序

232
00:09:31,240 --> 00:09:33,360
这时候说它的好处有什么

233
00:09:33,400 --> 00:09:37,160
创建 增加 缩小都比较容易

234
00:09:37,200 --> 00:09:39,440
然后也没有碎片

235
00:09:39,480 --> 00:09:41,120
你想直接访问哪一块呢

236
00:09:41,160 --> 00:09:44,240
我读到这一块索引块也就行了

237
00:09:44,280 --> 00:09:47,160
所以这样一来它也可以支持直接访问

238
00:09:47,200 --> 00:09:48,920
那它有什么缺点

239
00:09:48,960 --> 00:09:51,520
这时候说如果我的文件很小

240
00:09:51,560 --> 00:09:52,960
它一块就能存得下

241
00:09:53,000 --> 00:09:54,480
你还分配一个索引块

242
00:09:54,520 --> 00:09:57,040
那么这时候我又得要两块

243
00:09:57,080 --> 00:10:00,520
这时候呢它的存储开销是很大的

244
00:10:00,560 --> 00:10:03,320
这是文件比较小的时候

245
00:10:03,360 --> 00:10:05,760
如果文件比较大呢 大到什么程度

246
00:10:05,800 --> 00:10:08,720
大到我索引块里存的这些序号

247
00:10:08,760 --> 00:10:10,520
它也用一块存不下了

248
00:10:10,560 --> 00:10:11,360
那这时候呢

249
00:10:11,400 --> 00:10:15,160
我这地方就得再加索引块

250
00:10:15,200 --> 00:10:16,400
如果说你在你这里头

251
00:10:16,440 --> 00:10:18,880
不支持加多个索引块的话

252
00:10:18,920 --> 00:10:19,560
那么这时候

253
00:10:19,600 --> 00:10:22,760
对大文件的表示呢也会有麻烦

254
00:10:22,800 --> 00:10:24,800
所以这是我们这几种办法呢

255
00:10:24,840 --> 00:10:25,600
我们看下来

256
00:10:25,640 --> 00:10:28,600
它都各自有各自的优点和缺点

257
00:10:28,640 --> 00:10:30,040
那在实际用的时候呢

258
00:10:30,080 --> 00:10:31,520
我们基本上会把这几种呢

259
00:10:31,560 --> 00:10:33,120
组合到一起来用

260
00:10:33,160 --> 00:10:36,160
那这时候对于大个的索引文件呢

261
00:10:36,200 --> 00:10:37,760
我们又可以在这里呢

262
00:10:37,800 --> 00:10:40,920
再往下组合新的方式

263
00:10:40,960 --> 00:10:42,160
链式索引块

264
00:10:42,200 --> 00:10:45,040
也就是各个索引块之间它怎么来组织

265
00:10:45,080 --> 00:10:47,480
总体上来说它是索引分配方法

266
00:10:47,520 --> 00:10:49,400
指向这里的块

267
00:10:49,440 --> 00:10:51,320
然后这地方是索引块

268
00:10:51,360 --> 00:10:53,000
索引块之间呢我用一个链式

269
00:10:53,040 --> 00:10:55,800
或者索引块之间呢再做一个索引

270
00:10:55,840 --> 00:10:59,240
这就变成了多级索引块

271
00:10:59,280 --> 00:11:04,720
这是对大文件的表示方法

272
00:11:04,760 --> 00:11:05,520
我们下面呢

273
00:11:05,560 --> 00:11:08,960
来看一个实际的索引分配方法

274
00:11:09,000 --> 00:11:10,480
看它怎么做的

275
00:11:10,520 --> 00:11:12,120
怎么来把我们前面说到的

276
00:11:12,160 --> 00:11:14,800
各种算法的优点集中到一起

277
00:11:14,840 --> 00:11:17,080
把缺点都去掉

278
00:11:17,120 --> 00:11:21,400
这就是我们这里的UFS的多级索引分配

279
00:11:21,440 --> 00:11:24,960
UFS是unix file system

280
00:11:25,000 --> 00:11:26,400
unix文件系统

281
00:11:26,440 --> 00:11:27,560
它的做法是什么呢

282
00:11:27,600 --> 00:11:30,400
在这个文件控制块里头

283
00:11:30,440 --> 00:11:33,720
我前面10个是直接索引

284
00:11:33,760 --> 00:11:36,160
你直接这10块的位置都标在这里头

285
00:11:36,200 --> 00:11:38,760
如果说你存的数据比较少

286
00:11:38,800 --> 00:11:40,280
只有10块以内

287
00:11:40,320 --> 00:11:44,360
我就索引直接到文件对应的数据块

288
00:11:44,400 --> 00:11:46,000
如果说大于10块

289
00:11:46,040 --> 00:11:48,680
那这时候呢我第11个指针呢

290
00:11:48,720 --> 00:11:52,720
写的是一个一级间接索引

291
00:11:52,760 --> 00:11:55,520
那在这儿呢 它指向一个索引块

292
00:11:55,560 --> 00:11:57,040
这个索引块里头呢

293
00:11:57,080 --> 00:11:58,800
再指向实际的数据块

294
00:11:58,840 --> 00:12:00,640
这是一个间接索引

295
00:12:00,680 --> 00:12:02,480
这时候我在间接索引块里

296
00:12:02,520 --> 00:12:07,240
能放多少个序号呢 假定说能放N个

297
00:12:07,280 --> 00:12:10,120
根据你每一个序号所占用的空间不同

298
00:12:10,160 --> 00:12:14,360
和你块的大小呢这个地方是不一样的

299
00:12:14,400 --> 00:12:16,120
有了一级索引

300
00:12:16,160 --> 00:12:19,360
那这时候我只需要11个指针在前面

301
00:12:19,400 --> 00:12:22,680
如果说你仍然加一个一级索引

302
00:12:22,720 --> 00:12:26,040
和前面十块加在一起还不够用 怎么办呢

303
00:12:26,080 --> 00:12:28,440
不是我在这里再给你加一个一级索引

304
00:12:28,480 --> 00:12:31,280
它是加一个二级索引

305
00:12:31,320 --> 00:12:34,920
这是索引块的索引 这是二级索引

306
00:12:34,960 --> 00:12:37,200
那么只要你大到一定程度之后

307
00:12:37,240 --> 00:12:38,720
我就不再采用一级索引了

308
00:12:38,760 --> 00:12:40,080
我采用二级索引

309
00:12:40,120 --> 00:12:44,440
那二级索引如果仍然不够用怎么办呢

310
00:12:44,480 --> 00:12:47,800
它会再加一级 三级索引

311
00:12:47,840 --> 00:12:49,560
相当于这是索引块 

312
00:12:49,600 --> 00:12:53,880
然后这是一级索引

313
00:12:53,920 --> 00:12:55,960
然后这是二级索引

314
00:12:56,000 --> 00:12:57,840
那这时候我们看到后面这一块的话

315
00:12:57,880 --> 00:13:00,320
你要想访问到实际的数据块

316
00:13:00,360 --> 00:13:03,840
它前面是有大量要查询的

317
00:13:03,880 --> 00:13:07,720
这是我们多级索引它所面临的麻烦

318
00:13:07,760 --> 00:13:10,200
但是把这几个搁到一个实际系统里头

319
00:13:10,240 --> 00:13:11,320
我们就看到

320
00:13:11,360 --> 00:13:14,640
它表示文件的大小比较小的时候

321
00:13:14,680 --> 00:13:18,160
它的效率呢是直接索引

322
00:13:18,200 --> 00:13:19,600
文件比较大的时候呢

323
00:13:19,640 --> 00:13:21,200
它也能表示

324
00:13:21,240 --> 00:13:23,920
当然这个效率它是会有一定下降的

325
00:13:23,960 --> 00:13:25,680
我们看到在这里头呢

326
00:13:25,720 --> 00:13:28,360
这就把前面讲的几种办法呢

327
00:13:28,400 --> 00:13:30,240
很好地组合到一起

328
00:13:30,280 --> 00:13:34,960
从而呢变成一个实际的索引分配方案

329
00:13:35,000 --> 00:13:38,600
这是我们用一个实际的例子来说情况

330
00:13:38,640 --> 00:13:41,040
说10个然后在这里呢

331
00:13:41,080 --> 00:13:44,280
文件控制块里呢只有13个指针

332
00:13:44,320 --> 00:13:47,400
那下面我们看一下它所带来的效果

333
00:13:47,440 --> 00:13:50,760
这时候对于文件大小的限制

334
00:13:50,800 --> 00:13:52,280
我由于有三级索引

335
00:13:52,320 --> 00:13:54,600
那我可以表示很大的文件

336
00:13:54,640 --> 00:13:55,520
具体有多大

337
00:13:55,560 --> 00:13:58,480
我们会在练习里来进行计算

338
00:13:58,520 --> 00:14:02,280
然后说我对于动态分配

339
00:14:02,320 --> 00:14:05,560
我增加缩小都比较容易

340
00:14:05,600 --> 00:14:09,200
那这是索引分配方案的好处

341
00:14:09,240 --> 00:14:11,840
然后我对付小文件呢

342
00:14:11,880 --> 00:14:13,520
它的开销也比较小

343
00:14:13,560 --> 00:14:16,920
因为我直接在控制块里头

344
00:14:16,960 --> 00:14:20,440
填这个数据块的序号

345
00:14:20,480 --> 00:14:23,640
而对于大文件来说呢

346
00:14:23,680 --> 00:14:25,360
我使用间接索引

347
00:14:25,400 --> 00:14:27,280
所以这样它也能表示大文件

348
00:14:27,320 --> 00:14:31,040
只是说它的查询速度呢会有所下降

349
00:14:31,080 --> 00:14:33,400
到这个地方呢

350
00:14:33,440 --> 00:14:36,840
我们就把文件分配的几种方法呢

351
00:14:36,880 --> 00:14:38,640
有了一个大致的介绍

352
00:14:38,680 --> 00:14:41,320
也说明了它们各自的

353
00:14:41,360 --> 00:14:42,920
适用场景和优缺点

354
00:14:42,960 --> 00:14:43,000


