0
00:00:00,000 --> 00:00:06,400


1
00:00:06,440 --> 00:00:09,880
接下来我们讲操作系统的演变

2
00:00:09,920 --> 00:00:12,800
也就是说在历史上操作系统的技术

3
00:00:12,840 --> 00:00:15,360
它到底有些什么样的变化

4
00:00:15,400 --> 00:00:18,200
那么对于操作系统来说

5
00:00:18,240 --> 00:00:23,240
它主要的功能是在用户态和硬件之间

6
00:00:23,280 --> 00:00:27,480
做一个中间的协调和抽象

7
00:00:27,520 --> 00:00:29,040
然后是使得

8
00:00:29,080 --> 00:00:32,960
用户可以很方便的使用硬件的资源

9
00:00:33,000 --> 00:00:35,800
和操作系统里面的软件资源

10
00:00:35,840 --> 00:00:38,240
那么从这个道理上来讲

11
00:00:38,280 --> 00:00:40,800
这个中间的变化做成以后

12
00:00:40,840 --> 00:00:42,280
应该没有什么变化了

13
00:00:42,320 --> 00:00:43,240
但是实际上我们说

14
00:00:43,280 --> 00:00:45,600
操作系统的变化非常巨大的

15
00:00:45,640 --> 00:00:47,840
原因在于在过去

16
00:00:47,880 --> 00:00:51,520
操作系统发展的半个世纪的历史当中

17
00:00:51,560 --> 00:00:53,080
技术上有非常大的变化

18
00:00:53,120 --> 00:00:55,120
我们在这里举一个例子

19
00:00:55,160 --> 00:00:58,720
说从80年代个人计算机出现

20
00:00:58,760 --> 00:01:02,840
到2012年操作系统硬件技术

21
00:01:02,880 --> 00:01:04,520
有一些什么样的变化

22
00:01:04,560 --> 00:01:06,480
从这张表里我们可以看到

23
00:01:06,520 --> 00:01:08,680
计算机系统里的价格

24
00:01:08,720 --> 00:01:10,360
基本没有明显的变化

25
00:01:10,400 --> 00:01:13,240
我们先不考虑物价上涨之类的因素

26
00:01:13,280 --> 00:01:16,920
基本是在几千美元的尺度

27
00:01:16,960 --> 00:01:19,400
但是我们看一下计算机系统当中

28
00:01:19,440 --> 00:01:21,520
各个部分之间的变化

29
00:01:21,560 --> 00:01:22,880
就是非常巨大的

30
00:01:22,920 --> 00:01:26,000
我们从这里可以看出来CPU的速度

31
00:01:26,040 --> 00:01:32,040
从4M到3G基本上M到G

32
00:01:32,080 --> 00:01:35,720
基本增加了几百倍到1千倍的尺度

33
00:01:35,760 --> 00:01:42,360
而处理能力从0.3个MIPS到12年的76个MIPS

34
00:01:42,400 --> 00:01:44,680
基本上涨了200倍

35
00:01:44,720 --> 00:01:48,040
而存储能力变化是最大的部分

36
00:01:48,080 --> 00:01:50,400
从最早的内存从64K

37
00:01:50,440 --> 00:01:54,400
到8个G应该是涨了几十万倍

38
00:01:54,440 --> 00:01:56,240
而几十万倍的话

39
00:01:56,280 --> 00:01:59,400
从硬盘的存储能量也是类似的

40
00:01:59,440 --> 00:02:01,240
这种变化对于我们来说

41
00:02:01,280 --> 00:02:04,280
到底计算机技术里有什么样的区别呢

42
00:02:04,320 --> 00:02:05,720
大家可以想象一下

43
00:02:05,760 --> 00:02:08,200
早的时候有可能我一个文件

44
00:02:08,240 --> 00:02:11,720
从文本就是几百个字节

45
00:02:11,760 --> 00:02:12,840
几千个字节

46
00:02:12,880 --> 00:02:15,240
现在我们存的一个视频文件

47
00:02:15,280 --> 00:02:18,120
动不动几个G了

48
00:02:18,160 --> 00:02:20,800
这种变化实际上对操作系统来说

49
00:02:20,840 --> 00:02:24,080
它有至关重要的影响

50
00:02:24,120 --> 00:02:26,280
实际上在操作系统的发展历史上

51
00:02:26,320 --> 00:02:29,120
它从最简单的单用户系统

52
00:02:29,160 --> 00:02:31,000
就是说我们能让一个用户

53
00:02:31,040 --> 00:02:32,960
能够用计算机的资源

54
00:02:33,000 --> 00:02:36,760
能够算它的作业这就是它的目的了

55
00:02:36,800 --> 00:02:38,680
然后有了这个目的之后

56
00:02:38,720 --> 00:02:41,240
我计算机系统这个系统太贵了

57
00:02:41,280 --> 00:02:41,800
好 这个时候

58
00:02:41,840 --> 00:02:44,000
我能不能提高它的利用效率

59
00:02:44,040 --> 00:02:46,600
提高利用效率就是批处理系统

60
00:02:46,640 --> 00:02:49,040
和多道系统要干的事

61
00:02:49,080 --> 00:02:53,040
等到效率能提高一定程度以后

62
00:02:53,080 --> 00:02:56,120
如果说我在这里排作业算的时候

63
00:02:56,160 --> 00:02:59,680
我排到前面一个用户算的时间很长

64
00:02:59,720 --> 00:03:01,080
我在后面要等很长的时间

65
00:03:01,120 --> 00:03:01,880
这个时候怎么弄

66
00:03:01,920 --> 00:03:04,280
这个时候我们这个分时系统

67
00:03:04,320 --> 00:03:05,120
使得我可以

68
00:03:05,160 --> 00:03:06,880
在前一个作业没有结束的时候

69
00:03:06,920 --> 00:03:09,960
我后一个作业能够交替运行

70
00:03:10,000 --> 00:03:12,280
等到分时系统出现之后

71
00:03:12,320 --> 00:03:13,680
并且成熟了以后

72
00:03:13,720 --> 00:03:14,640
我们操作系统里面

73
00:03:14,680 --> 00:03:16,880
这些性能提高的这一部分

74
00:03:16,920 --> 00:03:19,040
就大致差不多了

75
00:03:19,080 --> 00:03:21,560
接下来是说个人计算机系统出现

76
00:03:21,600 --> 00:03:21,880
那这个时候

77
00:03:21,920 --> 00:03:24,680
它易用性变成它最主要的部分

78
00:03:24,720 --> 00:03:27,120
而分布式系统出现之后

79
00:03:27,160 --> 00:03:29,240
它的这种联成网络以后

80
00:03:29,280 --> 00:03:32,120
它的安全性和高可靠性

81
00:03:32,160 --> 00:03:34,040
变成它的主要内容

82
00:03:34,080 --> 00:03:36,720
我们看一下在这个变化的过程当中

83
00:03:36,760 --> 00:03:39,840
各个技术的变化的要点

84
00:03:39,880 --> 00:03:41,360
从计算机出现的

85
00:03:41,400 --> 00:03:45,360
40年代的前面的10年左右

86
00:03:45,400 --> 00:03:46,760
基本是解决

87
00:03:46,800 --> 00:03:50,320
我如何能让花很大价钱买来的计算机

88
00:03:50,360 --> 00:03:53,200
能够让它的利用效率能提高

89
00:03:53,240 --> 00:03:56,520
比如说这是最早的计算机系统

90
00:03:56,560 --> 00:03:58,480
能摆半层楼

91
00:03:58,520 --> 00:04:01,200
那在这头昂贵的计算系统

92
00:04:01,240 --> 00:04:02,680
我花了很多的时间

93
00:04:02,720 --> 00:04:06,720
去换子代穿孔机和最后打印成的结果

94
00:04:06,760 --> 00:04:08,560
这对于我来说是很不合算的

95
00:04:08,600 --> 00:04:12,000
我要努力的减少这部分的时间

96
00:04:12,040 --> 00:04:14,160
从而使得我的执行时间

97
00:04:14,200 --> 00:04:15,000
占的比例越来越高

98
00:04:15,040 --> 00:04:17,000
这样我的利用效率就高了

99
00:04:17,040 --> 00:04:18,200
怎么做呢

100
00:04:18,240 --> 00:04:19,440
  

101
00:04:19,480 --> 00:04:21,160
它的做法是把这些

102
00:04:21,200 --> 00:04:24,520
前后打印和前面的输入

103
00:04:24,560 --> 00:04:26,560
不用昂贵的计算机来做

104
00:04:26,600 --> 00:04:31,880
用周边设备来做这种输入和最后的输出

105
00:04:31,920 --> 00:04:34,360
中间这一段价钱贵的部分

106
00:04:34,400 --> 00:04:35,600
我让它尽可能的快

107
00:04:35,640 --> 00:04:38,200
这一部分数顺序的快速的执行

108
00:04:38,240 --> 00:04:40,400
这是第一个阶段要做的事情

109
00:04:40,440 --> 00:04:43,000
顺序执行我用批处理

110
00:04:43,040 --> 00:04:44,360
然后在这里面呢

111
00:04:44,400 --> 00:04:45,920
  

112
00:04:45,960 --> 00:04:47,440
我为了让它能快

113
00:04:47,480 --> 00:04:50,280
我在这里把若干个作业搁到一起

114
00:04:50,320 --> 00:04:52,560
它们在执行的时候还是顺序执行

115
00:04:52,600 --> 00:04:54,360
结果一块顺序打印

116
00:04:54,400 --> 00:04:58,440
这个阶段最有名的计算机公司就是IBM

117
00:04:58,480 --> 00:04:59,680
它在这里面发家

118
00:04:59,720 --> 00:05:02,400
就是靠做这些输入输出设备

119
00:05:02,440 --> 00:05:04,720
和计算机系统

120
00:05:04,760 --> 00:05:06,920
那么等到这一个阶段行了

121
00:05:06,960 --> 00:05:08,640
实际上对于我的CPU来说

122
00:05:08,680 --> 00:05:10,680
对于我的计算机系统来说

123
00:05:10,720 --> 00:05:13,040
它是满负荷的从头一个作业

124
00:05:13,080 --> 00:05:14,480
接一个作业去算

125
00:05:14,520 --> 00:05:16,240
为了进一步的提高系统的性能

126
00:05:16,280 --> 00:05:19,120
我们这个时候看怎么来做这点

127
00:05:19,160 --> 00:05:21,280
这就是我们这里的多道系统

128
00:05:21,320 --> 00:05:22,440
多道系统是干什么呢

129
00:05:22,480 --> 00:05:24,760
它利用到的一点还是为了提高效率

130
00:05:24,800 --> 00:05:28,000
也就是说我一个程序开始执行

131
00:05:28,040 --> 00:05:29,800
其中有一个做I/O

132
00:05:29,840 --> 00:05:33,480
做I/O呢我从系统调用进入系统里面来

133
00:05:33,520 --> 00:05:37,440
布置相应的设备进行I/O操作

134
00:05:37,480 --> 00:05:39,080
进行IO操作的过程当中

135
00:05:39,120 --> 00:05:42,120
我的计算机系统就在这等着了

136
00:05:42,160 --> 00:05:43,440
那这个等待呢

137
00:05:43,480 --> 00:05:45,520
我CPU是停着的

138
00:05:45,560 --> 00:05:46,880
没法干别的事

139
00:05:46,920 --> 00:05:49,120
要想进一步提高效率呢

140
00:05:49,160 --> 00:05:52,760
我让系统里同时存在多个作业

141
00:05:52,800 --> 00:05:53,920
第二个作业是

142
00:05:53,960 --> 00:05:57,200
在你第一个作业不在执行的时候

143
00:05:57,240 --> 00:05:58,200
空闲的时候

144
00:05:58,240 --> 00:06:01,360
这个时候我让第二个作业来执行

145
00:06:01,400 --> 00:06:04,400
等到你第一个作业返回结果回来以后

146
00:06:04,440 --> 00:06:08,120
我再切回来继续执行你的第一个作业

147
00:06:08,160 --> 00:06:11,400
这个时候在内存里面程序执行的

148
00:06:11,440 --> 00:06:13,480
就由原来的顺序执行

149
00:06:13,520 --> 00:06:16,680
变成的多道程序的交替执行

150
00:06:16,720 --> 00:06:18,160
但是交替的条件

151
00:06:18,200 --> 00:06:21,720
是前一个正在执行的程序

152
00:06:21,760 --> 00:06:24,600
主动让出CPU的使用权

153
00:06:24,640 --> 00:06:27,320
有了这一条以后我的CPU

154
00:06:27,360 --> 00:06:29,880
就可以变成是连续的

155
00:06:29,920 --> 00:06:32,720
尽可能的在处于运行的状态了

156
00:06:32,760 --> 00:06:35,520
这样的话我的效率又进一步提高了

157
00:06:35,560 --> 00:06:38,200
这一步提高以后再往下发展呢

158
00:06:38,240 --> 00:06:40,720
就是我们的分时系统

159
00:06:40,760 --> 00:06:43,720
分时系统它仍然是在做系统的

160
00:06:43,760 --> 00:06:46,360
多个程序的交替执行

161
00:06:46,400 --> 00:06:48,080
但是这个时候大家注意

162
00:06:48,120 --> 00:06:50,920
我们交替的条件不一样了

163
00:06:50,960 --> 00:06:53,720
我在这里加了一个时钟中断

164
00:06:53,760 --> 00:06:56,000
每一个作业算一段时间以后

165
00:06:56,040 --> 00:06:58,440
硬件会产生一个时钟中断

166
00:06:58,480 --> 00:06:59,720
时钟中断的时候

167
00:06:59,760 --> 00:07:02,920
我会暂停当前进程的执行

168
00:07:02,960 --> 00:07:05,440
去由操作系统去调度

169
00:07:05,480 --> 00:07:08,240
我让另一个程序继续执行

170
00:07:08,280 --> 00:07:10,440
等它的时间再一个时钟中断

171
00:07:10,480 --> 00:07:11,520
然后再回来

172
00:07:11,560 --> 00:07:14,000
这样的话我让多个进程交替执行

173
00:07:14,040 --> 00:07:15,560
这个时候交替执行就变成什么

174
00:07:15,600 --> 00:07:18,160
如果我有一个作业在前面

175
00:07:18,200 --> 00:07:19,680
花很长时间要算

176
00:07:19,720 --> 00:07:21,760
我又来一个作业我仅仅是做编译

177
00:07:21,800 --> 00:07:23,600
也许编译我就不一定通过了

178
00:07:23,640 --> 00:07:25,200
这种情况下我排在后面

179
00:07:25,240 --> 00:07:26,280
我会等很长时间

180
00:07:26,320 --> 00:07:29,680
有了分时系统以后大家一人算一点

181
00:07:29,720 --> 00:07:31,080
对于我刚才说的这种

182
00:07:31,120 --> 00:07:33,680
只是做编译测试的这种情况

183
00:07:33,720 --> 00:07:36,360
它可以分到它的时间很快算完

184
00:07:36,400 --> 00:07:37,920
算错了它就退出来了

185
00:07:37,960 --> 00:07:39,120
而另外一个长的呢

186
00:07:39,160 --> 00:07:43,320
它在交互式的这几个运行结束以后

187
00:07:43,360 --> 00:07:45,680
后面长的作业可以一直算下去

188
00:07:45,720 --> 00:07:47,920
这样一来就可以减少了

189
00:07:47,960 --> 00:07:50,040
我用户等待的时间

190
00:07:50,080 --> 00:07:53,040
这个时候说它的系统的性能

191
00:07:53,080 --> 00:07:54,880
在什么地方做提升

192
00:07:54,920 --> 00:07:56,760
它的提升不是在于

193
00:07:56,800 --> 00:07:59,720
有CPU的效率有提高

194
00:07:59,760 --> 00:08:01,800
原因在于CPU加了调度以后

195
00:08:01,840 --> 00:08:04,400
它的性能某种角度它会下降

196
00:08:04,440 --> 00:08:07,040
但是由于我让一些短的作业

197
00:08:07,080 --> 00:08:10,480
能够公平性能更好了

198
00:08:10,520 --> 00:08:12,320
这样的话我短作业

199
00:08:12,360 --> 00:08:14,200
用户的时间的会节约了

200
00:08:14,240 --> 00:08:17,040
从这个角度来讲仍然是提高效率的

201
00:08:17,080 --> 00:08:18,280
到了这一步以后

202
00:08:18,320 --> 00:08:21,120
分时系统我们的CPU的效率

203
00:08:21,160 --> 00:08:23,400
就基本上提到极致了

204
00:08:23,440 --> 00:08:25,880
接下来计算机发展的变化是什么呢

205
00:08:25,920 --> 00:08:28,800
就是个人计算机系统

206
00:08:28,840 --> 00:08:31,000
在个人计算机系统里面呢

207
00:08:31,040 --> 00:08:33,760
效率已经不再是我们关心的重点了

208
00:08:33,800 --> 00:08:35,360
这个时候计算机的价格

209
00:08:35,400 --> 00:08:38,480
已经降低到一个办公室

210
00:08:38,520 --> 00:08:39,560
或者说一个家庭

211
00:08:39,600 --> 00:08:41,600
可以有一台计算机的状态

212
00:08:41,640 --> 00:08:42,920
在这种状态下

213
00:08:42,960 --> 00:08:46,120
我用户也不再是局限于

214
00:08:46,160 --> 00:08:47,680
是计算机专业人士

215
00:08:47,720 --> 00:08:51,000
才能够使用计算机 写计算机程序

216
00:08:51,040 --> 00:08:52,880
很多人开始利用计算机

217
00:08:52,920 --> 00:08:54,200
来做自己的事情

218
00:08:54,240 --> 00:08:56,840
这个时候计算机的易用性

219
00:08:56,880 --> 00:08:58,120
变得非常重要了

220
00:08:58,160 --> 00:08:59,640
这个时候图形用户界面

221
00:08:59,680 --> 00:09:03,000
是这个阶段发展的重点

222
00:09:03,040 --> 00:09:06,240
在这个里面计算机变成一个

223
00:09:06,280 --> 00:09:09,520
支持沟通和交流的系统了

224
00:09:09,560 --> 00:09:10,520
而这个里头呢

225
00:09:10,560 --> 00:09:13,440
安全性的问题又变成这里最重要的了

226
00:09:13,480 --> 00:09:15,280
这个相当于安全的问题

227
00:09:15,320 --> 00:09:17,640
在操作系统里面重要程度有上升

228
00:09:17,680 --> 00:09:20,840
  

229
00:09:20,880 --> 00:09:22,440
个人操作系统实际上

230
00:09:22,480 --> 00:09:24,520
和网络的出现又联在一起

231
00:09:24,560 --> 00:09:26,120
这个时候我们网络的

232
00:09:26,160 --> 00:09:27,240
又形成了另外一个分支

233
00:09:27,280 --> 00:09:29,760
就是分布式操作系统

234
00:09:29,800 --> 00:09:31,120
分布式操作系统

235
00:09:31,160 --> 00:09:32,800
它因为有了网络以后

236
00:09:32,840 --> 00:09:35,720
我在多台机器之间

237
00:09:35,760 --> 00:09:38,960
需要有数据的共享和协调

238
00:09:39,000 --> 00:09:40,400
然后一台机器里面

239
00:09:40,440 --> 00:09:42,720
我也可能使用多个CPU

240
00:09:42,760 --> 00:09:45,640
这个时候多个CPU的使用

241
00:09:45,680 --> 00:09:47,920
和多台机器互联的使用

242
00:09:47,960 --> 00:09:49,520
这个时候可能提高的结果

243
00:09:49,560 --> 00:09:51,680
使得我们系统的可用性

244
00:09:51,720 --> 00:09:54,440
和可靠性有进一步提高

245
00:09:54,480 --> 00:09:56,480
这个时候我们见到的一种典型场景

246
00:09:56,520 --> 00:10:00,440
是若干个用户通过网络联在一起

247
00:10:00,480 --> 00:10:01,920
我们有服务器提供一些

248
00:10:01,960 --> 00:10:03,600
共性的资源的共享

249
00:10:03,640 --> 00:10:05,920
各个用户在自己的机器上

250
00:10:05,960 --> 00:10:07,160
进行相应的处理

251
00:10:07,200 --> 00:10:09,360
使得我整个网络可以开始

252
00:10:09,400 --> 00:10:12,720
去处理一些实时的信息

253
00:10:12,760 --> 00:10:14,800
比如说我们在这样的系统里面

254
00:10:14,840 --> 00:10:17,000
可以买飞机票 买火车票

255
00:10:17,040 --> 00:10:18,640
在网上进行购物

256
00:10:18,680 --> 00:10:21,440
这个图可以很方便地的来说明

257
00:10:21,480 --> 00:10:23,840
在操作系统演变的过程当中

258
00:10:23,880 --> 00:10:25,320
计算机的处理能力和

259
00:10:25,360 --> 00:10:27,920
操作系统变化之间的某种关系

260
00:10:27,960 --> 00:10:30,280
在最早的时候计算机系统

261
00:10:30,320 --> 00:10:33,280
主要是一个大型的主机系统

262
00:10:33,320 --> 00:10:37,000
一个学校可能会有一台计算机系统

263
00:10:37,040 --> 00:10:39,040
很多的计算机专业人士

264
00:10:39,080 --> 00:10:41,080
围绕这台计算机系统

265
00:10:41,120 --> 00:10:42,680
来提高它的效率

266
00:10:42,720 --> 00:10:45,960
我们所说到的批处理系统 

267
00:10:46,000 --> 00:10:48,320
多道系统 分时系统

268
00:10:48,360 --> 00:10:50,160
都是在这个阶段出现

269
00:10:50,200 --> 00:10:52,800
并且不断成熟和发展起来的

270
00:10:52,840 --> 00:10:55,480
然后等到计算机硬件成本

271
00:10:55,520 --> 00:10:56,920
降低到一定程度

272
00:10:56,960 --> 00:10:59,000
这个时候我们每一个办公室

273
00:10:59,040 --> 00:11:00,320
或者说每一个家庭

274
00:11:00,360 --> 00:11:01,800
可以有一台计算机的时候

275
00:11:01,840 --> 00:11:04,480
这个时候通过网络互联的

276
00:11:04,520 --> 00:11:08,040
个人计算机变成主流了

277
00:11:08,080 --> 00:11:10,400
在这种情况下我们的方便性

278
00:11:10,440 --> 00:11:13,520
易用性就变成其中一个重要的内容

279
00:11:13,560 --> 00:11:15,560
这是我们在桌面系统上看到的

280
00:11:15,600 --> 00:11:17,280
图形用户接口的发展

281
00:11:17,320 --> 00:11:18,440
鼠标的使用

282
00:11:18,480 --> 00:11:21,120
这些都算是这个阶段的

283
00:11:21,160 --> 00:11:24,760
再往上等到我们每一个人

284
00:11:24,800 --> 00:11:27,520
都有一台便携式的

285
00:11:27,560 --> 00:11:29,680
可随身携带的计算机系统的时候

286
00:11:29,720 --> 00:11:33,360
这个时候我们要处理的易用性

287
00:11:33,400 --> 00:11:37,000
或者说这种自适应能力变得更强

288
00:11:37,040 --> 00:11:39,560
也许到不远的将来

289
00:11:39,600 --> 00:11:41,960
甚至于现在我们一个人就有可能有

290
00:11:42,000 --> 00:11:43,800
多台计算机系统了

291
00:11:43,840 --> 00:11:45,240
比如说我会有手机

292
00:11:45,280 --> 00:11:47,120
有一台笔记本

293
00:11:47,160 --> 00:11:48,440
那在这个系统里面呢

294
00:11:48,480 --> 00:11:50,800
我们如果说到某一个状态下是

295
00:11:50,840 --> 00:11:52,320
每一个电子设备里

296
00:11:52,360 --> 00:11:54,040
都有一个计算机系统

297
00:11:54,080 --> 00:11:55,360
里面都有操作系统的话

298
00:11:55,400 --> 00:11:56,680
这个时候就是我们所说的

299
00:11:56,720 --> 00:11:59,360
普适计算 移动计算 云计算

300
00:11:59,400 --> 00:12:01,640
就变成一个主流的内容了

301
00:12:01,680 --> 00:12:03,880
而在这种环境下

302
00:12:03,920 --> 00:12:06,240
我们可能涉及到大量的数据

303
00:12:06,280 --> 00:12:07,640
而这种数据的处理

304
00:12:07,680 --> 00:12:11,760
又对主机系统又会产生一轮影响

305
00:12:11,800 --> 00:12:14,480
这就是我们这个云计算

306
00:12:14,520 --> 00:12:16,000
需要面对的环境

307
00:12:16,040 --> 00:12:17,560
在这个状态下实际上操作系统

308
00:12:17,600 --> 00:12:20,400
还会再继续往前又发展

309
00:12:20,440 --> 00:12:22,200
这个就是我们在最开始讲到的

310
00:12:22,240 --> 00:12:24,960
实际上像现在的

311
00:12:25,000 --> 00:12:28,280
谷歌 亚马逊 百度 搜狐

312
00:12:28,320 --> 00:12:29,760
这一类的互联网公司

313
00:12:29,800 --> 00:12:31,120
会把精力集中到

314
00:12:31,160 --> 00:12:34,080
操作系统研究上来的缘故

315
00:12:34,120 --> 00:12:35,800
好 这就是我们说到的

316
00:12:35,840 --> 00:12:37,480
操作系统发展的过程

317
00:12:37,520 --> 00:12:38,600


318
00:12:38,640 --> 00:12:38,640


