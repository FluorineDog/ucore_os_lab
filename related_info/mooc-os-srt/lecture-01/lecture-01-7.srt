0
00:00:00,000 --> 00:00:06,400


1
00:00:06,440 --> 00:00:09,760
接下来我们来讲操作系统的结构

2
00:00:09,800 --> 00:00:13,440
任何一个软件它都会有自己的结构

3
00:00:13,480 --> 00:00:14,960
操作系统也不例外

4
00:00:15,000 --> 00:00:16,680
操作系统在发展的过程当中

5
00:00:16,720 --> 00:00:20,360
它的结构实际上有了非常大的变化

6
00:00:20,400 --> 00:00:23,400
我们从历史上发展的过程来看

7
00:00:23,440 --> 00:00:25,400
操作系统可能采取的结构

8
00:00:25,440 --> 00:00:29,360
和每种结构它的特征

9
00:00:29,400 --> 00:00:30,600
最早的时候实际上

10
00:00:30,640 --> 00:00:32,760
操作系统它是一种简单的结构

11
00:00:32,800 --> 00:00:34,680
对下控制硬件

12
00:00:34,720 --> 00:00:39,400
对上提供用户应用程序所需要的服务

13
00:00:39,440 --> 00:00:42,360
中间的功能实际上实现的很简单

14
00:00:42,400 --> 00:00:44,760
我们在BIOS里面有一层

15
00:00:44,800 --> 00:00:47,600
对硬件进行管理的驱动程序

16
00:00:47,640 --> 00:00:50,160
操作系统内部它把这一层

17
00:00:50,200 --> 00:00:52,120
做了更进一步的完善

18
00:00:52,160 --> 00:00:55,000
这种完善形成了系统里面的驱动

19
00:00:55,040 --> 00:00:58,080
然后有一些常驻的服务系统程序

20
00:00:58,120 --> 00:00:59,920
然后上面是应用程序

21
00:00:59,960 --> 00:01:03,920
应用程序有可以使用操作系统提供的

22
00:01:03,960 --> 00:01:05,160
设备驱动服务

23
00:01:05,200 --> 00:01:06,680
也可能直接使用

24
00:01:06,720 --> 00:01:09,920
底下BIOS提供的系统服务

25
00:01:09,960 --> 00:01:13,600
在这个里面它没有进行模块化的划分

26
00:01:13,640 --> 00:01:16,120
实现的时候操作系统的代码

27
00:01:16,160 --> 00:01:17,960
也主要是汇编来写的

28
00:01:18,000 --> 00:01:20,160
基于这种情况操作系统

29
00:01:20,200 --> 00:01:22,240
它是从一个平台

30
00:01:22,280 --> 00:01:23,800
操作系统只能用在这个平台上

31
00:01:23,840 --> 00:01:26,120
到其它的品平台上不能使用的

32
00:01:26,160 --> 00:01:26,800
所以这样的话

33
00:01:26,840 --> 00:01:28,760
每个操作系统都是只针对

34
00:01:28,800 --> 00:01:31,400
特定硬件平台来写的操作系统

35
00:01:31,440 --> 00:01:34,160
在这个阶段我们有很多种操作系统

36
00:01:34,200 --> 00:01:37,680
在PC机上主要是DOS系统

37
00:01:37,720 --> 00:01:41,040
它只能用在X86的系统上

38
00:01:41,080 --> 00:01:42,280
第二种结构实际上

39
00:01:42,320 --> 00:01:45,240
随着Unix系统不断发展完善

40
00:01:45,280 --> 00:01:47,600
形成的这就是分层结构

41
00:01:47,640 --> 00:01:49,120
在分层结构当中

42
00:01:49,160 --> 00:01:52,800
我们会把操作系统功能分成若干层

43
00:01:52,840 --> 00:01:55,480
最底下一层是硬件

44
00:01:55,520 --> 00:01:59,600
最上面一层是用户接口

45
00:01:59,640 --> 00:02:01,120
在中间实际上

46
00:02:01,160 --> 00:02:03,560
我们按照功能的不断的丰富

47
00:02:03,600 --> 00:02:06,040
不断的完善把它分成了N层

48
00:02:06,080 --> 00:02:09,680
每一层只使用下一层提供的服务

49
00:02:09,720 --> 00:02:10,960
这种分层结构

50
00:02:11,000 --> 00:02:16,400
使得各个层依赖关系得到一定的限制

51
00:02:16,440 --> 00:02:19,760
使得我的可靠性能够进一步提高

52
00:02:19,800 --> 00:02:22,360
这个里面分层结构很大贡献

53
00:02:22,400 --> 00:02:25,560
在于它把可移植性

54
00:02:25,600 --> 00:02:28,160
作为操作系统的一个重要的目标

55
00:02:28,200 --> 00:02:29,680
以前的话我们是说

56
00:02:29,720 --> 00:02:31,000
对于一个特定的硬件平台

57
00:02:31,040 --> 00:02:33,560
我要全新对它写一套操作系统

58
00:02:33,600 --> 00:02:34,800
现在我只需要

59
00:02:34,840 --> 00:02:37,920
把整个操作系统代码分成两部分

60
00:02:37,960 --> 00:02:41,560
一部分与硬件平台无关的部分

61
00:02:41,600 --> 00:02:44,280
这一部分我们用高级语言来实现

62
00:02:44,320 --> 00:02:47,120
另外一部分是跟特定硬件平台

63
00:02:47,160 --> 00:02:48,160
密切相关的部分

64
00:02:48,200 --> 00:02:49,160
这一部分我们仍然

65
00:02:49,200 --> 00:02:51,800
使用汇编程序来实现

66
00:02:51,840 --> 00:02:56,040
做了这种划分以后操作系统的移植

67
00:02:56,080 --> 00:02:58,760
只需要改汇编的部分

68
00:02:58,800 --> 00:03:01,280
我们在这里说到Unix系统和C语言

69
00:03:01,320 --> 00:03:03,080
我们前面说Unix系统的时候已经

70
00:03:03,120 --> 00:03:09,640
见过这两位Thompson和 Ritchie

71
00:03:09,680 --> 00:03:12,000
他们实际在Unix系统发展过程当中

72
00:03:12,040 --> 00:03:13,480
他提出来的C语言

73
00:03:13,520 --> 00:03:16,040
C语言也会由于Unix系统的发展

74
00:03:16,080 --> 00:03:18,280
而得到广泛的使用

75
00:03:18,320 --> 00:03:21,200
最后他们得了图灵奖

76
00:03:21,240 --> 00:03:23,960
这是第二种结构

77
00:03:24,000 --> 00:03:27,320
我们所使用ucore教学操作系统

78
00:03:27,360 --> 00:03:30,960
它的结构基本是采用分层的结构

79
00:03:31,000 --> 00:03:32,640
我们在这里要学的内容

80
00:03:32,680 --> 00:03:36,200
是划红线的这几个部分

81
00:03:36,240 --> 00:03:37,720
我们基本涉及到

82
00:03:37,760 --> 00:03:41,640
从最底层的中断 系统加载

83
00:03:41,680 --> 00:03:43,080
一直到操作系统内部

84
00:03:43,120 --> 00:03:45,080
各个核心模块对上提供的服务

85
00:03:45,120 --> 00:03:48,920
和系统服务里的命令行

86
00:03:48,960 --> 00:03:50,520
这是分层结构

87
00:03:50,560 --> 00:03:53,160
分层结构随着层次的增加

88
00:03:53,200 --> 00:03:56,760
依赖关系这种层次越来越复杂

89
00:03:56,800 --> 00:03:58,080
复杂的结果是

90
00:03:58,120 --> 00:04:00,160
操作系统内核里面的东西越来越多

91
00:04:00,200 --> 00:04:02,000
效率越来越下降

92
00:04:02,040 --> 00:04:05,320
在这个基础上微内核结构

93
00:04:05,360 --> 00:04:08,640
因为分层结构的层次多

94
00:04:08,680 --> 00:04:12,080
所带来的效率低的一种做法

95
00:04:12,120 --> 00:04:13,480
我们希望实际上是

96
00:04:13,520 --> 00:04:16,640
把一些操作系统内核提供的服务

97
00:04:16,680 --> 00:04:19,600
放到用户态是不是这样的话

98
00:04:19,640 --> 00:04:20,840
能够提高它的效率

99
00:04:20,880 --> 00:04:24,560
所以在这做了一种尝试微内核

100
00:04:24,600 --> 00:04:27,880
把尽可能多的内核的功能放到用户态

101
00:04:27,920 --> 00:04:31,120
在内核里面只保留进程间通信

102
00:04:31,160 --> 00:04:33,840
和底下对硬件的支持

103
00:04:33,880 --> 00:04:35,240
然后在这之上

104
00:04:35,280 --> 00:04:38,160
这个时候会说如果用户态应用程序

105
00:04:38,200 --> 00:04:40,800
想使用传统内核提供的

106
00:04:40,840 --> 00:04:42,560
系统服务功能怎么办呢

107
00:04:42,600 --> 00:04:45,160
这个时候说用户态的应用程序

108
00:04:45,200 --> 00:04:47,240
要想跟内核进行通讯

109
00:04:47,280 --> 00:04:52,080
它需要先绕到内核然后再回到用户态

110
00:04:52,120 --> 00:04:55,680
这样做之后它的安全性和可扩展性

111
00:04:55,720 --> 00:04:57,680
就会有大幅度提高

112
00:04:57,720 --> 00:05:00,960
但是它也会有问题

113
00:05:01,000 --> 00:05:04,480
它的性能就会有大幅度下降

114
00:05:04,520 --> 00:05:05,440
实际上在这个里面

115
00:05:05,480 --> 00:05:07,360
我们现在用到的操作系统

116
00:05:07,400 --> 00:05:08,320
你看它的结构

117
00:05:08,360 --> 00:05:10,080
它是微内核结构和

118
00:05:10,120 --> 00:05:12,600
分层结构的一个混合体

119
00:05:12,640 --> 00:05:13,520
在这种情况下

120
00:05:13,560 --> 00:05:15,800
我们会注意到有一些系统里面的

121
00:05:15,840 --> 00:05:16,680
某一部分内容

122
00:05:16,720 --> 00:05:19,080
在某一个版本里是放到内核里面

123
00:05:19,120 --> 00:05:21,880
到另一个版本里把它放到用户态去了

124
00:05:21,920 --> 00:05:23,440
又有可能过了一段时间以后

125
00:05:23,480 --> 00:05:27,080
它又把它放回来这是微内核结构

126
00:05:27,120 --> 00:05:29,040
在针对微内核结构

127
00:05:29,080 --> 00:05:32,320
进一步的改进叫做外核

128
00:05:32,360 --> 00:05:33,280
它的做法是什么呢

129
00:05:33,320 --> 00:05:35,040
它的做法是向内核里面

130
00:05:35,080 --> 00:05:37,280
放更少的东西

131
00:05:37,320 --> 00:05:43,120
它只是起到资源的保护和隔离的作用

132
00:05:43,160 --> 00:05:45,600
然后把资源管理的任务

133
00:05:45,640 --> 00:05:49,160
交给应用态的代码去完成

134
00:05:49,200 --> 00:05:50,640
这个时候

135
00:05:50,680 --> 00:05:52,720
原来的操作系统功能怎么办呢

136
00:05:52,760 --> 00:05:54,360
原来操作系统的功能

137
00:05:54,400 --> 00:05:58,080
是由用户态的函数库来提供

138
00:05:58,120 --> 00:06:01,720
这种情况下我们看到的是

139
00:06:01,760 --> 00:06:03,240
操作系统的硬件资源

140
00:06:03,280 --> 00:06:05,920
在上面只有一个很薄的

141
00:06:05,960 --> 00:06:07,600
一层安全绑定

142
00:06:07,640 --> 00:06:09,840
在这个安全绑定里面

143
00:06:09,880 --> 00:06:14,880
它控制哪些资源归哪一个系统使用

144
00:06:14,920 --> 00:06:16,920
而相应的资源管理

145
00:06:16,960 --> 00:06:19,880
由各自的系统自己来维护

146
00:06:19,920 --> 00:06:22,640
在这种情况下我们可以在一个系统上

147
00:06:22,680 --> 00:06:25,840
支起不同的操作系统服务

148
00:06:25,880 --> 00:06:27,160
某种角度来说

149
00:06:27,200 --> 00:06:30,320
这好像是一个虚拟机的结构

150
00:06:30,360 --> 00:06:32,600
我们现在意义上的虚拟机

151
00:06:32,640 --> 00:06:34,560
它不是一个我们传统说的

152
00:06:34,600 --> 00:06:36,320
操作系统的一个结构

153
00:06:36,360 --> 00:06:37,120
实际上这个时候

154
00:06:37,160 --> 00:06:40,080
它是把我们现在用到的XEN

155
00:06:40,120 --> 00:06:43,480
早期的时候就是以这种结构出现的

156
00:06:43,520 --> 00:06:46,840
接下来我们说虚拟机管理系结里面

157
00:06:46,880 --> 00:06:51,080
计算机的硬件之上我们架了一个VMM

158
00:06:51,120 --> 00:06:53,400
它负责把真实的硬件

159
00:06:53,440 --> 00:06:57,280
虚拟成若干个虚拟的硬件

160
00:06:57,320 --> 00:06:59,520
然后我们操作系统在这上面

161
00:06:59,560 --> 00:07:02,080
来实现传统操作系统的功能

162
00:07:02,120 --> 00:07:05,800
这一部分功能虚拟管理器来决定

163
00:07:05,840 --> 00:07:08,080
我每一个虚拟机到底可以使用

164
00:07:08,120 --> 00:07:10,720
哪样一些硬件资源

165
00:07:10,760 --> 00:07:14,400
有了这个管理器以后

166
00:07:14,440 --> 00:07:17,640
我们传统的操作系统与硬件

167
00:07:17,680 --> 00:07:19,160
和应用之间的关系

168
00:07:19,200 --> 00:07:20,800
就会发生一个变化

169
00:07:20,840 --> 00:07:22,880
这种变化在什么地方呢

170
00:07:22,920 --> 00:07:26,800
原来的操作系统是直接底下接触硬件

171
00:07:26,840 --> 00:07:29,040
上面对应用提供服务

172
00:07:29,080 --> 00:07:30,720
现在变成是

173
00:07:30,760 --> 00:07:33,760
虚拟机管理器和硬件打交道

174
00:07:33,800 --> 00:07:37,600
操作系统来和虚拟机管理器打交道

175
00:07:37,640 --> 00:07:38,280
但是实际上

176
00:07:38,320 --> 00:07:39,600
它其中有一部分

177
00:07:39,640 --> 00:07:42,320
还是会和硬件直接打交道

178
00:07:42,360 --> 00:07:43,800
这个时候的区别在什么地方

179
00:07:43,840 --> 00:07:47,000
在于管理器负责资源的隔离

180
00:07:47,040 --> 00:07:51,400
操作系统负责资源的管理

181
00:07:51,440 --> 00:07:56,560
好 到现在为止

182
00:07:56,600 --> 00:07:59,600
我们第一讲的内容就讲到结尾了

183
00:07:59,640 --> 00:08:02,880
我们说操作系统是很有趣的

184
00:08:02,920 --> 00:08:06,200
它可以很好的控制一台完整的计算机

185
00:08:06,240 --> 00:08:08,560
如果说你最后做完实验以后

186
00:08:08,600 --> 00:08:11,760
能够用自己写的操作系统代码

187
00:08:11,800 --> 00:08:13,960
去控制一台真实的物理机器

188
00:08:14,000 --> 00:08:16,000
你的感受会是非常好的

189
00:08:16,040 --> 00:08:18,120
但是要想实现这一点

190
00:08:18,160 --> 00:08:21,080
你需要付出非常多的努力

191
00:08:21,120 --> 00:08:26,640
同时操作系统它现在仍然很不完善

192
00:08:26,680 --> 00:08:28,520
不管你花了多长时间做测试

193
00:08:28,560 --> 00:08:32,920
用户实际使用的时候它仍然会有错误

194
00:08:32,960 --> 00:08:36,000
仍然会性能或者功能不满意

195
00:08:36,040 --> 00:08:37,120
这个时候仍然有很多

196
00:08:37,160 --> 00:08:39,240
我们需要去改进的地方

197
00:08:39,280 --> 00:08:41,720
这也是我们学操作系统课

198
00:08:41,760 --> 00:08:43,600
想要去挑战的地方

199
00:08:43,640 --> 00:08:45,840
同时它很庞大

200
00:08:45,880 --> 00:08:48,200
通常情况下我们现在用到ucore

201
00:08:48,240 --> 00:08:50,480
它有一万行代码左右

202
00:08:50,520 --> 00:08:52,920
这是你在前序的一些课程里面

203
00:08:52,960 --> 00:08:54,360
不会学到这么多代码的

204
00:08:54,400 --> 00:08:58,360
综合利用它你才能够完成操作系统实验

205
00:08:58,400 --> 00:09:01,160
理解操作系统这些原理

206
00:09:01,200 --> 00:09:04,840
最后我们想说操作系统尽管很困难

207
00:09:04,880 --> 00:09:07,120
但是我们前面例子

208
00:09:07,160 --> 00:09:09,480
我们能够做到依靠你自己的努力

209
00:09:09,520 --> 00:09:12,080
最后我们是能够实现

210
00:09:12,120 --> 00:09:15,280
一个小的教学操作系统

211
00:09:15,320 --> 00:09:16,320
今天的课就上到这里

212
00:09:16,360 --> 00:09:17,200


213
00:09:17,240 --> 00:09:17,680


214
00:09:17,720 --> 00:09:18,280


215
00:09:18,320 --> 00:09:18,320


