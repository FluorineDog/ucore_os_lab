0
00:00:00,000 --> 00:00:07,280


1
00:00:07,320 --> 00:00:09,920
接下来 我们对这学期的教学内容

2
00:00:09,960 --> 00:00:12,520
做一个整体上的介绍

3
00:00:12,560 --> 00:00:14,680
在这里包括我们要讲的内容

4
00:00:14,720 --> 00:00:16,240
我们要做的实验内容

5
00:00:16,280 --> 00:00:18,600
和课程设计的内容

6
00:00:18,640 --> 00:00:19,960
操作系统课 

7
00:00:20,000 --> 00:00:23,640
涉及到计算机系统当中资源管理

8
00:00:23,680 --> 00:00:26,480
所以我们围绕着操作系统的实现

9
00:00:26,520 --> 00:00:28,640
来介绍相关的内容

10
00:00:28,680 --> 00:00:30,200
主要分成这样几个部分

11
00:00:30,240 --> 00:00:33,040
第一个操作系统软件的结构

12
00:00:33,080 --> 00:00:35,280
任何一个软件在设计的时候

13
00:00:35,320 --> 00:00:38,280
和在实现的时候它都有自己结构特点

14
00:00:38,320 --> 00:00:39,640
那对于操作系统来说

15
00:00:39,680 --> 00:00:40,960
它有什么样的结构特点

16
00:00:41,000 --> 00:00:43,160
是我们在这里需要来讨论的问题

17
00:00:43,200 --> 00:00:45,440
第二个是中断与系统调用

18
00:00:45,480 --> 00:00:48,120
这说的是操作系统这个软件

19
00:00:48,160 --> 00:00:51,440
它和外界打交道的这些接口

20
00:00:51,480 --> 00:00:54,720
中断是操作系统和硬件打交道的接口

21
00:00:54,760 --> 00:00:56,360
操作系统在服务过程当中

22
00:00:56,400 --> 00:00:59,040
外部如果有设备有请求

23
00:00:59,080 --> 00:01:01,600
比如说你敲键盘网络有数据包来了

24
00:01:01,640 --> 00:01:03,680
这个时候操作系统如何对它进行响应

25
00:01:03,720 --> 00:01:06,720
那么这是中断里要讨论的内容

26
00:01:06,760 --> 00:01:09,040
硬件上已经有了一些机制

27
00:01:09,080 --> 00:01:10,760
能够对外边做一些响应

28
00:01:10,800 --> 00:01:12,840
但是这个时候它只是做了其中第一步

29
00:01:12,880 --> 00:01:14,920
比如说你敲键盘的时候

30
00:01:14,960 --> 00:01:17,320
这个时候的硬件机构

31
00:01:17,360 --> 00:01:20,320
已经能把数据存到相应缓冲区里头

32
00:01:20,360 --> 00:01:22,680
但是缓冲区如何到应用程序里

33
00:01:22,720 --> 00:01:25,560
那是操作系统需要解决的问题

34
00:01:25,600 --> 00:01:27,160
而系统调用是操作系统

35
00:01:27,200 --> 00:01:29,920
对上层应用提供的服务接口

36
00:01:29,960 --> 00:01:31,320
也就是说上层应用

37
00:01:31,360 --> 00:01:34,720
要想利用操作系统提供的服务

38
00:01:34,760 --> 00:01:36,320
来实现自己的功能

39
00:01:36,360 --> 00:01:38,640
必须使用系统调用

40
00:01:38,680 --> 00:01:40,280
在这里头系统调用

41
00:01:40,320 --> 00:01:42,920
如何从用户态的应用程序里头

42
00:01:42,960 --> 00:01:46,240
获取用户想使用服务的类型

43
00:01:46,280 --> 00:01:48,320
和相应的输入数据

44
00:01:48,360 --> 00:01:51,120
都必须从系统调用接口来

45
00:01:51,160 --> 00:01:53,920
这里系统调用的介绍

46
00:01:53,960 --> 00:01:57,040
如何让用户的输入能够到系统里来

47
00:01:57,080 --> 00:02:00,880
系统处理完的结果如何能回到用户态

48
00:02:00,920 --> 00:02:03,000
而接下来的这几个部分是

49
00:02:03,040 --> 00:02:05,240
我们操作系统要管理的资源

50
00:02:05,280 --> 00:02:07,360
第一个是内存资源

51
00:02:07,400 --> 00:02:10,840
也就是说在计算机系统当中有内存

52
00:02:10,880 --> 00:02:12,640
随机访问存储器

53
00:02:12,680 --> 00:02:14,000
这部分存储能力

54
00:02:14,040 --> 00:02:15,600
会有很多应用程序要使用

55
00:02:15,640 --> 00:02:19,040
那如何协调各个应用对内存的使用

56
00:02:19,080 --> 00:02:21,160
可能会是说有的应用

57
00:02:21,200 --> 00:02:24,040
它需要大量的内存空间来存储数据

58
00:02:24,080 --> 00:02:25,840
有的应用需要的不多

59
00:02:25,880 --> 00:02:27,680
那么这个时候对于我们操作系统来说

60
00:02:27,720 --> 00:02:29,560
需要要么是应用程序告诉你

61
00:02:29,600 --> 00:02:30,400
我需要多少

62
00:02:30,440 --> 00:02:33,640
要么是你在使用过程中动态进行调节

63
00:02:33,680 --> 00:02:37,640
而这种调节和内存分配和回收

64
00:02:37,680 --> 00:02:39,280
是我们操作系统要做的事情

65
00:02:39,320 --> 00:02:41,880
接下来一个是操作系统需要管理

66
00:02:41,920 --> 00:02:44,560
用户程序的执行过程

67
00:02:44,600 --> 00:02:47,040
也就是说任何一个程序在执行

68
00:02:47,080 --> 00:02:49,880
它首先需要系统给它分配

69
00:02:49,920 --> 00:02:51,320
它执行所需要的资源

70
00:02:51,360 --> 00:02:54,680
比如说CPU 内存和相应访问的

71
00:02:54,720 --> 00:02:59,040
一些外部设备和数据资源

72
00:02:59,080 --> 00:03:01,360
有了这些资源之后程序开始运行

73
00:03:01,400 --> 00:03:05,480
在运行过程中这些执行的状态

74
00:03:05,520 --> 00:03:07,280
也是在不断变化的过程当中

75
00:03:07,320 --> 00:03:10,200
它可能会占用CPU执行指令

76
00:03:10,240 --> 00:03:12,880
也可能会由于等待用户输入

77
00:03:12,920 --> 00:03:14,320
而进入暂停状态

78
00:03:14,360 --> 00:03:15,760
这些状态的维护

79
00:03:15,800 --> 00:03:18,280
就是我们这里所说进程和线程

80
00:03:18,320 --> 00:03:20,160
操作系统需要维护每一个

81
00:03:20,200 --> 00:03:22,920
正在执行的程序它的状态

82
00:03:22,960 --> 00:03:25,160
以便于在它们执行结束之后

83
00:03:25,200 --> 00:03:27,600
能够回收相应的资源

84
00:03:27,640 --> 00:03:30,720
这是进程管理需要讨论的问题

85
00:03:30,760 --> 00:03:32,080
  

86
00:03:32,120 --> 00:03:34,360
接下来一个是处理机调度

87
00:03:34,400 --> 00:03:38,560
处理机调度是指说我们有多个进程

88
00:03:38,600 --> 00:03:41,840
在计算机系统当中交替运行

89
00:03:41,880 --> 00:03:44,320
那么如果说你只有一个CPU

90
00:03:44,360 --> 00:03:46,440
或者说你的应用进程数目

91
00:03:46,480 --> 00:03:47,920
是大于CPU的数目

92
00:03:47,960 --> 00:03:49,880
做不到每一个进程

93
00:03:49,920 --> 00:03:51,880
有一个完全独占的CPU来使用

94
00:03:51,920 --> 00:03:52,480
那么这个时候

95
00:03:52,520 --> 00:03:56,240
大家是交替使用CPU来执行指令

96
00:03:56,280 --> 00:03:58,880
这种交替就需要有一个调度

97
00:03:58,920 --> 00:04:01,720
到底一个正在执行的进程

98
00:04:01,760 --> 00:04:03,880
到什么时候让出CPU使用权

99
00:04:03,920 --> 00:04:05,960
下一个选择又是谁

100
00:04:06,000 --> 00:04:10,360
这是我们调度算法要进行解决的问题

101
00:04:10,400 --> 00:04:13,080
接下来一个是进程间通讯

102
00:04:13,120 --> 00:04:14,320
或者叫同步互斥 

103
00:04:14,360 --> 00:04:16,840
这里指的是我们任何一个应用进程

104
00:04:16,880 --> 00:04:18,200
它在执行过程当中

105
00:04:18,240 --> 00:04:20,720
都不会是自己一个

106
00:04:20,760 --> 00:04:22,760
在那封闭着进行执行

107
00:04:22,800 --> 00:04:24,960
它不会跟外界做任何交道

108
00:04:25,000 --> 00:04:27,040
我们计算机上的程序

109
00:04:27,080 --> 00:04:28,760
它所做到最大好处是

110
00:04:28,800 --> 00:04:31,480
由于用户输入的不同

111
00:04:31,520 --> 00:04:34,240
那我给出不同的处理结果

112
00:04:34,280 --> 00:04:36,920
而这个处理是可以重复进行的

113
00:04:36,960 --> 00:04:38,200
所以我们在这里才会

114
00:04:38,240 --> 00:04:42,440
有计算机程序来实现自动化处理

115
00:04:42,480 --> 00:04:45,200
那为了实现这个计算机上的

116
00:04:45,240 --> 00:04:46,280
各个应用进程之间

117
00:04:46,320 --> 00:04:49,320
它们是需要有一些通讯交流的

118
00:04:49,360 --> 00:04:52,400
这种交流就是我们这里的同步互斥

119
00:04:52,440 --> 00:04:54,360
也就是说两个进程之间

120
00:04:54,400 --> 00:04:55,520
要想进行通讯

121
00:04:55,560 --> 00:04:56,680
那这个通讯是在

122
00:04:56,720 --> 00:04:58,960
操作系统控制下完成的

123
00:04:59,000 --> 00:05:00,120
操作系统控制下

124
00:05:00,160 --> 00:05:04,240
如何让进程间的信息交流

125
00:05:04,280 --> 00:05:07,520
做的流畅安全

126
00:05:07,560 --> 00:05:10,680
这是我们这部分要讨论的

127
00:05:10,720 --> 00:05:13,160
而下一个文件系统是说

128
00:05:13,200 --> 00:05:14,320
计算机系统当中

129
00:05:14,360 --> 00:05:16,520
数据大到一定程度之后

130
00:05:16,560 --> 00:05:18,040
这个时候就不能简单

131
00:05:18,080 --> 00:05:20,600
我整一张线性表来存这些数据

132
00:05:20,640 --> 00:05:23,280
我们必须把这个数据管理起来

133
00:05:23,320 --> 00:05:26,120
做持久性的保存

134
00:05:26,160 --> 00:05:28,200
而这一部分大到一定程度的时候

135
00:05:28,240 --> 00:05:29,560
就变成系统了

136
00:05:29,600 --> 00:05:30,640
在这个系统中

137
00:05:30,680 --> 00:05:33,160
我们如何来组织这些文件

138
00:05:33,200 --> 00:05:38,120
以便于方便用户的读 写和查找

139
00:05:38,160 --> 00:05:41,720
这也是操作系统也解决问题之一

140
00:05:41,760 --> 00:05:44,920
最后一个是I/O子系统

141
00:05:44,960 --> 00:05:47,880
计算机系统当中CPU 内存

142
00:05:47,920 --> 00:05:50,640
这两个部分种类相对来说比较少

143
00:05:50,680 --> 00:05:52,320
而对于它所能够

144
00:05:52,360 --> 00:05:54,800
涉及的外设会有很多种

145
00:05:54,840 --> 00:05:56,800
那据一种不完全的统计

146
00:05:56,840 --> 00:06:00,080
我们能够连到PC机上的外部设备的

147
00:06:00,120 --> 00:06:02,040
种类应该是上万种

148
00:06:02,080 --> 00:06:05,320
这些差异非常大的这些外部设备

149
00:06:05,360 --> 00:06:07,400
对于计算机系统来说如何连上来

150
00:06:07,440 --> 00:06:09,040
实际上是一个很大的挑战

151
00:06:09,080 --> 00:06:12,600
对于这部分是由操作系统里的I/O子系统

152
00:06:12,640 --> 00:06:14,040
来负责管理的

153
00:06:14,080 --> 00:06:16,640
我们需要把这些差异非常大的

154
00:06:16,680 --> 00:06:18,600
这些设备连到同一个系统上来

155
00:06:18,640 --> 00:06:23,280
并且都能对它们进行高效的控制

156
00:06:23,320 --> 00:06:26,000
比如说我们键盘的速度是很慢的

157
00:06:26,040 --> 00:06:28,480
这个时候你两只手一起敲

158
00:06:28,520 --> 00:06:31,960
你一秒钟也就最多敲几十个按键

159
00:06:32,000 --> 00:06:35,240
而如果说我们用的网络接口是10G的

160
00:06:35,280 --> 00:06:36,760
那这个时候它数据量

161
00:06:36,800 --> 00:06:38,960
在一秒钟就是10GBPS

162
00:06:39,000 --> 00:06:41,040
两者之间的差异是非常大的

163
00:06:41,080 --> 00:06:44,120
操作系统需要在里头提供一个

164
00:06:44,160 --> 00:06:46,840
尽可能统一的接口来管理

165
00:06:46,880 --> 00:06:50,880
尽可能范围大的这些外部设备

166
00:06:50,920 --> 00:06:52,960
从这个角度讲我们这学期

167
00:06:53,000 --> 00:06:55,680
操作系统涉及到的内容是非常广泛的

168
00:06:55,720 --> 00:06:58,160
所以我们这门操作系统课

169
00:06:58,200 --> 00:07:00,640
也是一种介绍性的课程

170
00:07:00,680 --> 00:07:03,040
对于每一个部分深入介绍下去

171
00:07:03,080 --> 00:07:05,120
都会是一个非常专门的

172
00:07:05,160 --> 00:07:07,320
后续课程讨论内容

173
00:07:07,360 --> 00:07:09,120
而围绕着教学内容的安排

174
00:07:09,160 --> 00:07:11,520
我们每一段教学内容后面

175
00:07:11,560 --> 00:07:13,480
都有相应的课堂练习

176
00:07:13,520 --> 00:07:16,280
这是对大家掌握知识情况的了解

177
00:07:16,320 --> 00:07:18,520
和成绩评定的一部分内容

178
00:07:18,560 --> 00:07:21,000
另一个内容是实验

179
00:07:21,040 --> 00:07:23,200
实验基本上围绕着我们前面

180
00:07:23,240 --> 00:07:26,160
教学内容形成八个实验

181
00:07:26,200 --> 00:07:27,640
这里的实验0

182
00:07:27,680 --> 00:07:31,640
是我们教学实验环境的准备

183
00:07:31,680 --> 00:07:34,160
我们在这门课程里头不会去讲

184
00:07:34,200 --> 00:07:37,200
如何使用Linux 如何使用Windows

185
00:07:37,240 --> 00:07:38,280
但是你要想

186
00:07:38,320 --> 00:07:40,800
在已有操作系统上来做我们实验

187
00:07:40,840 --> 00:07:43,840
那你必须知道Windows  Linux如何使用

188
00:07:43,880 --> 00:07:46,040
那这是建立实验环境

189
00:07:46,080 --> 00:07:49,680
希望大家下去之后能够看相关的资料

190
00:07:49,720 --> 00:07:52,520
尽可能熟练使用相应的系统

191
00:07:52,560 --> 00:07:54,560
而下面这八个实验基本上

192
00:07:54,600 --> 00:07:56,280
是围绕着我们前面内容

193
00:07:56,320 --> 00:07:57,640
起动和中断 

194
00:07:57,680 --> 00:07:59,960
对应着我们中断和系统调用

195
00:08:00,000 --> 00:08:03,680
而内存管理到我们这里分成两个实验

196
00:08:03,720 --> 00:08:06,800
物理内存和虚拟存储管理

197
00:08:06,840 --> 00:08:08,280
物理内存管理是

198
00:08:08,320 --> 00:08:11,680
负责物理存储的分配和回收

199
00:08:11,720 --> 00:08:13,880
而虚拟存储实际上相当于

200
00:08:13,920 --> 00:08:17,800
我们把物理存储的存储能力

201
00:08:17,840 --> 00:08:20,560
抽象成一个虚拟的存储界面

202
00:08:20,600 --> 00:08:22,200
让用户在使用的时候

203
00:08:22,240 --> 00:08:23,480
一种明显特征是说

204
00:08:23,520 --> 00:08:25,600
我可以用到比物理内存更大的

205
00:08:25,640 --> 00:08:28,440
一个存储环境

206
00:08:28,480 --> 00:08:31,240
而对于进程和线程

207
00:08:31,280 --> 00:08:33,880
在我们这里分成内核线程管理

208
00:08:33,920 --> 00:08:35,320
和用户进程管理

209
00:08:35,360 --> 00:08:39,000
这两个部分 接下来分别是

210
00:08:39,040 --> 00:08:41,880
处理机调度对应着 实验六

211
00:08:41,920 --> 00:08:45,160
而同步互斥对应 实验七

212
00:08:45,200 --> 00:08:47,120
文件系统对应着 实验八

213
00:08:47,160 --> 00:08:48,880
这样我们所有的这些上课内容

214
00:08:48,920 --> 00:08:50,360
主要内容在这里

215
00:08:50,400 --> 00:08:52,760
都有相应的实验内容和它对应起来

216
00:08:52,800 --> 00:08:55,160
同时我们在这里做的实验

217
00:08:55,200 --> 00:08:58,200
它是一个相互关联的整体

218
00:08:58,240 --> 00:08:59,720
我们在一开始的时候

219
00:08:59,760 --> 00:09:02,000
就给大家一个实验基准代码

220
00:09:02,040 --> 00:09:04,520
然后后面你就往上添你的功能

221
00:09:04,560 --> 00:09:06,800
你每添上一个功能的时候

222
00:09:06,840 --> 00:09:09,760
你的实验系统它处理能力

223
00:09:09,800 --> 00:09:11,720
就比原来会强一些

224
00:09:11,760 --> 00:09:13,640
那你在后续实验的时候

225
00:09:13,680 --> 00:09:16,240
有可能会用到你前面实现的功能

226
00:09:16,280 --> 00:09:18,160
所以在这大家在做实验的时候

227
00:09:18,200 --> 00:09:21,000
一定不要说我在前面做实验的时候

228
00:09:21,040 --> 00:09:22,800
能通过测试就算完成任务了

229
00:09:22,840 --> 00:09:24,360
有可能在后面做实验的时候

230
00:09:24,400 --> 00:09:28,960
会发现前面的实验的代码会有问题

231
00:09:29,000 --> 00:09:30,920
所以在这对前面的实验

232
00:09:30,960 --> 00:09:32,240
要认真仔细去做

233
00:09:32,280 --> 00:09:35,440
可以方便你后边加快你的实验进度

234
00:09:35,480 --> 00:09:38,920
好 这是实验和练习内容

235
00:09:38,960 --> 00:09:40,320
对于学有余力的

236
00:09:40,360 --> 00:09:43,400
我们可以安排课程设计

237
00:09:43,440 --> 00:09:45,680
目前阶段我们课程设计

238
00:09:45,720 --> 00:09:48,680
还是围绕着ucore来进行

239
00:09:48,720 --> 00:09:51,120
大家做实验的环境叫ucore

240
00:09:51,160 --> 00:09:53,200
我们同时维护了一个

241
00:09:53,240 --> 00:09:56,000
它的扩展版本叫ucore+

242
00:09:56,040 --> 00:09:58,880
在那里头我们现在的实验环境

243
00:09:58,920 --> 00:10:00,840
是在X86环境下运行

244
00:10:00,880 --> 00:10:07,560
但实际上我们的ucore+可以在X86 ARM LIPS

245
00:10:07,600 --> 00:10:10,640
等几种不同的CPU平台上运行

246
00:10:10,680 --> 00:10:12,960
并且可以在多种硬件平台上

247
00:10:13,000 --> 00:10:14,600
能直接跑起来

248
00:10:14,640 --> 00:10:17,040
我们目前这个改进和完善工作

249
00:10:17,080 --> 00:10:18,160
还在继续进行

250
00:10:18,200 --> 00:10:23,000
我们现在工作重点是它的模块化

251
00:10:23,040 --> 00:10:25,240
我们已经可以在一些平台上

252
00:10:25,280 --> 00:10:28,960
支持ucore可加载内核模块

253
00:10:29,000 --> 00:10:30,560
那实际上在这里我们希望

254
00:10:30,600 --> 00:10:32,200
能够把这些工作做的更完善

255
00:10:32,240 --> 00:10:36,360
最极致的目标是我们希望和Linux的

256
00:10:36,400 --> 00:10:39,160
内核可加载模块的接口兼容

257
00:10:39,200 --> 00:10:41,440
以至于Linux可加载模块

258
00:10:41,480 --> 00:10:43,360
可以在我们ucore上不用修改

259
00:10:43,400 --> 00:10:45,840
就直接能够编译运行

260
00:10:45,880 --> 00:10:47,360
这样一来我们的ucore

261
00:10:47,400 --> 00:10:49,080
就可以有更多算法

262
00:10:49,120 --> 00:10:50,520
可以加在上头去了

263
00:10:50,560 --> 00:10:53,000
应用程序 如果支持动态链接的话

264
00:10:53,040 --> 00:10:56,000
你可以在里面利用的其它资源也会变得很多

265
00:10:56,040 --> 00:10:59,360
目前我们已经能够在X86-32上

266
00:10:59,400 --> 00:11:00,840
能够有很好的支持

267
00:11:00,880 --> 00:11:03,520
在ARM和X86-64上

268
00:11:03,560 --> 00:11:05,360
也有一些基本的支持了

269
00:11:05,400 --> 00:11:08,120
我们希望继续有同学来完善这个

270
00:11:08,160 --> 00:11:10,520
对于我们现在已经实现的

271
00:11:10,560 --> 00:11:12,040
这些ucore内核功能

272
00:11:12,080 --> 00:11:13,160
我们希望能够对它

273
00:11:13,200 --> 00:11:15,120
进行模块化的改造

274
00:11:15,160 --> 00:11:17,000
文件系统 调度算法

275
00:11:17,040 --> 00:11:19,400
内存置换算法和设备驱动

276
00:11:19,440 --> 00:11:21,280
现在这里头文件系统

277
00:11:21,320 --> 00:11:22,880
处理机调度算法和置换算法

278
00:11:22,920 --> 00:11:24,600
都已经有了一些基本的

279
00:11:24,640 --> 00:11:25,720
模块化的实现

280
00:11:25,760 --> 00:11:28,400
如果说我们这个工作继续做完善了

281
00:11:28,440 --> 00:11:31,280
以后大家做的操作系统的实验

282
00:11:31,320 --> 00:11:32,320
就可能是让大家

283
00:11:32,360 --> 00:11:33,960
我给你一个已经实现的模块

284
00:11:34,000 --> 00:11:37,000
让你去实现另一个完整的模块

285
00:11:37,040 --> 00:11:38,600
这样的话就比我们目前

286
00:11:38,640 --> 00:11:41,400
往里头去添代码片断

287
00:11:41,440 --> 00:11:44,040
能够有更好的训练效果

288
00:11:44,080 --> 00:11:46,080
同时你是一整块有参考

289
00:11:46,120 --> 00:11:48,840
那这个时候它的难度也会有所下降

290
00:11:48,880 --> 00:11:52,120
如果说这些内容你都觉得没有兴趣

291
00:11:52,160 --> 00:11:54,120
那么我们在这里还有更进一步的

292
00:11:54,160 --> 00:11:57,120
我们希望能在真实的硬件环境下去

293
00:11:57,160 --> 00:11:59,200
运用我们的ucore+

294
00:11:59,240 --> 00:12:00,880
  现在我们的ucore+

295
00:12:00,920 --> 00:12:03,960
已经能在树莓派上运行了

296
00:12:04,000 --> 00:12:07,080
树莓派是一款开源的硬件平台

297
00:12:07,120 --> 00:12:09,920
它在这里支持有线的网卡USB

298
00:12:09,960 --> 00:12:12,320
和HDMI视频接口

299
00:12:12,360 --> 00:12:15,360
那在上头能跑标准的Linux

300
00:12:15,400 --> 00:12:16,880
我们的ucore最基本的版本

301
00:12:16,920 --> 00:12:18,360
也能跑起来了

302
00:12:18,400 --> 00:12:22,480
但是对它的HDMI接口支持并不是很好

303
00:12:22,520 --> 00:12:24,240
我们只能把它的HDMI接口

304
00:12:24,280 --> 00:12:28,400
当一个简单的最基本的VGA功能来使用

305
00:12:28,440 --> 00:12:31,280
我们希望能够在上面做更完善的支持

306
00:12:31,320 --> 00:12:34,320
右边是别人已经做成的一个

307
00:12:34,360 --> 00:12:37,640
基于树莓派的集群系统

308
00:12:37,680 --> 00:12:40,680
那这是这个系统的作者和他的结果

309
00:12:40,720 --> 00:12:41,960
我们希望有同学后面

310
00:12:42,000 --> 00:12:44,480
能给出来你的结果

311
00:12:44,520 --> 00:12:49,560
然后再有一个这是2014年英特尔新出的

312
00:12:49,600 --> 00:12:53,720
一个小的SOC

313
00:12:53,760 --> 00:12:55,640
这是Edison

314
00:12:55,680 --> 00:12:59,880
我们在前边也在Edison早期版本上

315
00:12:59,920 --> 00:13:01,560
运行过我们的ucore

316
00:13:01,600 --> 00:13:03,600
但是现在这个Edison上面

317
00:13:03,640 --> 00:13:05,280
我们还没有做到这件事情

318
00:13:05,320 --> 00:13:07,840
这个Edison相当于十多年前

319
00:13:07,880 --> 00:13:10,040
我们一台PC机的处理能力

320
00:13:10,080 --> 00:13:15,440
目前这个核心的部件上有WIFI  有蓝牙

321
00:13:15,480 --> 00:13:17,040
400M的双核的CPU

322
00:13:17,080 --> 00:13:19,880
并且有一个100M的MCU

323
00:13:19,920 --> 00:13:24,920
与此同时它还有1G的内存和4G的FLASH

324
00:13:24,960 --> 00:13:27,440
所有这些都是处理能力很强的

325
00:13:27,480 --> 00:13:29,960
我们希望在上面能跑起我们的ucore

326
00:13:30,000 --> 00:13:32,080
并且能够用它来做一些

327
00:13:32,120 --> 00:13:35,360
更有创意性的应用

328
00:13:35,400 --> 00:13:36,960
  

329
00:13:37,000 --> 00:13:40,240
如果这些问题都不满足你的兴趣

330
00:13:40,280 --> 00:13:41,800
或者说你有更好的建议

331
00:13:41,840 --> 00:13:43,920
我们也支持自选的

332
00:13:43,960 --> 00:13:46,120
操作系统课程设计的题目

333
00:13:46,160 --> 00:13:49,080
如果你有这个兴趣你可以告诉老师

334
00:13:49,120 --> 00:13:51,040
你也可以从我们WiKi上

335
00:13:51,080 --> 00:13:55,640
看到往年做这些课程设计的同学

336
00:13:55,680 --> 00:13:57,240
他们给出来的结果

337
00:13:57,280 --> 00:13:58,920
我们希望到最后做出来之后

338
00:13:58,960 --> 00:14:01,920
你提供你的报告和你的视频

339
00:14:01,960 --> 00:14:04,720
我们来看做出来最后的结果

340
00:14:04,760 --> 00:14:06,800
希望这些介绍有利于大家

341
00:14:06,840 --> 00:14:09,600
掌握我们在操作系统课里到底讲什么 

342
00:14:09,640 --> 00:14:10,960
大家能学到些什么

343
00:14:11,000 --> 00:14:11,000


